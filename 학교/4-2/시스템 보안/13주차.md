40. 머신코드의 리턴 return orientied programming
41. system("/bin/sh")하면 루트 셸 획들 불가
	1. 이유: 파라미터로 들어오는 것을 루트 셸로 실행하기 때문에
	2. /bin/sh -c /bin/zsh를 실행하는 것이기 때문에
42. ROP(원래는 프로그래밍 기법인데 악용)
	1. call 대신 return 사용
	2. cll,push eip/jmp 0x.... 
	3. ret: pop eip(스택에서 빼옴 -> 스택에 이전함수 시작 주소 있어야 함)
43. main과 foo에서 bar,baz 호출 안함 
	1. 코드 안에서 ebp값 보고 싶어서 framep? 넣어놓고 출력
44. bar 함수를 ret 이용해서 여러번 호출
45. **~={red}시험=~** ebp 추적하는 이유: return address 덮어씌우기 위해서
	1. call이 아닌 ret를 이용해서 bar()로 넘어감
	2. foo함수의 return address 영역에 bar()주소 계속 넣음
46. 112,4,4x10,4(0xaa,0xFFFFFFFF,bar_addr,exit) 총 160바이트 content 배열이됨
	1. 왜 113-116에 0xFFFFFFFF? 리턴 주소 없애기 위해서
47. static: 딱 한번만 초기화 하는 변수(카운팅 하기 위해서)
	1. static 안쓰면 모두 1 나옴
	2. FFFFFFFF(ebp)에서 에필로그 시작해야함
	3. 에필로그 중에 bar 함수 주소 있으니 bar의 프롤로그 시작 -> bar 프롤로그 시작 -> bar 에필 -> bar 프롤로그 -> 반복...
	4. 결론: bar함수의 시작 주소가 return address가 된다
48. bar함수에 공격자를 넣어야 함 => 3번까지만 매개변수 넣을 수 있음
	1. 함수의 매개변수는 ebp + 8에 위치해 있음
49. 4번째 부터 매개변수가 들어갈 공간을 찾아야 한다
	1. Y가 답=> 쓰레기인 ffffffff를 넣는 곳에 원하는 위치를 넣어두면 원하는 곳으로 점프 가능(이전 ebp인 y로 이동)
	2. but, mov esp ebp로 인해 다시 x + 4로 되돌아옴(rollback)
50. 프롤로그 스킵해서 해결
51. 현실은 프롤로그가 없는 libc가 있다
---
체이닝 할때 인자가 있으면 프롤로그 skippping
3바이트 더하면 프롤로그 스킵함-프롤로그가 3바이트이기 때문에
53. 현실: printf에는 프롤로그가 없음
	1. printf가 호출되자마자 다른 함수를 호출함
54. 프롤로그 없을 때-가상의 empty함수를 사용
	1. A -> empty 프롤로그를 이용해 프롤로그 스킵후 에필로그
	2. 결론: empty 프롤로그 건너뛰고 empty의 에필로그만 이용
55. 그림
56. empty는? leave와 ret이용해서(에필로그) => 아무함수의 시작 주소 넣으면 leave ret알아서 된다
57. 고급 shell을 사용하면 공격이 의미가 없어서 setuid(0)을 넣어줘야 하는데 0을 어떻게? => spirntf 사용(버퍼에 출력하는 함수)
	1. src + null을 destnation에 copy함
	2. 0x00을 가리키고 있는 명령어 주소 알아내서 sprintf의 src에 넣음 => 1byte씩 4번 호출하여 0000을 채움 -> setuid 호출 -> system("bin/sh") -> exit()