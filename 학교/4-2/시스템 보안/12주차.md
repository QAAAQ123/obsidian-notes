17. buffer에 A로 채우고, saved ebp에 b로 채우고 리턴 주소에 e08a... 담고, 위에 AAA,그위에 f9... => exploit 총 96바이트
18. bin/sh에 시작 주소 넣은 이유: system() 함수의 파라미터를 bin/sh로 채우기 위해서 => system(bin/sh)가 됨
19. ㅋㄷ
20. ㄷ
21. 코드
22. 환경설정 3개
23. systme 함수 주소 찾기 ->/bin/sh 주소 찾기 ->system함수의 매개변수 설정
24. A: system함수 주소 찾기: 디버거로 찍어보기 system,exit/랜덤 옵션 껐으니 위치가 항상 같다
25. B: bin/sh주소값 찾기 (환경변수 주소값)/export MYSHELL
26. B코드
	1. getenv로 찾기 =>if로 제대로 가져 왔다면 문자열 주소 출력
	2. %s:문자열
	3. %x:16진수(unsigned int) shell로 10진수로 변환하기 위해서
	4. 1.컴파일,2.myshll export,실행
	5. 자식 프로세스에서 실행(export이기 때문에)
27. B
	1. mv해서 옮기면 /bin/sh의 주소값이 달라짐
	2. 프로그램이 실행되고 있을 때 있는 환경변수들
		1. 바이너리의 env55,env7777의 바이트가 늘어났기 때문에
		2. 2바이트가 밀려서 환경변수의 주소값이 바뀐다. -> 프로그램이 변경될 때
28. C: system() 매개변수 넣기
	1. 프롤로그 push ebp => esp to ebp => esp = esp -nbyte(지역변수를 위한 공간)
29. C: 에필로그
	1. ebp to esp 복사 => pop ebp: 스택 최상단(이전 ebp값)을 ebp에 넣음
	2. ebp: 이전 함수로 올라감,esp: 한칸 올라감
	3. ret: pop eip(call할때 push했던 값을 꺼내서 eip에 저장) + esp감소
30. 왼쪽 어셈블리어 foo함수
	1. 프롤록,에필로그 leave = movl = popl
	2. a=x;의 어셈블리어 movl 2개 ebp+8값=eax,ebp-4=eax
---
수요일
32. ||esp|ebp|
    ||x|x|
	|에필|x+4|Y|
	||x+8|Y|
	|프롤|x+4|Y|
	||x+4|Y|
33. 중간에 call이 없어서 이상하게 동작한다(push eip없이)
	1. (a) 12바이트 차이남
	2. 핵심:argument와 ?
34. ㄷ
35. ㄷ
36. 112-116,116-120,120-132
	1. system시작 주소,exit시작 주소,/bin/sh시작 주소
	2. 원래는 100바이트인데 300바이트 덮어씌움
37. 정리
38. 랜덤,스택가드 끔/주입 불가함
	1. 단점 구현 복잡
39. ASRL: 100%막을수 있는것 아니다
	1. CFI: 100%막음,무결성 런타임 검증-흐름 그래프에서 벗어나는 움직임을 보일때
40. ROP: return to libc 진화 형태