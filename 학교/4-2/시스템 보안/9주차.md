**~={red}기본 코드 분석 그림 없는 부분 그리기,설명 시험=~**
함수 종료전에 계산 되었던 값들은 eax에 있다
fork() 시스템 콜 처리
	eax는 시스템콜 함수 안에서 sys_call_table의 인덱스 역할을 한다. 시스템 콜에서 뭐를 실행해야 할지 알려주는 인덱스
### 수요일 수업
40. 시스템 콜: 유저모드에서 HW 사용할 수 있게 하는것
	1. fork() => 자식 프로세스 생성하는 함수
	2. 직접 접근하지 못함 -> 운영체제에서 한번 판단함
41. ㄷ
42. 시스템 콜 예시
	1. int -> 인터럽트
	2. idt -> interupt description table => 인터럽트시 어떻게 할지 정해놓은 테이블
	3. 0x80 => 시스템 콜 실행
	4. movl 2 -> 2를 sys_call_table에서 찾아서 사용
43. idt 
44. 시스템 콜 개수 늘어나고 있음
45. shell code : 셸을 띄우는 머신 코드
	1. 왜 중요?: 공격자가 (su권한) 셸을 얻으면 모든것 할 수 있기 때문에
	2. 어셈블리or머신코드 이용해서 공격
46. e
47. c로 셸 얻기
	1. execve: 명령어 실행하는 시스템 콜
48. 바이너리 파일을 어셈블리로 보여주는 코드
	1. 공격자가 어셈블리를 얻기 위해 dump 한것
	2. 최대한 작게 작성해야 함 -> 크기가 크면 공격이 걸릴 위험이 높아지기 때문에
	3. 00 00 00 == NULL
	4. 공격자 입장에서 NULL이 있으면 안됨
	5. injection => 메모리에 주입시킨다
	6. strcpy단점: NULL값을 만나면 멈춘다. 따라서 copy하려고하는 '머신코드'에 NULL이 있으면 안된다(공격하기 위해서)
49. 일반적으로(실제로) injection은 stack에 한다
	1. execve 실행할 때 eax,ebx,ecx,edx에 값
	2. eax: 0x0b(=11)(=execve)
	3. ebx: /bin/sh의 시작 주소 값
	4. ecx: argv의 시작 주소 값
	5. edx: 0
	6. => 하지만 edx를 0으로 하면 공격할때 strcpy때문에 0이 있으면 안됨
50. 49페이지 해결 방법: xor edx,edx => 결과가 edx에 0을 저장하는 결과
	1. //sh => 아스키코드 4byte
	2. mov: /bin/sh의 시작주소를 ebx에 저장
51. argv[0] : 명령어 시작 주소,argv[1]
	1. esp값: argv의 시작주소 가리킴
	2. esp값을 ecx로 옮김
52. edx 세팅
53. eax를 0x0b로 세팅 해줘야함
	1. eax초기화
	2. al에 0x0b넣음
	3. 인터럽트
54. 모아보기,어셈블리에서 주석은`;`이다
55. object파일을 바이너리 파일로 바꿈(54의 코드를)
56. shell 띄우기 위한 최소 코드,null 해결 못함
57. 56을 이어 붙힌 것
	1. `void(*func ~~~~~ shell)`: 함수 포인터
	2. func() 실행하면 EIP가 shell 배열을 바라보기 때문에 shell을 실행한다.
	3. shell배열은 BSS(전역변수)에 들어가 있는 상태
	4. func를 stack에 넣음
	5. func의 shell배열을 명령어로 인식하여 실행
	6. 결론: EIP가 shell배열을 바라보게 만들면 된다.
58. e

