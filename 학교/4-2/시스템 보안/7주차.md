### Ch5. 어셈블리 언어
- 오버플로를 이해하기 위한 어셈블리 언어
2. 80386부터 4GB 메인 메모리 사용(32bit)
3. 컴퓨터 구조 전체 그림
	1. 메모리=RAM
	2. I/O Bus 실제: 메인보드 연결 단자
4. 명령어 사이클
	1. C언어 컴파일 하면 실행파일 나옴(바이너리 파일)
	2. 바이너리파일 안에는 기계어 밖에 없음
	3. 실행하면 '바이너리 파일'이 메모리에 올라가고 이게 프로세스가 된다
	4. CPU에서 기계어 실행함
5. ALU 
	1. 가산기,보수기,시프터로 구성
6. 제어 장치
	1. 명령어 해독기: 해독/부호기/주소해독기: 메인 메모리 주소 해독
7. 레지스터: CPU내의 기억 장치
	1. 범용 레지스터에서 예전에 16비트 많이 사용함
	2. AX의 상위: AH/AX의 하위: AL/BX의 상위: BH/BX의 하위: BL
	3. 16비트에서 extended 붙혀서 32bit는 EAX,EBX
	4. **RAX의 하위 32bit:EAX**
	5. **EAX의 하위 16bit:AX**
	6. **AX의 상위 8bit:AH**
	7. **AX의 하위 8bit:AL**
8. 레지스터2(파란색이 자주 사용됨)
	1. EAX(accumualtor): 누산기
	2. EBX(Base): 특정 주소 저장
	3. ECX(count):반복적 실행 저장(루프나 좌우 비트 시프트)
	4. EDX(data): 데이터(일반 자료) 저장
	5. EAX,EBX,ECX,EDX: 범용 레지스터
	6. S로 끝나면 세그먼트 레지스터
	7. 세그먼트 레지스터: 세그먼트(논리 단위) 주소 저장
9. 레지스터3
	1. EBP(Base Pointer): **현재 사용하고 있는 함수의 시작 주소**
	2. ESP(Stack Pointer):스택의 가장 끝 주소 가리킴-스택 구조 때문에
	3. EIP(Instruction Pointer):다음에 수행할 명령의 주소
	4. EDI,ESI => 인덱스 레지스터
10. 플래그 레지스터 -> 파란색과 빨간색이 중요함
	1. 상태 표시하기 위해서 사용한다
	2. ZF: 0인 상태인것 알려줌(Zero Flag)
11. 레지스터5
	1. 연산 관련 레지스터, 제어 관련 레지스터로 구성되어 있다
12. 메모리 기본 구조-32비트 기준
	1. stack,heap,data segment,bss segment,text segment
	2. 0x: 16진수
	3. 0x00 00 00 00 => 숫자 하나에 4bit이기 때문에 숫자 2개에 1byte, 총 4byte이다
	4. 2^32 byte = 4GB => 32GB메모리에서 한 프로세스가 가지는 메모리의 양
	5. 0xFFFFFFFF이상 지칭 할 수 없다(메모리 안에서)(2^32 까지 접근 가능)
	6. stack영역,Heap영역,...
	7. ~={red}stack은 아래로 쌓이고=~,Heap은 위로 쌓인다.
	8. Heap: 동적 메모리 할당 ex)c의 malloc() => 시작 주소 리턴
	9. **ESP: 스택의 top을 가리킴**
	10. **EBP: 현재 사용하는 함수의 시작 주소**
13. 메모리 구조2
	1. Heap
	2. 예시 1000바이트 시작 주소 값 가짐
	3. P가 저장하는 값은 1000바이트 배열 시작하는 주소값 저장
	4. 그래서 32bit에서 모든 포인터 변수는 4byte임
	5. 64bit에서 모든 포인터 변수는 8byte
	6. 데이터 세그먼트: 초기화된 전역변수와 정적 변수 저장
14. 메모리구조3
	1. BSS(Blocked started segment)
		1. 초기화되지 않은 전역 변수와 정적 변수 저장
		2. 실행 될 때 0이나 null로 초기화
	2. 텍스트 세그먼트: 기계어가 저장되는 공간
15. 음수 표현 법
	1. 부호화 절댓갑: MSB 0이면 양수,1이면 음수
	2. 1의 보수: 0은1로 1은0으로 변환하여 음수 표현
	3. 2의 보수:1의 보수에서 1더하여 음수 표현
16. 어셈블리언어는 컴퓨터가 인식하지 못한다. 어셈블러를 통해 기계어로 바꿔야 컴퓨터가 인식한다
17. 어셈블리어: 기계어를 니모닉 코드로 표현한 것
18. 어셈블러: 어셈블리 언어를 기계어로 변환
19. 어셈블리어 데이터 타입
	1. 바이트(1byte),워드(2byte),더블워드(4byte)
20. 바이트 정렬 방식: 회사마다 다름
	1. 빅엔디안: 상위 바이트(MSB)를 작은 번지에 저장
	2. 리틀 엔디안: LSB를 작은 번지에 저장
21. 어셈블러 구조: 서로 반대
	1. 윈도우 mov EXA,1: 1을 EXA에 저장/메모리[]
	2. 리눅스 movl $1,%EXA: 1을 EXA에 저장/메모리()
22. 주소 지정 방식1:Register Addressing-레지스터 주소 지정
	1. 레지스터의 주소값 지정 복사,속도 가장 빠름
	2. EBX 주소를 EAX에 카피
23. 주소 지정 방식2:Dircet Addressing-직접 주소 지정 방식
	1. Segment:[offset]형식으로 메모리에 접근
	2. 데이터 세그먼트(DS)가 시작되는 곳에서부터 0012FF78h만큼 떨어진 메모리 주소에 있는 4바이트 값을 EAX 레지스터로 가져와라
24. 레지스터 직접 주소 지정 방식**~={red}(참고:현대 리눅스 OS의 DS는 대부분 0x000000이다)=~**
	1. MOV EAX,[EBX] : EBX에 대응하는 DS에서 EBX만큼 떨어진 메모리 주소에 있는 바이트 값을 EAX 레지스터로 복사해라
	2. MOV EAX, CS:[EBX]와 같은 형식으로 사상되지 않는 세그먼트 강제 지정 가능(DS에서 CS로 바뀜)
25. 인덱스 주소 지정 방식
	1. 레지스터 간접 지정 방식에 변위를 더하는 방식
	2. `MOV EAX, [EBX+20h]`: EBX에서 16진수 20만큼 떨어진 곳에 있는 바이트 값을 EAX에 복사해라
	3. MOV EAX,20h[EBX] 로도 표현 가능
26. 베이스-인덱스 주소 지정 방식
	1. 베이스 레지스터와 인덱스 레지스터를 결합한 방식
	2. MOV EAX,[EBX+ESI] : DS에서 EBX+ESI한 위치의 byte값을 EAX에 복사해라
	3. `[EBX][ESI]` 로도 표현 가능
27. 베이스-인덱스 변위 주소 지정 방식
	1. 베이스-인덱스 주소 지정 방식의 변형
	2. MOV EAX,[EBX+ESI+20h]
28. 명령어 형식: 연산자는 반드시 1개,피연산자는 없거나 2개
	1. 명령어의 기계어 포맷(명령어마다 바이트 수가 다름)
		1. 차지할 수 있는 바이트 수
	2. 4 3 1 1 4 4 byte
29. ㄷ
30. 어셈블리언어 기계어로 바꾸는 방법
	1. 예시 EAX + EBX
		1. 03 => add는 1byte연산
31. ADD EAX,EBX->03 /r -> 03 c3->0000 0011 1100 0011(2byte)
--- 
30. 기본 문법(윈도우): ADD EAX,4 : EAX = EAX + 4
	1. SUB EXA, 4 : EXA = EAX - 4
31. 문법2
	1. CMP 비교: 데이터 변경 안 일어남
	2. 플래그 레지스터에 ZR이 변함-CMP가 같으면 ZR=1,CMP가 다르면 ZP=0
32. 기타 명령어 36x
33. ㄷ
34. ㄷ
35. ㄷ
36. ㄷ
37. 문법: 전송 MOV 1,2: 2->1로 복사
	1. 값: 메모리 주소 값/[값] => 메모리 주소안에 들어 있는 값
38. PUSH: 데이터를 stack에 삽입-스택 커지고 스택 포인터(ESP)는 감소 
	1. 피연산자 1개
	   ex) PUSH EBP(EBP: 스택의 베이스 포인터-함수의 시작지점 포인터)
39. POP: 데이터 삭제하고 피연산자에 담고 ESP증가
	1. 지워지지는 않지만 ESP가 가리키지 않아서 ESP증가
40. LEA 주소값 자체를 1에 저장
41. 기타
42. 논리 AND 1 2 => 계산해서 1에 저장
43. OR연산
44. XOR연산 => AND와 똑같히
45. NOT 각 비트 반전,연산자가 1개
46. TEST: **~={red}AND연산의 결과=~**가 0이면 ZR=1,1이면 ZR=0(조건문)/값 저장 안함
47. 기타: 위 2개 shift연산은 많이 쓰임
48. 문자열: REP??
	1. 배열 문자열 이름: 시작 주소값
49. 기타
50. JMP: 무조건 점프
	1. JMP 주소값
	2. EIP: 수행할 명령어 가리킴
	3. 누가 가는지 EIP값 <- 주소값
	4. EIP로 주소값 들어감
51. 조건부 점프
	1. JE/JZ 많이 사용
	2. JBE/JNA
52. 조건부 점프2
	1. JNE/JNZ
53. 제어 전송 CALL: 함수 호출
	1. CALL(함수 시작 주소) 
	2. PUSH EIP:EIP주소값을 스택에
	3. JMP: EIP값을 EIP에 넣음
	4. RET: return-호출 한 곳으로 돌아감
	5. Stack이 저장된 되돌아갈 주소로 돌아감
54. LOOP
	1. ECX값이 0이 될 때까지 반복
	2. EAX :32,AX:16
	3. INT 커널 영역으로 들어가는 명령어(시스템 콜)-시스템 콜 호출
55. 프로세스 제어 STC,NOP
	1. NOP: 효율적으로 byte를 맞추기 위해서(4byte단위가 효율적이여서)