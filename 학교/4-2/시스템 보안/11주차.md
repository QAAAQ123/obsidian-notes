17. Task B-악성코드 주소(셸 띄우는 코드)
	1. 가상메모리 랜덤 끄는 옵션
18. 랜덤을 끄기 어렵기 때문에 확률을 높힘
	1. NOP-0x90은 1바이트
	2. 애매한 곳에 NOP를 넣어서 계속 넘어가면서 악성 코드를 실행할 확률을 높힌다
19. badfile구축
	1. distance 112바이트
	2. 시작 주소부터 리턴주소까지 112개 NOP
	3. RT에 shellcode의 시작주소가 아닌 NOP로 채워 돌아가게 한다
	4. 왜? 주소가 랜덤으로 컴파일되기 때문에
	5. NOP을 따라가다보면 악성코드를 실행할 수 있기 때문에
	6. +중간에 0x00이 나오면 안된다(strcpy때문에)
20. 300바이트 NOP세팅 ->셸코드 넣어줌 ->RT 수정
	1. 총 2곳 수정함(셸코드와 RT)
21. 허접한 shell로 바꿔야 한다.
22. 저장순서(빅,리틀 앤디안)
23. shellcode 24바이트
24. 예방법
	1. 운영체제
		1. ASLR(랜덤 메모리주소)
		2. 셸 프로그램 방어
		3. Non-executeable stack(실행 불가능한 스택)
			1. 스택에 EIP가 접근해서 실행하는것 자체를 차단(스택주소에 EIP가 접근하는게 비정상이기 때문에)
	2. 컴파일러-스택 가드
25. 개발자 입장-secure 코딩법
26. ASLR-운영체제 예방법
27. ASLR[x->stack, y->heap]=>주소 출력
28. 옵션 
	1. ASLR 0: heap,stack모두 랜덤화하지 않음
	2. ASLR 1: 스택만 랜덤화
	3. ASLR 2: heap,stack모두 랜덤화
29. ASLR 무력화 방법
30. ASLR 무력화 방법 => 스크립트 만들어서 무한루프 될때까지 돌림
	1. 메모리 한정적 => stack 영역이 정해져있기 때문에 확률상 터진다
31. 한번만 공격해도 성공임
32. OS2: set-uid권한 자동으로 다운
33. OS2 무력화 방법
	1. 중간에 setuid(0)넣음(RUID=0) => 셸 실행 직전에 root가 되게 설정
34. OS3: 스택 직접 실행 불가능하게 
	1. 우회 방법: return to libc공격
35. stack guard 값을 컴파일러가 만들어서 집어넣음
	1. 리턴하기 직전에 stack guard를 보고 변경되어있으면 실행안함
36. stack guard=>canary라고 부름
	1. canary세팅(볼드체)
	2. %gs:20에 시크릿값 저장되어 있음
	3. 리턴할때 값을 다시 eax로 가져와 xor연산으로 함수 실행후 전후 값 비교
	4. 같으면 정상,다르면 call
---
heap오버플로우 안나옴
## ch8. 컨트롤 하이재킹 공격
2. 순서
	1. 순허 흐름 탈취
	2. call 이용하여 공격
	3. eip값을 조작해야함
	4. 예시- 코드 주입 공격(->버퍼 오버플로),코드 재사용 공격(->컨트롤 하이재킹 공격)
3. CFG(제어흐름 그래프)
	1. 노드: basic block
4. 주입 VS 재사용 공격
5. 주입 공격-원하는 만큼 머신코드 주입
   ex)셸코드
6. 악성흐름 만들어냄(3->a)
7. 코드 재사용 공격
	1. 재사용해서 의도하지 않은 방향으로 틈
	2. 핵심: 원래 있던 코드영역으로 이동시킴
	3. 주입 공격: 공격자가 주입해서 공격
	   예)Return-to-libc,Rop,Jop
8. 재사용은 머신코드가 아니다 -> 이미 가지고 있는 블록이다
	1. 간선을 바꾸는게 핵심이다(eip)
9. e
10. 왜 reuse공격이 생겨났는지
	1. 코드 주입 공격이 막히자 피해서 재사용 공격이 나타남
	2. 여전히 바라보는 영역은 코드 영역이다
11. return-to-libc
12. 함수 포인터: 매개변수의 타입이 같아야 함수 포인터 선언 가능
13. 배열을 함수로 바라보게끔 변경해서 -> 셸코드 실행함
	1. buffer 대신 code를 넣으면 어떻게되는지 => **~={red}시험=~**
14. 컴파일 옵션
	1. segmentation falut=>메모리 참조 오류
15. nx비트 무력화 방법
	1. 기존에 있는 코드 사용하자
	2. 헤더파일에 함수의 원형이 있음(이름,매개변수)
	3. system함수도 libc에 있다 -> 공격 가능
	4. 결론: system의 시작주소를 return address에 덮어씌우면 됨
	5. libc-리눅스 기초 라이브러리(함수의 바디 부분)
16. 환경변수도 메모리에 올라가 있음
	1. 그냥 라이브러리 함수로 점프시킴
