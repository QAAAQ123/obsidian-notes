23. man-manual 명령어
	1. section 명시하면 그에 따른 내용 보여줌 ex) `main 1 <examplefile>`
	2. 섹션1: 명령어 관련/섹션5: 파일 포맷
	3. passwd는 user/bin/passwd에 있다
	4. 환경변수가 있기 때문에 절대경로를 모두 입력하지 않아도 된다
	5. man1은 bin/passwd이고 man5는 파일 포맷 관련이기 때문에 etc/passwd이다
24. chown = change owner/chsh = change shell/touch
25. 리눅스는 멀티 유저 기반
	1. 유저ID는 유니크한 ID값을 가지고 있어야 함
	2. root/etc/passwd안에 UserID가 저장됨
	3. 유저 알고 싶을때 `$id`
	4. 일반 유저는 1000번대 부터 시작
26. UID와 GID 찾기
	1. ~={red}1000번부터 유저가 생성한 ID 그 이전은 시스템이 선점한 유저(0번은 root)=~
	2. get 명령어: 찾기
	3. more: 페이지 넘어가지 전까지의 정보 보여줌,스페이스바로 다음 화면 넘어감
27. 그룹-한명의 유저가 여러개의 그룹에 속할수 있음
	1. groups: 현재 유저가 속해있는 그룹만 보여주는 명령어
	2. grep: 필터링 관련 명령어
28. adduer: 새유저 생성
	1. sw: switch to another user
	2. `~`: 본인의 home 디렉토리를 나타내는 기호
	   ex) seed 유저면 ~는 /home/seed이다
29. 유저는 UID,GID,Password를 가진다
	1. Root유저로 할 수 있는 것들 목록
	2. **~={red}시험: 루트는 다른 사용자의 비밀번호를 볼 수있는가?=~**???
			1. **~={red}볼수 없다. salt와 함께 해쉬된 값이 들가있기 때문에=~**
30. root = superuser
31. xxx
32. 허가 모델(permission model)
	1. 파일 접근 권한: r,w,x로 나뉨
	2. x: 프로그램이나 스크립트일때 실행 할 수있는 권한
	3. ls -l로 권한에 관한 정보를 볼 수 있음
33. file permission
	1. 리눅스의 모든 파일은 소유자와 소유그룹을 가진다.
	2. `-`는 파일,`d`는 디렉토리
	3. 파일 오너(소유자)/소유그룹(소유자 제외)/그외 모두
34. 퍼미션 비트 구성
	1. symblic link => 윈도우의 바로가기 링크
	2. t-디렉터리만 적용 가능한 퍼미션: 파일 추가만 가능하고 삭제 불가
35.~={red} defualt 파일 퍼미션: inital-umask로 defult 파일 퍼미션 조정=~
	3. 우분투 기본 세팅:666
	4. umask로 사용자가 666에서 빼줄수 있음
	5. initial-umask(2진수 뺄셈)
	6. `umask`: 현재 umask 보기
	7. `umask xxx`: umask 변경
	8. 권한이 `--- --- --- `일때 해당 파일의 권한은 root만 가진다
36. 개개의 유저의 권한을 따로 줄 수있음
	1. getfacl: 파일의 자세한 권한 보기
37. setfacl: 파일에 자세한 권한 부여
	1. 특정 사용자or그룹에 대해서 권한 부여
	2. **~={red}유저나 그룹이 이미 생성되어있는 상태에서만 권한을 부여할 수 있는지? 아니면 없어도 권한 부여하면 자동으로 생성되는지=~**
		1. **~={red}이미 존재하는 유저에 대해서만 setfacl로 권한 부여 가능=~**
	3. ls -l로 본 퍼미션에서 +가 있으면 setfacl로 세부적을 권한 부여함
38. xxx
39. 커맨드 매커니즘: 1. sudo,2.set-uid,3.POSIX
	1. 이 챕터에서는 set-uid를 다룸
40. sudo 사용
	1. sudo를 사용할수 있는 권한을 부여 받아야 sudo를 사용할 수 있음
	2. sudo 권한과 계정은 별개
	3. ~={red}etc/sudoers에 sudo를 사용가능한 사용자와 그룹이 있음=~
41. 루트
	1. 20.04부터 루트가 잠겨져 있음
	2. 루트 권한(Shell)로 들어가는 방법 sudo -s,sudo bash,su
	3. ~={red}루트 계정으로 shell을 하는 것을 비추천 -> 필요한 루트 권한만 sudo로 실행하는 것을 권장=~
42. sudo사용
	1. etc/sudoers에 접근 할 수 있는 권한 440 => sudo권한으로 접근 => password 입력 => etc/sodoers 접근 가능
	2. 다른 유저의 권한으로 실행하는 명령어: sudo -u `유저id`
43. POSIX
	1. 리눅스 운영체체간 상호호환 가능한 인터페이스 형태로 만들어진 ~={red}프로세스 권한 부여 명령=~
	2. getcap/CAP_NET_RAW
44. File capalibity 예제 => UID의 권한(rwx)와는 별개로 동작함(**프로세스 단위 권한 부여**)
	1. 1. 복사 2.실행 3.mybash에서 실행 4. shadow읽기 실패
	2. **~={red}setcap=~**으로 mybash에 읽기 권한 줌 2. mybash실행 3.mybash실행 됨 + **~={red}getcap=~**
	3. 실행된 상태에서 shadow파일 읽기 가능 2.~={red}읽기 권한만 부여했기 때문에 쓰기는 불가=~
	4. <:읽기>: 쓰기
45. 권한 보기: getcap
	1. 와이어 샤크가 어떻게 네트워크를 보는 권한을 가져서 사용자에게 네트워크를 보여주는지 설명
	2. 핑: 핑이 어떻게 네트워크 접근 권한을 가져서 사용자에게 핑을 보여주는지 설명
	3. net_raw로 네트워크 권한 부여
	4. 패킷의 구성: MacHeader/ipHeader/TCP|UDP
		1. TCP or UDP는 포트이다. OS가 어느 프로그램으로 패킷을 보낼지를 포트 번호가 결정한다
		2. raw_socket: 패킷을 분리해서 받지 않고 전체다 받는 권한 
46. sudo,~={red}POSIX->getcap,setcap=~,set-uid
#### 수요일 수업
46. 유저 인증
	1. 인증-내가 맞는지 인증/인가-인증 한 뒤에 권한이 있는지
47. 인증
	1. 패스워드: 무엇을 알고 있는지
	2. ID카드: 무엇을 가지고 있는지
	3. 유저 자체: 얼굴,지문,동맥 등
	4. 2차 인증: 예시-OTP(Onetime password)
48. 패스워드
	1. 해쉬값으로 저장
	2. 동일한 해쉬 함수로 인증
49. shadow에 password가 저장되어 있다(해쉬된 Password 저장)
	1. ~={red}passwd에는 pw가 없다=~-원래 unhashed pw가 passwd에 저장되어 있었는데, 보안문제로 passwd에서 pw제거
	2. Group
	3. UID: 0 root/1-999: 시스템이 미리 선점하고 있는 UID
	4. /etc/passwd,/etc/shadow,/etc/groups
50. 원래 passwd에 pw저장했었다가 shadow에 hash된 값 저장하는 것으로 변했다
51. **~={red}(시험)=~** etc/passwd의 구성-~={red}유저이름:pw(실제로는 없어서 x로 표시):UID:GID:주석:홈디렉토리:shell=~
	1. 홈디렉토리: 유저의 시작 공간/반드시 home디렉토리 아래에 있을 필요가 없음
	2. shell: remote(원격)으로 접속시 보이는 화면
52. shadow파일의 마지막(쉘) 특정 유저
	1. 데몬의 로그인: nologin=>**로그인 자체 불가**
	2. tss의 로그인: bin/false => **로그인 가능,but 쉘 사용 불가**
	3. 데몬과 tss의 nologin,false의 목적: 외부 사용자가 접근하지 못하고 내부에서만 사용하기 위해서
53. ~={red}shadow 파일 내부=~
	1. `user_id$hash알고리즘 번호$salt$pw hashed값`
	2. salt+pw를 해쉬한 값이 들어가고,salt의 원본도 같이 저장되어 있다
		1. salt
			1. 무작위 공격에 방어하기 위해
			2. 유저 password 보호
			3. 유저의 pw가 서로 같을 때 서로 다른 salt값을 사용하면 보호 가능성 높아짐
54. `$id$salt$hash$`가 중요
55. hash펑션
56. ㄷ
57. salt값은 os가 만들어줌/salt + 사용자 입력을 합쳐서 pw를 hash function에 넣고 돌림=>결론: salt,pw를 같이 저장
58. ~={red}pw인증 과정=~
	1. pw생성: 랜덤salt + input pw
	2. pw인증: 저장된 salt + 입력한 pw => hash function을 돌려 이미 저장되어있는 salt+pw값과 비교
59. ~={red}`!` => root가 lock 걸려있다는 표시
	1. 이때 root 계정은 접속 불가이지만, sudo 권한은 사용가능=~
	2. !!: 계정 생성 되었지만,비밀번호가 없음