- 코드 주입 공격과 코드 재사용 공격
	- 코드 주입 공격: 주입한 악성코드를 이용하여 공격
	- 코드 재사용 공격: 프로그램의 **정상흐름을 파괴**하여 의도하지 않은 경로를 호출
- 코드 재사용 공격이 생겨난 이유
	- 코드 주입 공격이 막혀서 생겨났지만, 여전히 코드 영역을 바라본다

### Return to libc 공격
- 함수 포인터는 함수의 매개변수의 타입과 리턴 타입까지 일치해야 사용 할 수 있다
- NX(스택 실행 불가)bit를 켜면 injection공격을 할 수 없다
- 보호 기법 해제
	- ASLR(메모리 랜덤) 해제
	- NX bit 해제
	- stackgruad 해제
	- pie 해제
- 공격 방법
	- 기존에 있는 코드를 사용하자
	- system함수가 libc에 있다
	- 결론: system함수의 주소를 return address에 덮어씌우면 됨
- 환경변수도 메모리에 올라가 있음
- 과정
	1. system()함수 주소 찾기
	2. /bin/sh 주소 찾기
	3. system함수와 /bin/sh 연결하기
- 실제 과정
	1. system(),exit()함수 gdb 디버거로 찾기: p system,p exit
	2. /bin/sh를 환경변수에 넣고 환경변수의 주소 찾기
		1. 환경변수의 주소는 프로그램의 이름 길이에 민감하다.
		2. 프로그램이 실행될 때 운영체제는 스택 메모리의 가장 높은 주소 영역(High Address)에 환경변수와 프로그램의 실행 경로 및 이름을 문자열 형태로 저장하기 때문에 
	3. system()함수 인자 만들기
		1. 공격 대상 함수의 에필로그와 system함수의 프롤로그 이용
- 전체 흐름
	- vu_func의 리턴 주소를 system()함수의 주소로 덮어씀
	- vul_func가 종료되면서 에필로그인 leave,ret이 실행
	- system()함수로 들어감
	- system 함수는 ebp + 8에서 /bin/sh를 찾음
	- system함수는 ebp + 4에서 return address인 exit로 들어가서 깔끔하게 종료됨
- 왜 libc 사용하는지
	- 프로세스의 메모리 영역에는 실행 가능한 시스템 라이브러리들이 링크되어 있다
	- libc는 거의 모든 유닉스,리눅스 프로그램에서 쓰이며,공격에 유용한 함수들이 많기 때문이다
	- **~={red}return to libc는 실행 불가능 스택(NX)를 우회 할 수있다=~**
- 막는 기술
	- ASLR-메모리 랜덤
	- CFI(Control-Flow Integrity, 제어 흐름 무결성)
		- **원리:** 프로그램의 정상적인 실행 흐름을 미리 **제어 흐름 그래프(CFG, Control-Flow Graph)**로 정의해 둡니다.
		- **검증:** 프로그램 실행 중에 점프(분기)가 발생할 때마다, 이 점프가 CFG상에서 허용된 경로인지 검사합니다.
		- 오버헤드 큼
- 정리
	- **~={red}함수 에필로그이후에 바로 프롤로그 실행하면 return address만 쌓임=~**

## Return-oriented Programing(ROP)
- 정리
	- **~={red}ebp값을 fake로 가질수 있게 만들어서 인자 공간을 확보한다(프롤로그 건너뛰기)=~**
- return 지향 프로그래밍
- call을 ret로 덮어씌워서 원하는 함수로 이동
- 목표: bar()함수 연속 실행해서 root shell 획득
- ebp를 tracking하는 이유: return address를 덮어씌우기 위해서
45페이지-**~={red}시험=~**
![[Pasted image 20251206165901.png]]
- 인자가 없는 함수에 return address를 체이닝하면 바로 위에 계속 덮어 씌워도 된다, 하지만 함수의 인자가 있으면 함수의 인자가 들어갈 공간을 만들어줘야 한다.
- 인자가 들어갈 공간을 만들어주는 아이디어: 함수 프롤로그 스킵
	- 체이닝 할 때 인자가 있으면 **~={red}프롤로그(3byte)를 스킵=~**한다
- 프롤로그 스킵
	- 에필로그의 leave(mov ebp to esp,pop ebp)가 **~={red}프롤로그의 ebp 세팅 기능을 대신=~** 해준다.
	- 이때 다음 함수의 ebp 주소는 공격자가 미리 적어두어야 한다
- 프롤로그가 없을 때는 가상의 empty()함수 이용한다
	- 프롤로그가 없으면 에필로그도 없기 때문에 ROP를 이용할 수 없다
	- 이것을 해결하기 위해서 아무 함수의 에필로그를 함수 리턴 주소 자리에 넣어주면 된다.
- 고급 shell을 사용 할때 setuid 인자
	- sprintf: src + null을 dst에 출력
	- src가 null이나 빈 문자열이면 null만 dst에 출력됨
	- 이걸 4번 반복하면 setuid의 인자에 0x00000000이 들어가서 setuid(0)이 됨
- **~={red}rop 실제로 해보기@@@@@@@@@@@@@@@@@@@@@@@@@=~**


---
사용자의 이해를 돕기 위해 질문하신 내용을 명확히 정정하고, 비교표를 작성해 드리겠습니다.

결론부터 말씀드리면 질문하신 내용 중 **"인자가 있는 경우 에필로그를 건너뛴다"는 부분은 반대**입니다. 인자가 있는 ROP 체이닝(Chaining)을 할 때는 **"프롤로그(Prologue)를 건너뛰고, 에필로그(Epilogue, `leave; ret`)는 반드시 실행"**해야 합니다.

### 1. 인자 유무에 따른 실행 방식 차이

강의 자료(Chapter 8)를 바탕으로 정확한 메커니즘을 설명해 드립니다.

#### **(1) 인자가 없는 함수 체이닝 (No Arguments)**

- **실행 방식:** 함수 **전체(프롤로그 + 본문 + 에필로그)를 모두 실행**합니다.
    
- **이유:** 인자가 없으므로 스택에 있는 데이터를 참조할 필요가 없습니다. 단순히 `ret` 명령어가 스택에 쌓여 있는 다음 함수의 주소로 점프만 잘 해주면 되기 때문에, `ebp` 레지스터가 망가져도 상관없습니다 1.
    

#### **(2) 인자가 있는 함수 체이닝 (With Arguments)**

- **실행 방식:** 함수의 **프롤로그(Prologue)를 건너뛰고(Skip)**, 본문과 **에필로그(Epilogue, `leave; ret`)를 실행**합니다.
    
- **이유 (왜 프롤로그를 건너뛰나?):**
    
    - 함수의 프롤로그(`push ebp; mov ebp, esp`)는 `ebp`를 현재 스택 위치(`esp`)로 초기화해버립니다.
        
    - 하지만 우리는 **가짜 스택 프레임(Fake Frame)**을 만들어 인자를 배치했으므로, **`ebp`가 우리가 만든 가짜 프레임을 가리키고 있어야 합니다.**
        
    - 따라서 `ebp`를 초기화해버리는 프롤로그를 실행하면 인자를 찾을 수 없게 되므로, **프롤로그 다음 주소(`함수주소 + 3` 등)로 점프**하여 `ebp`를 유지해야 합니다 2.
        
- **`leave; ret`의 역할:** 에필로그인 `leave`(`mov esp, ebp; pop ebp`)가 실행되어야 `ebp`가 다음 가짜 프레임으로 이동(갱신)하고, `ret`이 다음 함수를 호출하여 체인이 연결됩니다 3.
    


### 2. Return-to-Libc vs. ROP (인자 있음) 비교

단일 함수 호출인 일반적인 **Return-to-Libc**와 여러 함수를 연결하는 **ROP(인자 있음)**의 차이를 비교한 표입니다.

|**비교 항목**|**Return-to-Libc (Basic)**|**ROP with Arguments (Chaining)**|
|---|---|---|
|**목표**|단 하나의 함수(예: `system`) 실행 후 종료|여러 함수를 연속적으로 실행 (예: `func1` → `func2` ...)|
|**스택 구조 (Payload)**|`[시스템함수 주소] [종료 주소] [인자 주소]`|`[다음 EBP] [함수 주소] [인자] [패딩]` 반복|
|**함수 진입 지점**|함수의 **시작 주소** (프롤로그부터 실행)|함수의 **프롤로그 이후 주소** (Skip Prologue)|
|**EBP 레지스터**|중요하지 않음 (시스템 함수가 알아서 관리)|**매우 중요** (가짜 프레임을 가리켜야 함)|
|**ESP 레지스터**|단순히 아래로 내려가며 실행|`leave` 명령어를 통해 `ebp` 위치로 이동하며 실행|
|**공격 성공 원리**|스택의 `ret` 주소 하나만 덮어씀|스택에 **가짜 프레임 체인**을 만들고 연결함|
|**참고 자료**|Chapter 8, 16페이지 4|Chapter 8, 52페이지 5|

### 3. 공격 과정 요약 비교

#### **A. Return-to-Libc (단일 호출)**

1. **준비:** `system()` 주소, `exit()` 주소, `"/bin/sh"` 문자열 주소를 찾습니다.
    
2. **스택 구성:**
    
    - Buffer Overflow를 일으켜 리턴 주소(RET)를 `system()` 주소로 덮어씁니다.
        
    - 그 뒤에 `exit()` 주소(system 종료 후 돌아갈 곳)를 넣습니다.
        
    - 그 뒤에 `"/bin/sh"` 주소(system의 인자)를 넣습니다.
        
3. **실행:** `ret` → `system("/bin/sh")` 실행 → 종료.
    

#### **B. ROP with Arguments (연속 호출)**

1. **준비:** 사용할 함수들의 주소(프롤로그 건너뛴 주소), 각 함수에 넣을 인자 값, 현재 스택의 `ebp` 주소를 찾습니다.
    
2. **스택 구성 (Badfile 작성):**
    
    - **Frame 1:** `[Frame 2의 EBP 주소]` + `[함수1 주소(Skip Prologue)]` + `[인자1]` + `[패딩]`
        
    - **Frame 2:** `[Frame 3의 EBP 주소]` + `[함수2 주소(Skip Prologue)]` + `[인자2]` + `[패딩]`
        
    - ... (반복)
        
    - **Last Frame:** `[더미 값]` + `[exit() 주소]` + `[더미 인자]`
        
3. **실행:**
    
    - 첫 번째 함수가 끝날 때 `leave`가 실행되면서 `mov esp, ebp; pop ebp`가 수행됩니다.
        
    - 이때 `pop ebp`에 의해 **`ebp` 레지스터가 Frame 2의 EBP 주소로 업데이트**됩니다.
        
    - `ret`에 의해 함수2가 실행되고, 함수2는 업데이트된 `ebp`를 기준으로 자신의 인자를 찾습니다.
        
    - 이 과정이 체인처럼 반복됩니다.
        

이해가 되셨나요? 핵심은 **"인자가 있는 ROP는 `ebp`를 내가 원하는 곳(가짜 프레임)으로 계속 옮겨줘야 하므로, `ebp`를 초기화해버리는 프롤로그를 실행하면 안 된다"**는 점입니다.


 