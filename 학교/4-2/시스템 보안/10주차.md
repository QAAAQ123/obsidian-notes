59. mov eax,0 => 머신코드에 0이 나타나서 안됨
	1. xor eax,eax => 0세팅
	2. eax는 32bit 레지스터
	3. 만약 mov eax,0x99 => 0x99는 실제로 0x00000099이기 때문에 중간에 0x00이 나온다
	4. xor eax,eax와 ov al,0x99에는 0x00이 들어있지 않다
60. 
	1. ebx = 0xff112233
	2. shift left ebx,8bit => ebx = 0x11223300
	3. shift right ebx,8bit => ebx = 0x00112233
	4. => 위 명령어 3개는 0x00이 없다
61. 위 3줄하여 edx는 0x
62. e
63. 목적 execve()를 실행시키는 것
	1. 어셈블리어의 label :
	2. JMP: eip주소 값 수정
	3. call=> push하고 eip변경??
	4. 55페이지와 결과는 같지만 다른 방법
64. ㄷ
65. --omagic: 보안끄기(?????????)
## Ch7 버퍼 오버플로우 공격
2. notepad => 4gb가상 메모리
	1. 운영체제가 계속 4gb할당받음(매우 작은프로그램도 모두 4gb로 할당해줌)
	2. 가상메모리 -> 물리메모리(매핑)
	3. 매핑정보를 OS가 테이블로 관리
3. y => BSS에 저장
	1. `*ptr`: heap에 저장(주소 가리키는 것은 stack에 있음)
	2. void*를 int*로 형변환
	3. ~={red}int **=&ptr??? 찾아보기=~
4. function의 base라서 base pointer => ebp
	1. ebp이용하면 데이터 접근 12(%ebp)
	2. movl 12(%ebp),%eax => ebp에서 12byte(3줄)위에 있는 데이터를 eax에 복사
	3. 2번째 줄 ebp에서 8byte(2줄) "" edx에 복사
	4. 덧셈
	5. ebp에서 8byte아래 있는것을 eax에서 복사받음
	6. ebp는 스택에 저장되어 있다. ebp는 함수 시작 주소
---
수요일
7. strcpy하면 hello world까지만(null 바이트 있기 때문에)
	1. '\','0'은 1바이트 char,\0은 null 1바이트
	2. null byte전까지 copy
	3. 컴파일러가 알아서 문자열 뒤에 null넣음
	4. null과 0차이-> null은 무
8. 버퍼오버플로
	1. 함수 생성 하면 함수를 위한 stack frame 생성됨
	2. strcpy에 확인할 때 => 무시하고 null이 나올 때까지 cpy
	3. 메모리 할당되지 않은 곳에 덮어 씌움
	4. => 컴파일하면 segmention fault오류 => OS가 해당 프로세스 kill
	5. 할당한 크기보다 크게 담으려고 하는것 => 버퍼 오버플로우
9. call foo하면 foo 스택 프레임 생성 => push eip -> jmp foo -> push ebp(메인함수의 ebp) -> mov ebp,esp -> 로컬 변수 할당(여기서는 buffer)
	1. ebp는 previous frame pointer
	2. 매개변수는 ebp로 접근함
	3. strcpy까지는 문제 없으ㅁ,ret 할때 문제 생김
	4. pop edp -> pop eip(여기서 문제 생김)
10. 버퍼 오버플로 기본 개념
	1. 103바이트까지는 덮어쓰기 pfp 104부터 107까지 리턴 주소=> 여기를 뭘로 채울건지
	2. 108부터 실행코드 담음=> 실행코드 시작주소 알아냄=>그 시작주소를 리턴 주소에 담으면 됨
	3. pop eip 이후에 malicious 코드 실행됨
	4. 11핵심
	5. return address 값을 overwriting시키는것
11. 100 정상,180 오류
12. badfile,foo함수 => 100바이트 이상이면 오류
13. ㄷ
14. ㄷ
15. 2가지 핵심
	1. 버퍼(시작점)과 리턴주소 사이의 거리
	2. shellcode의 시작주소
16. Task A
	1. 디버거 이용해서 알아냄/-g 옵션: 디버깅 정보 담은채로 컴파일
	2. foo 함수시작에 break point 걸고 실행
	3. ebp값 출력(foo함수 edp값)
	4. buffer 시작주소 출력
	5. p/d ebp -buffer 시작 주소 = distance(108바이트)
	6. 왜4이여야함? 이전 프레임 포인터가 4바이트이기 때문에 4바이트 더해야 리턴주소로 가기 때문에

