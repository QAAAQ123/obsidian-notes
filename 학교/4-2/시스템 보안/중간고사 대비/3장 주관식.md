
## ch3: Set-UID 프로그램 - 주관식 퀴즈

1. 일반 사용자가 자신의 비밀번호를 변경하려면 루트(root)만 쓰기 권한을 가진 `/etc/shadow` 파일을 수정해야 합니다1. 운영체제는 이 문제를 해결하기 위해 어떤 메커니즘을 사용하며, 이것이 왜 필요한지 설명하세요.
   shadow파일을 수정할 때만 root권한을 주는 set-uid 메커니즘을 활용한다. 특정 파일에 특정 기능에만 권한상승을 할 수 있어, 일반적인 sudo나 su에 비해서 더 안전하다
    
2. 프로세스가 실행될 때 **실제 사용자 ID (RUID)**와 **유효 사용자 ID (EUID)**는 각각 어떤 역할을 하며, 일반 프로그램을 실행할 때와 Set-UID 프로그램을 실행할 때 이 두 ID의 관계는 어떻게 달라지나요? 
   Ruid는 실제 사용자의 id,euid는 현재 어느 사용자의 권한을 가지고 있는지 나타낸다. 일반에서는 ruid=euid이지만,set-uid에서는 ruid!=euid이다
    
3. Set-UID 프로그램의 보안 모델을 "파워 슈트 2.0"에 비유했습니다3. 이 비유가 의미하는 바는 무엇이며, `sudo` 명령어와 비교했을 때 Set-UID 프로그램이 사용자에게 권한을 부여하는 방식은 어떻게 다른가요? 
   해당 기능과 명령어에 대해서만 권한을 부여한다.❌
    
4. Set-UID 프로그램의 주요 공격 경로(Attack Surfaces) 4가지 중, 사용자가 프로그램 실행 전에 설정할 수 있으며 프로그램 코드에 직접 드러나지 않는 입력값은 무엇인가요? 
   환경변수
    
5. `system("ls");`와 같이 외부 명령어를 호출하는 Set-UID 프로그램이 있을 때, 공격자가 **PATH 환경 변수**를 어떻게 조작하여 시스템을 공격할 수 있는지 그 원리를 설명하세요. 
   PATH 환경변수를 현재 디렉토리부터 찾도록 우선순위를 변경하고, 공격 명령어 파일을 현재 디렉토리에 만들면 현재 디렉토리에 만든 공격 명령어를 권한 상승하여 실행하기 때문에 시스템을 공격 할 수 있다
    
6. `LD_PRELOAD` 환경 변수를 이용한 공격은 어떤 원리로 동작하며, 이 공격을 막기 위해 리눅스의 동적 링커는 Set-UID 프로그램 실행 시 어떤 보안 조치를 취하나요? 
	프로그래밍언어를 이용해 동적 링킹 방식으로 프로그램을 만들때 미리 로드해놓아야 하는 라이브러리를 공격자가 만들어 놓은 라이브러리로 변경하여 프로그램을 실행할 때 공격자 라이브러리를 링킹하게 만든다. 그래서 set-uid프로그램은 root권한으로 실행되는 프로그램이 있으면 LD_PRELOAD 환경변수를 아예 제거하여 위협 자체를 제거한다.
    
7. `system()` 함수를 사용하여 외부 명령어를 호출하는 것이 왜 위험한지 설명하고, `execve()` 함수가 더 안전한 대안이 되는 이유를 **코드와 데이터의 분리** 관점에서 설명하세요. 
   system()은 root shell을 호출하여 그 위에서 system()의 매개변수로 들어온 것들을 실행한다. root shell을 호출하여 shadow와 같이 중요하고 민감한 정보를 간단하게 system()으로 접근 할수 있기 때문에 위험하다. execve()는 매개변수에 코드와 어느 데이터를 사용할지를 분리해 놓는다. ❌
    
8. Set-UID 프로그램이 권한이 필요한 작업을 마친 후 `setuid(getuid());`와 같은 함수를 호출하여 권한을 영구적으로 낮추는 이유는 무엇이며, 이를 **'최소 권한 원칙'**과 어떻게 연결할 수 있나요?
   권한이 상승된 채로 다른 작업을 하면 보안위험 때문에,정확히 권한이 필요한 작업만 마친뒤 권한을 없애 버리기 때문에 최소 권한 원칙을 이용한다고 볼 수 있다. 
    
9. **역량 누수 (Capability Leaking)** 공격은 어떤 상황에서 발생하며, 강의 자료의 예시처럼 권한을 낮춘 셸(shell)에서 어떻게 루트만 쓸 수 있는 파일에 데이터를 쓸 수 있었는지 설명하세요. 
   파일을 제대로 닫지 않고 권한을 낮추었을때 발생한다. 파일 열기는 루트로 이루어 지기 때문에 파일을 닫지 않고 권한을 낮춰버리면 파일 열기때 썼던 루트 셸이 그대로 남아있는다.❌
    
10. Set-UID 프로그램의 취약점은 C언어뿐만 아니라 PHP와 같은 다른 언어에서도 발생할 수 있습니다11111111. 강의 자료의 PHP 예제에서 사용자의 입력값(`$dir`)이 어떻게 서버에서 의도치 않은 명령어를 실행하게 만들 수 있는지 설명하세요. 12
    system함수를 이용해서 파일 위치에 뭐가 있는지 ls명령어로 볼 수 있다. 만약 사용자가 dir 변수에 중요한 파일 경로를 넣으면 해당 디렉토리에 뭐가 있는지 전부 다 알 수 있다.❌

채점 완료했습니다. 전반적으로 Set-UID의 핵심 원리를 매우 잘 파악하고 계십니다! 👏

답변하신 내용 중 일부 부정확하거나 보충 설명이 필요한 3, 7, 9, 10번 문항에 대해 오답 노트를 정리해 드릴게요.

---

### ## 3번: "파워 슈트 2.0" 비유와 `sudo`와의 차이점

> **작성하신 답변:** 해당 기능과 명령어에 대해서만 권한을 부여한다.

**피드백:** 핵심을 정확히 짚으셨습니다. 다만, "어떻게" 기능이 제한되는지 비유를 통해 조금 더 구체적으로 설명하면 완벽합니다.

**보충 설명:**

"파워 슈트 2.0"의 핵심은 **정해진 동작만 수행하는 칩**이 내장되어 있다는 점입니다1. 사용자는 그 칩에 프로그래밍된 동작(예: '비밀번호 변경') 외에는 어떤 다른 행동도 할 수 없습니다2222.

- **Set-UID 프로그램:** 이 비유처럼, 프로그램의 동작은 **코드로 완전히 고정**되어 있습니다. 사용자는 `passwd` 프로그램을 실행하여 비밀번호를 바꾸는 정해진 작업만 할 수 있을 뿐, 그 권한을 이용해 다른 파일(`ls`, `cat`)을 실행하거나 시스템을 변경할 수는 없습니다.
    
- **`sudo` 명령어:** 반면, `sudo`는 사용자에게 특정 시간 동안 **루트(root)의 권한 그 자체**를 빌려주는 것에 가깝습니다. `sudo bash`를 실행하면 사용자는 거의 모든 것을 할 수 있는 루트 셸을 얻게 됩니다. 이는 특정 기능만 탑재된 "파워 슈트"가 아니라, 무엇이든 할 수 있는 "마스터 키"를 잠시 빌리는 것과 같습니다.
    

---

### ## 7번: `system()`의 위험성과 `execve()`의 안전성

> **작성하신 답변:** system()은 root shell을 호출하여 그 위에서 system()의 매개변수로 들어온 것들을 실행한다. (...) execve()는 매개변수에 코드와 어느 데이터를 사용할지를 분리해 놓는다.

**피드백:** `execve()`가 안전한 이유에 대해서는 정확히 이해하셨습니다. 하지만 `system()`이 위험한 이유는 "root shell을 호출"하기 때문이라기보다는, 셸이 **문자열을 명령어로 해석하는 방식** 때문입니다.

**보충 설명:**

`system()` 함수는 내부적으로 `/bin/sh`와 같은 셸을 호출하여 ~={red}**넘겨받은 문자열 전체를 명령어로 해석하여 실행**=~합니다3. 이것이 문제의 핵심입니다.

예를 들어, `system("cat a.txt");`와 같은 코드가 있을 때, 공격자가 `a.txt` 대신 `a.txt; /bin/sh` 라는 값을 입력하면 `system()` 함수는 다음과 같은 문자열을 셸에 전달합니다.

`"cat a.txt; /bin/sh"`

셸은 세미콜론(`;`)을 **명령어 구분자**로 인식하여, `"cat a.txt"`를 실행한 뒤, 이어서 **`"/bin/sh"`라는 두 번째 명령어를 실행**하게 됩니다4. 즉, 사용자의 **데이터(파일 이름)**가 **코드(실행 명령어)**로 둔갑해 버리는 **코드 인젝션(Code Injection)**이 발생합니다5.

반면, `execve()`는 첫 번째 인자로 **실행할 코드(명령어)**를 명확히 지정하고, 두 번째 인자로 **데이터(전달할 인자)**를 분리해서 받습니다6666. 따라서 사용자가 입력한 데이터에 세미콜론과 같은 특수 문자가 있어도, 이를 명령어로 해석하지 않고 단순히 파일 이름의 일부로만 취급하여 공격이 실패하게 됩니다7.

---

### ## 9번: 역량 누수(Capability Leaking) 공격 원리

> **작성하신 답변:** 파일을 제대로 닫지 않고 권한을 낮추었을때 발생한다. 파일 열기는 루트로 이루어 지기 때문에 파일을 닫지 않고 권한을 낮춰버리면 파일 열기때 썼던 루트 셸이 그대로 남아있는다.

**피드백:** 원인을 거의 정확하게 파악하셨지만, '루트 셸'이 남는다는 표현은 약간의 오해가 있습니다. 남아있는 것은 셸이 아니라 **파일 디스크립터(File Descriptor)**입니다.

**보충 설명:**

공격 과정은 다음과 같습니다.

1. Set-UID 프로그램이 **루트 권한(EUID=0)**으로 실행됩니다.
    
2. 이 프로그램은 루트 권한으로만 쓸 수 있는 `/etc/zzz` 파일을 쓰기 모드로 엽니다(`open()`). 커널은 이 파일에 대한 **접근 권한을 가진 파일 디스크립터(File Descriptor, 예: 숫자 3)**를 이 프로세스에게 부여합니다888888888. 이 파일 디스크립터는 '루트 권한으로 열린 파일로 가는 티켓'과 같습니다.
    
3. 프로그램은 파일을 닫지 않은 채(`close()` 호출 없이), 자신의 권한을 일반 사용자 권한으로 낮춥니다(`setuid()`)9.
    
4. 그 후, 일반 사용자 권한을 가진 새로운 셸(`/bin/sh`)을 실행합니다10.
    
5. 이때, 자식 프로세스(새로운 셸)는 부모 프로세스의 **파일 디스크립터를 상속**받습니다. 즉, 권한은 일반 사용자로 낮아졌지만, **루트 권한으로 열렸던 파일로 가는 티켓(파일 디스크립터 3번)은 여전히 손에 쥐고 있는 상태**가 됩니다. 이것이 바로 '역량 누수'입니다11111111.
    
6. 공격자는 이 남아있는 파일 디스크립터(3번)를 통해 루트 소유의 파일에 데이터를 쓸 수 있습니다 (`echo ccc >& 3`)12121212.
    

---

### ## 10번: PHP 예제에서의 명령어 실행 원리

> **작성하신 답변:** (...) 만약 사용자가 dir 변수에 중요한 파일 경로를 넣으면 해당 디렉토리에 뭐가 있는지 전부 다 알 수 있다.

**피드백:** 이 답변은 정보 유출의 한 측면을 설명하지만, 강의 자료에서 보여주는 핵심적인 공격은 단순한 파일 목록 조회가 아닌 **명령어 인젝션(Command Injection)**입니다.

**보충 설명:**

PHP 코드 `system("/bin/ls $dir");`는 `system()` 함수와 마찬가지로, 변수 `$dir`의 내용을 포함한 문자열 전체를 셸 명령어로 실행합니다13.

공격자는 URL을 통해 $dir 변수에 악의적인 값을 주입합니다.

`http://localhost/list.php?dir=.;date` 14

이 URL로 접속하면, 서버의 PHP 코드는 `$dir` 변수에 `.;date`라는 문자열을 할당하고, 최종적으로 다음 명령어를 실행하게 됩니다.

`system("/bin/ls .;date");` 15

C언어 예제와 동일하게, 셸은 세미콜론(`;`)을 명령어 구분자로 인식하여 `/bin/ls .` 명령어를 실행한 뒤, 이어서 **`date`라는 전혀 상관없는 두 번째 명령어를 실행**합니다. 이처럼 공격자는 파일 목록(`ls`)을 보는 척하면서 자신이 원하는 어떤 명령이든(예: 사용자 정보 탈취, 파일 삭제 등) 추가로 실행시킬 수 있습니다. 이것이 이 취약점의 핵심입니다.