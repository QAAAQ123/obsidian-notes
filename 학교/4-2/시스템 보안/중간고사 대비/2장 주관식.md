### # ch2: Linux 보안 기본 - 주관식 퀴즈

1. **사용자 모드(User Mode)**와 **커널 모드(Kernel Mode)**를 구분하는 이유와, 이 두 모드 사이의 전환(Mode Transition)이 일어나는 대표적인 경우 세 가지는 무엇인지 설명해 보세요.
	- 구분 이유: 사용자가 직접 HW에 접근하는 일을 막기 위해서,-오류,시스템 콜,인터럽트
    
2. 리눅스 시스템에서 **루트(root) 사용자**가 일반 사용자와 근본적으로 다른 점은 무엇이며, 왜 루트 계정을 직접 사용하는 것이 권장되지 않는지 설명해 보세요.
	- 모든 권한을 가지고 있기 때문에, 직접 사용하면 실수든 고의든 보안 사고가 일어날 가능성이 많아서
    
3. `su` 명령어와 `sudo` 명령어는 둘 다 권한 상승에 사용되지만, 어떤 **보안적인 차이점**이 있으며 왜 현대 리눅스 시스템에서는 `sudo` 사용을 더 권장하는지 설명해 보세요.
	- su는 유저 자체를 변경하고 sudo는 해당 명령어에 대해서만 유저의 권한을 부여하기 때문에 su의 보안 위험이 더 크다. 
    
4. `/etc/passwd` 파일은 모든 사용자가 읽을 수 있도록 허용하면서도, 암호 정보는 `/etc/shadow` 파일에 별도로 저장하여 루트만 읽을 수 있게 한 이유는 무엇일까요
   암호는 보안에 매우 중요한 정보이기 때문에 ❌
    
5. 리눅스에서 파일에 권한을 부여할 때 **소유자(Owner), 그룹(Group), 그 외(Other)** 세 가지로 나누어 관리하는 이유는 무엇인지 설명해 보세요.
   권한을 분리하여 관리하고 싶기 때문에❌
    
6. **Set-UID** 비트가 설정된 프로그램은 어떤 특별한 방식으로 동작하며, 이 기능이 왜 강력하면서도 동시에 심각한 보안 위협이 될 수 있는지 설명해 보세요.
   set-uid 프로그램을 실행하면 실행하는 동안만 해당 유저의 권한으로 실행되며,다른 기능은 이용할 수없다. 그러나 set-uid자체가 다른 유저의 권한을 얻기 때문에 프로그램을 제대로 닫지 않거나 수정하게 되면 심각한 보안 위협이 된다.
    
7. 암호를 `/etc/shadow` 파일에 저장할 때, 그냥 해시(Hash)만 하지 않고 굳이 **솔트(Salt)**를 추가하는 이유는 무엇이며, 이를 통해 어떤 종류의 공격을 더 효과적으로 방어할 수 있는지 설명해 보세요.
    무작위성을 더 부여하기 위함이다. 패스워드 탈취 공격을 효과적으로 방어하기 위함❌
8. 사용자 프로그램이 파일 읽기나 네트워크 통신과 같은 작업을 직접 수행하지 않고 **시스템 호출(System Call)**을 통해 커널에 요청하는 이유는 무엇인지, 보안 관점에서 설명해 보세요.
    사용자가 직접 파일 읽기나 통신과 같은 민감한 작업을 하게 된다면 실수할 가능성이 크고, 사용자의 권한만 탈취하면 공격자가 하드웨어를 장악 가능하게 된다. ❌
9. `umask`는 어떤 역할을 하며, 이것이 시스템 보안에 왜 중요한지 설명해 보세요.
    기본 권한부여 설정, 생성할때 기본적으로 읽기나 실행을 제한하여 보안 달성
10. **POSIX 기능(Capabilities)**은 기존의 루트 권한 모델과 비교했을 때 어떤 장점이 있으며, 이것이 '최소 권한 원칙'을 어떻게 구현하는 데 도움이 되는지 설명해 보세요.
    프로세스에만 권한을 부여하여 해당 프로세스에서만 루트 권한을 사용가능하다는 장점이 있다. 이것은 사용자 모드 전체에 루트 권한을 부여하지 않아서 최소 권한 원칙을 구현하는데 도움을 준다.

네, 제출하신 답변을 채점해 보았습니다. 대부분의 개념을 정확히 이해하고 계시네요! 👍

다만, 몇몇 문제의 답변은 조금 더 구체적이거나 핵심을 짚을 필요가 있어 보입니다. 오답 또는 보충 설명이 필요한 4, 5, 7, 8번 문항에 대해 자세히 설명해 드릴게요.

---

### ## 4번: `/etc/passwd`와 `/etc/shadow` 파일 분리 이유

**"암호는 보안에 매우 중요한 정보이기 때문"**이라고 답변하셨는데, 맞습니다. 하지만 '왜' 분리해야만 했는지에 대한 **구조적인 이유**를 설명하면 더 좋습니다.

**보충 설명:**

가장 큰 이유는 **권한의 충돌** 때문입니다.

- `/etc/passwd` 파일은 `ls -l` 명령어처럼 파일 소유자 숫자를 사용자 이름으로 보여주는 등, 시스템의 여러 기본 기능이 사용자 정보를 참조하기 위해 **모든 사용자가 읽을 수 있어야 합니다 (world-readable)**. 1
    
- 만약 이 파일에 암호 해시가 저장되어 있다면, 시스템의 모든 사용자가 다른 모든 사용자의 암호 해시를 볼 수 있게 됩니다. 이는 무차별 대입 공격(Brute-force attack)이나 레인보우 테이블 공격에 매우 취약해지는 심각한 보안 문제입니다. 2
    
- 이 문제를 해결하기 위해, 암호 해시와 같은 민감한 정보만 별도의 `/etc/shadow` 파일로 분리하고, 이 파일은 **오직 루트(root) 사용자만 읽을 수 있도록** 권한을 제한한 것입니다. 3333
    

> analogy **비유:** `/etc/passwd`는 누구나 볼 수 있는 **'공개 전화번호부'**와 같고, `/etc/shadow`는 본인과 관리자만 접근할 수 있는 **'비밀 금융 정보'**와 같습니다. 중요한 정보는 별도의 금고에 보관하는 것과 같은 원리입니다.

---

### ## 5번: 소유자(Owner), 그룹(Group), 그 외(Other)로 권한을 나누는 이유

**"권한을 분리하여 관리하고 싶기 때문"**이라고 하신 점은 맞지만, 각 역할이 왜 필요한지에 대한 설명이 추가되면 더 좋습니다.

**보충 설명:**

이는 **효율적인 협업과 접근 제어**를 위해 역할을 나눈 것입니다.

- **소유자 (Owner):** 파일이나 디렉터리를 **생성한 사용자**입니다. 콘텐츠에 대한 완전한 제어 권한을 갖는 것이 기본입니다. 4
    
- **그룹 (Group):** **여러 사용자를 하나의 단위로 묶어** 동일한 권한을 부여하기 위해 존재합니다. 예를 들어, '개발팀'이라는 그룹을 만들고 특정 소스 코드 디렉터리에 대한 읽기/쓰기 권한을 이 그룹에만 부여하면, 팀원들은 모두 협업할 수 있지만 팀에 속하지 않은 다른 사용자는 접근할 수 없습니다. 이는 사용자마다 일일이 권한을 설정하는 비효율을 줄여줍니다. 5
    
- **그 외 (Other):** 소유자도 아니고, 그룹에도 속하지 않은 **시스템의 모든 나머지 사용자**를 의미합니다. 이들에게 부여할 최소한의 공개 범위를 설정하기 위해 필요합니다. 6
    

---

### ## 7번: 해시에 솔트(Salt)를 추가하는 이유

**"무작위성을 부여하고, 패스워드 탈취 공격을 방어하기 위함"**이라고 하셨는데, 정확히 **어떤 공격**을 어떻게 막는지가 중요합니다.

**보충 설명:**

솔트는 특히 **레인보우 테이블(Rainbow Table) 공격**을 무력화하기 위해 사용됩니다. 7

- **솔트가 없다면:** '1234'라는 동일한 암호를 사용하는 모든 사용자는 동일한 해시 값을 갖게 됩니다. 공격자는 미리 수많은 암호에 대한 해시 값을 계산해 둔 '레인보우 테이블'이라는 거대한 데이터베이스를 이용해 해시 값만으로 원래 암호를 즉시 찾아낼 수 있습니다.
    
- **솔트가 있다면:** 솔트는 사용자마다 다른 임의의 값입니다. 암호를 해시할 때 이 솔트를 추가하기 때문에, '1234'라는 동일한 암호를 사용하더라도 **모든 사용자가 서로 다른 해시 값을 갖게 됩니다**. 8888 결과적으로 공격자는 사용자별 솔트를 알지 못하면 레인보우 테이블을 사용할 수 없게 되어 공격이 훨씬 더 어려워집니다.
    

---

### ## 8번: 시스템 호출(System Call)을 사용하는 이유

답변하신 내용은 시스템 호출의 필요성을 잘 설명하고 있지만, **'사용자 모드'**와 **'커널 모드'**라는 핵심 키워드를 사용하면 더 명확해집니다.

**보충 설명:**

보안 관점에서 시스템 호출은 **안전하게 커널의 기능을 사용하기 위한 유일한 통로**이기 때문입니다.

- 운영체제는 시스템을 보호하기 위해 **사용자 모드**와 **커널 모드**로 권한을 분리합니다. 9파일 시스템 접근, 메모리 할당, 하드웨어 제어 등과 같은 중요한 작업은 오직 **커널 모드**에서만 실행할 수 있는 **특권 명령(Privileged Instructions)**을 필요로 합니다. 10
    
- 사용자 프로그램은 **사용자 모드**에서 실행되므로 이러한 특권 명령을 직접 실행할 수 없습니다. 11
    
- **시스템 호출**은 사용자 프로그램이 커널에게 정해진 규칙과 절차에 따라 안전하게 서비스를 요청하는 공식적인 인터페이스입니다. 12121212이 호출이 발생하면 하드웨어는 사용자 모드에서 커널 모드로 전환하여 요청된 작업을 수행하고, 완료 후 다시 사용자 모드로 돌아옵니다. 13
    

이러한 구조 덕분에 사용자의 실수가 시스템 전체를 망가뜨리는 것을 막고, 공격자가 임의로 하드웨어를 제어하는 것을 방지할 수 있습니다.