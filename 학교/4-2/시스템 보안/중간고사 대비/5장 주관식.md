### ch5: 어셈블리 언어 기초 - 주관식 퀴즈

1. CPU가 메모리에서 명령어를 가져와 실행하는 '명령어 실행 사이클'의 5단계를 순서대로 설명하세요.
    기계어가 메모리에 올라감 -> CUP 버스로 기계어가 이동함 -> 레지스터로 실행 -> 프로세스가 됨❌
2. 프로세스의 메모리 구조는 여러 세그먼트로 나뉩니다. '데이터 세그먼트'와 'BSS 세그먼트'는 각각 어떤 종류의 변수를 저장하며, 둘 사이의 주된 차이점은 무엇인가요?
    데이터는 초기화 되지않은 정적,전역 변수 저장/BSS는 초기화 된 정적,전역 변수저장❌
3. 32비트 환경에서 EIP, ESP, EBP 레지스터는 각각 어떤 목적을 위해 사용되는지 설명하세요.
    EIP: 다음 실행할 명령어,ESP: 스택 포인터,EBP: 실행할 함수 저장❌
4. C언어에서 `malloc()` 함수를 사용하여 메모리를 동적으로 할당할 때, 이 메모리는 프로세스의 주소 공간 중 어느 영역에서 할당되며, 이 영역의 특징은 무엇인가요?
    HEAP,동적으로 사용자가 지정한 명령만 영역에 올라가고 0xffffffff로 올라가는 형태이다❌
5. 메모리에 다중 바이트 데이터를 저장하는 방식에는 빅 엔디안과 리틀 엔디안이 있습니다. 두 방식의 차이점은 무엇이며, Intel CPU는 어떤 방식을 사용하나요?
    빅 엔디안은 MSB를 메모리 주소가 큰곳에서부터 저장하고 리틀은 MSB를 메모리 주소가 작은곳 에서부터 저장한다. intel은 빅을 사용한다.❌
6. `MOV EAX, [EBX]`와 `LEA EAX, [EBX]` 명령어는 어떤 차이가 있는지 설명하세요.
    MOV는 EBX의 주소에 있는 값을 EAX로 복사하고,LEA는 EBX의 주소를 EAX로 복사한다.
7. `PUSH`와 `POP` 명령어는 스택 메모리를 어떻게 조작하며, 이 명령어들이 실행될 때 스택 포인터(ESP)의 값은 각각 어떻게 변하나요?
    PUSH는 스택 메모리에 기계어를 넣는다,pop은 스택 메모리에서 기계어를 빼지만,기계에는 스택에서만 빠져있을 뿐 그대로 있다. ESP는 PUSH에서 감소하고,POP에서 증가한다.❌
8. `CMP` 명령어는 `SUB` 명령어와 유사하게 뺄셈 연산을 수행하지만, 두 명령어 사이에는 어떤 결정적인 차이점이 있나요? 또한 `CMP` 명령어는 주로 어떤 목적으로 사용되나요?
    SUB는 제1피연산자에 저장하지만,CMP는 저장하기지 않고 ZF의 상태를 변화시킨다. CMP는 비교 목적으로 사용
9. `CALL` 명령어를 사용하여 함수를 호출하고 `RET` 명령어로 복귀하는 과정에서 스택이 어떻게 사용되는지 설명하세요.
    CALL 하면 STACK에 ESP는 감소하고 데이터를 스택에 넣는다. RET하면 STACK의 ESP는 증가하고 데이터를 스택에서 꺼낸다.❌
10. 어셈블리 언어는 CPU가 직접 이해할 수 없습니다. 어셈블리 언어로 작성된 '소스 프로그램'을 기계어로 된 '오브젝트 프로그램'으로 변환해주는 역할을 하는 소프트웨어는 무엇인가요?
    어셈블러
    
    
    네, 채점 결과입니다. 6, 8, 10번은 정확하게 이해하셨지만, 나머지 문항들에는 일부 오답이나 보충이 필요한 부분이 있습니다. 오답 위주로 자세히 설명해 드릴게요.

### 1번: 명령어 실행 사이클

> **작성하신 답변:** 기계어가 메모리에 올라감 -> CUP 버스로 기계어가 이동함 -> 레지스터로 실행 -> 프로세스가 됨

**피드백:** 이는 프로그램 실행의 전체적인 흐름에 가깝고, CPU 내부에서 하나의 명령어가 처리되는 '사이클'과는 다릅니다.

정답 및 보충 설명:

CPU의 명령어 실행 사이클은 다음과 같은 5단계로 이루어집니다. 11111111111111111

1. **인출 (Fetch):** 메모리에서 다음에 실행할 명령어를 가져옵니다. 2
    
2. **해독 (Decode):** 가져온 명령어가 어떤 동작을 수행해야 하는지 해석합니다. 3
    
3. **피연산자 인출 (Fetch operands):** 명령어 실행에 필요한 데이터(피연산자)를 레지스터나 메모리에서 가져옵니다. 4
    
4. **실행 (Execute):** ALU(연산 장치)에서 실제 연산을 수행합니다. 5
    
5. **결과 저장 (Store output):** 실행 결과를 레지스터나 메모리에 저장합니다. 6
    

---

### 2번: 데이터 세그먼트 vs BSS 세그먼트

> **작성하신 답변:** 데이터는 초기화 되지않은 정적,전역 변수 저장/BSS는 초기화 된 정적,전역 변수저장

**피드백:** 두 세그먼트의 역할이 서로 바뀌었습니다.

**정답 및 보충 설명:**

- **데이터 세그먼트 (Data Segment):** **초기화된** 전역 변수나 정적(static) 변수를 저장합니다. 7 (예: `int global_var = 10;`)
    
- **BSS 세그먼트 (BSS Segment):** **초기화되지 않은** 전역 변수나 정적 변수를 저장합니다. 8888이 영역의 변수들은 프로그램이 시작될 때 0이나 NULL로 자동 초기화됩니다. 9 (예: `int global_var;`)
    

---

### 3번: EIP, ESP, EBP 레지스터의 목적

> **작성하신 답변:** EIP: 다음 실행할 명령어, ESP: 스택 포인터, EBP: 실행할 함수 저장

**피드백:** EIP와 ESP는 정확합니다. 하지만 EBP의 설명이 틀렸습니다.

**정답 및 보충 설명:**

- **EIP (Instruction Pointer):** 다음에 실행할 명령어의 **주소**를 가리킵니다. 10101010
    
- **ESP (Stack Pointer):** 스택의 가장 마지막 위치(top)의 **주소**를 가리킵니다. 11111111
    
- **EBP (Base Pointer):** 현재 실행 중인 함수의 스택 영역, 즉 스택 프레임의 **시작 주소(기준 주소)**를 가리킵니다. 12121212 함수가 끝나고 이전 함수로 돌아갈 때 스택을 복원하는 기준점 역할을 합니다. '실행할 함수' 자체를 저장하는 것이 아닙니다.
    

---

### 4번: `malloc()`과 힙(Heap) 영역

> **작성하신 답변:** HEAP, 동적으로 사용자가 지정한 명령만 영역에 올라가고 0xffffffff로 올라가는 형태이다

**피드백:** 힙 영역이라는 점은 맞지만, 특징에 대한 설명이 부정확합니다.

정답 및 보충 설명:

malloc()으로 할당된 메모리는 힙(Heap) 영역에 생성됩니다. 13

힙 영역의 특징은 다음과 같습니다.

- 프로그램 실행 중에 프로그래머가 원하는 크기의 메모리를 **동적으로 할당**하고 해제할 수 있습니다. 14
    
- 메모리의 **낮은 주소에서 높은 주소 방향**으로 데이터가 쌓입니다(자랍니다). 이는 높은 주소에서 낮은 주소로 자라는 스택과 반대입니다.
    
- '명령'이 올라가는 것이 아니라, 프로그램이 사용할 **'데이터'**를 저장하기 위한 공간입니다.
    

---

### 5번: 빅 엔디안 vs 리틀 엔디안

> **작성하신 답변:** 빅 엔디안은 MSB를 메모리 주소가 큰곳에서부터 저장하고 리틀은 MSB를 메모리 주소가 작은곳 에서부터 저장한다. intel은 빅을 사용한다.

**피드백:** 두 방식의 정의가 모두 틀렸고, Intel CPU가 사용하는 방식도 틀렸습니다.

**정답 및 보충 설명:**

- **빅 엔디안 (Big Endian):** 상위 바이트(MSB, Most Significant Byte)를 **낮은 주소**에 저장합니다. 15 (예: `0x1234` -> `12 34`)
    
- **리틀 엔디안 (Little Endian):** 하위 바이트(LSB, Least Significant Byte)를 **낮은 주소**에 저장합니다. 16 (예: `0x1234` -> `34 12`)
    
- **Intel CPU는 리틀 엔디안 방식을 사용합니다.** 17
    

---

### 7번: PUSH와 POP의 동작

> **작성하신 답변:** PUSH는 스택 메모리에 기계어를 넣는다, pop은 스택 메모리에서 기계어를 빼지만, 기계에는 스택에서만 빠져있을 뿐 그대로 있다. ESP는 PUSH에서 감소하고, POP에서 증가한다.

**피드백:** ESP의 변화는 정확하지만, 스택에 저장되는 대상에 대한 설명이 부정확합니다.

정답 및 보충 설명:

PUSH와 POP은 '기계어'를 조작하는 것이 아니라 '데이터'(레지스터 값, 변수 값, 주소 값 등)를 조작하는 명령어입니다.

- **PUSH:** 피연산자의 **데이터**를 스택에 삽입합니다. 18이때 스택 포인터(ESP)는 데이터 크기만큼 **감소**합니다. 19
    
- **POP:** 스택의 top에 있는 **데이터**를 피연산자로 꺼내옵니다. 20이때 스택 포인터(ESP)는 데이터 크기만큼 **증가**합니다. 21 말씀하신 대로 데이터가 물리적으로 지워지지는 않고, ESP가 다른 곳을 가리키게 되어 덮어쓸 수 있는 상태가 됩니다.
    

---

### 9번: CALL과 RET에서의 스택 사용

> **작성하신 답변:** CALL 하면 STACK에 ESP는 감소하고 데이터를 스택에 넣는다. RET하면 STACK의 ESP는 증가하고 데이터를 스택에서 꺼낸다.

**피드백:** 너무 일반적인 설명입니다. CALL과 RET에서 스택에 저장되고 꺼내지는 '데이터'가 무엇인지가 핵심입니다.

**정답 및 보충 설명:**

- **CALL:** 함수를 호출할 때, 함수 실행이 끝난 뒤 **돌아와야 할 주소(복귀 주소, 즉 다음 명령어의 EIP 값)**를 스택에 `PUSH`합니다. 22 그 후 호출할 함수의 시작 주소로 점프합니다.
    
- **RET:** 함수가 종료될 때, 스택에 저장해 두었던 **복귀 주소**를 `POP`하여 EIP 레지스터에 다시 넣습니다. 23 이로써 프로그램은 함수를 호출했던 바로 다음 위치에서 실행을 이어갈 수 있습니다.