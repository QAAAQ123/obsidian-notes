## Ch3 set-uid
2. 권한 필요성-패스워드 딜레마
	1. 허가=>root는 rw,shadow그룹은 r의 권한만 가지고 있음
	2. 유저정보 수정=> shadow 파일 수정 => w가 필요함 =>w는 root만 가지고 있음 => 일반 유저가 어떻게 수정해야 할까
3. 일반 유저가 어떻게 변경하는지
	1. root권한(sudo): 위험성 존재
	2. rwx에 3bit 더해서 권한 표시(Set-UID)
	3. rwx: 굵직한 틀만 잡아서 권한 부여/rwx + 3bit: 더 세분화 하여 rwx보다 안전함
	4. 특권 프로그램 사용하기 위해서 3bit 추가함
	5. privileged program
		1. set uid: 세세한 접근 제어=> 많이 사용됨
		2. demons: 윈도우의 set-uid이름
4. Daemons => 백그라운드에서 돌아가는 프로그램/set-uid: 스페셜 비트/unix에서 많이 사용
5. 버전 1.0-모든 권한 가짐/다른 사람이 잘못 이용하면 문제 생김
	1. 버전 2.0-특정 업무만 할 수 있는 것을 종류별로 만듦=> set-uid 매커니즘
6. set-uid 컨셉
	1. set-uid 프로그램 실행하면 **~={red}'소유자의 권한으로 실행'=~**시켜줌
	2. **~={red}그 프로그램의 소유자 권한으로 변경한다.=~**
	3. 소유자에 따라서 바뀐다
	4. 프로그램 수행할 동안에만 소유자 권한
	5. 예시: passwd 프로그램 /user/bin/passwd-> 실행파일 (etc/passwd->유저정보만 저장)
	6. rws의 s->set-uid가 설정되어있음
	7. 노말 유저가 passwd 실행하면 일시적으로 root권한이 생겼다 사라짐
	8. 이 root권한으로 다른 일을 할 수 없다
7. 2종류의 userid
	1. CLI에서 `$`는 일반 유저 권한이다
	2. Real-UID: 진짜 유저 ID/E-UID: 실행된 프로세스의 프리빌리지 알려줌
	3. set-uid가 아닌 프로그램 실행: RUID=EUID
	4. set-uid인 프로그램 실행: RUID != EUID
	5. RUID는 불변/EUID는 변함
8. 코드-**~={red}시험=~**
	1. cat 명령어 복사
	2. cat 권한 거부됨
	3. mod 변경: 권한은 755인데 왜 4가 붙은 4775인지? -> 3bit가 더 붙기 때문에
	4. **~={red}chmod xxxx에서 첫번째 숫자가 특수 권한 비트인데 여기서 set-uid로 설정하는 숫자가 4이기 때문에=~**
	5. 100 => 첫번째 bit가 set-uid bit이다
9. id명령어 myid로 복사: euid가 아래에서 생김 => ruid와 euid가 다르기 때문
10. 도식화: 프로세스가 끝나면 EUID가 원래대로 돌아간다
11. ㄷ
12. 제한된 행동: ~만 할 수 있다. 
	1. 쉘 실행파일에 root 권한 set-uid로 주면 안됨->shell을 열면 기본이 root권한이기 때문에
	2. **~={red}vi: 다른 프로그램을 띄울 수 있음 -> root의 set-uid 주면 안됨=~**
13. 미리 인질만 구하게 pre-program하면 안전 할까? 안전하지 않다
	1. exploit: 거꾸로 날아가면 된다 -> 3.0등장: 왼쪽이 아닌 서쪽으로 날라고 코딩
14. set-uid 표면 공격:1.유저 인풋, 2.시스템 인풋, 3.환경변수, 4. 표면 공격
	1. 윈도우 레지스트리=unix환경 변수
15. 환경 변수 공격
	1. env 명령어 => 환경 변수 보여줌
	2. echo $home => 환경 변수 값 보기
	3. PATH는 중요한 환경변수
	4. PATH의 역할: 실행파일 경로
	   예시) ls하면 'ls'파일 실행 => 경로를 path로 찾음
	5. **~={red}`:`의 의미: 우선순위=~**
	6. 예시 ls가 있을 때까지 다음 경로로 넘어가면서 찾음
16. ??
	1. system("ls"): system은 /bin/shell 참조 -> bin/shell은 환경변수 참조 -> 환경변수에서 ls찾음
17. c언어 캘린더
	1. bin/shell -> 환경 변수 -> cal 실행됨(상대경로임)
	2. /bin/shell -> 절대 경로 넣음 -> 이렇게 되면 환경변수의 영향 안 받음
18. vul.c는 set-uid 프로그램이 됨
	1. gcc: c언어 컴파일 명령어
	2. calc.c는 /bin/dash 실행하는 것
	3. expoert로 환경변수 값 설정: 변수명=value,환경변수 구분 문자`:`
	4. 기존 PATH값: `$PATH`,`.`: 현재 디렉토리
	5. 환경변수 출력
	6. vul 실행 -> root shell 얻음
	7. ??
	8. 공격 어떻게 막음 -> **~={red}절대 경로 사용=~**
	9. 어디에 있는 cal인지 정확히 절대경로로 명시
19. 다이나믹 링커
	1. 다이나믹 링킹: 실행 or 컴파일시 외부 라이브러리 연결
	2. static linking: 정적 링킹
	3. static과 danynic의 차이
20. 동적 링킹과 정적 링킹
	1. 다이나믹으로 컴파일
	2. 스태틱으로 컴파일
	3. 파일 크기가 100배 차이남
		1. 이유?: 스태틱은 실행파일안에 모든 라이브러리 바디를 넣어놓음
		2. 다이나믹은 실행시점에 찾아서 업로드 -> body에 printf 함수가 없다
	4. 스태틱: 빠르다,안전하다/파일 크기가 큼,패치가 바뀌면 모두 찾아서 수정해야함
	5. 다이나믹: 스태틱의 반대
21. ldd명령어
	1. 정적: 동적 없음
	2. 동적: 동적 링킹 3개 있음(설명 참조)
22. 케이스1-동적 링킹,컴파일함/1초 멈췄다가 실행 => 진짜 sleep
	1. 가짜 sleep: main함수 없음
23. 1
	1. gcc에 -c면 object파일 나옴
	2. sleep.c를 libmylib 라이브러리로 만듦
	3. ls -l =>라이브러리 생김
	4. 환경 변수 수정 => mylib가지도록 세팅
	5. mytest실행
	6. ldd로 시켜봄 => 시스템콜,mylib가 껴듬,여기서 sleep 찾아내고 진짜 sleep은 못 찾음(환경변수 변경했기 때문에)
24. e
	1. my env를 set-uid로 만듦
	2. 환경변수 변경
	3. env와 myenv로 grep하면 2개가 myenv에서 안보임->myenv는 set-uid이기 떄문에 즉시 root로 바뀜
	4. **env명령 실행시: env는 일반 프로그램이기 때문에 동적 링커의 보안이 작동하지 않는다**
	5. **myenv명령 실행시: myenv는 루트 setuid이다. 그래서 동적 링커가 보안모드로 작동하여 위험한 환경변수를 지워버린다**
	6. **결론: set-uid프로그램이 환경변수 공격을 막아준다.**
25. 유저 input공격
	1. 모든 공격의 목표: root shell 띄우기
	2. 버퍼 오버플로우 공격-c언어는 보통 배열이 버퍼 넘치게 담으려고 시도
	3. 포맷 스트림-포맷팅 과정의 취약점 공격
	4. 입력 과정에서 취약점 공격
26. change-shell: etc/passwd
	1. 문제: 유저 세세한 인증 실패/공격자가 새로운 root 계정 만듦
	2. 맨 아래 명령
		1. 정상
		2. 비정상=>띄어쓰기 하기 위해(패스워드 포맷과 똑같다)