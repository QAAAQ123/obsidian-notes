## Ch3. 가상화 보안
2. 가상화 
	1. 물리적이지 않고 주어진 하드웨어를 이용해서 실제와 동일한 머신을 할당하고 관리
	2. 하이퍼바이져:**VM을 생성하고 관리하는 manager 역할**
	3. Hypervisor = Virtual machine monitors = Virtual Machine Manager
	4. 가상화 이전: HW위에 OS
	5. 가상화 후: HW위에 하이퍼바이져 그 위에 게스트OS(게스트 OS를 동작 시키는 Virtual HW는 하이퍼바이져가 관리)
	6. 실제로 VM은 하나의 파일로 관리됨
3. 가상화 전후 차이
	1. 전: 각각의 물리 머신에 하나의 역할만 부여(역할 하나당 한개의 물리 머신 필요)
	2. 후: 한개의 물리 머신으로 다양한 역할 부여 가능
	3. 가상화 장점
		1. 적은 CAPEX
			1. CAPEX: 자산 지출
		2. 중앙집중적 관리
4. 가상화(동적 리소스 할당)
	1. 하드웨어 풀에서 필요한 만큼만 할당함
	2. HW가 더 필요하면 개별 장치만 추가하여 문제 해결가능
5. 가상화(클라우드 컴퓨팅 도식화)
	1. 클라우드 컴퓨팅의 핵심은 가상화
6. 가상화 시스템 아키텍쳐
	1. 호스트 OS 있는 버전과 없는 버전이 있음
	2. 가상머신은 반드시 하이퍼바이져를 통해야함
	3. 가상 머신은 서로 격리되어 있다
7. 가상머신 카테고리화(타겟에 따라서 결정)
	1. 서버 가상화
	2. 데스크탑 가상화
	3. 앱 가상화
	4. HW 가상화
8. 하이퍼바이져: 가상화 핵심 미들웨어
	1. 게스트 OS가 잘 동작할 수 있도록 관리
	2. 하이퍼바이져가 해줘야 하는 것들
		1. 충성도(Fidelity): 게스트 OS입장에서 물리 머신의 OS와 똑같이 가상 머신이 동작해야 한다
		2. 격리와 안전: 일반적으로 여러개의 VM을 사용하기 때문에 각각의 VM을 완전히 격리시켜줘야 한다.(Host OS의 접근도 허용하지 않아야 한다)
		3. 성능: 하이퍼바이져를 거쳐야 하기 때문에 물리에서 돌아가는 OS보다는 성능 저하가 있을 수 밖에 없다.이 성능 저하를 최소화 하는 것
9. 하이퍼바이져의 위치와 역할
	1. type1: Native 하이퍼바이져(Bare Metal)
		1. 하드웨어 바로 위에 하이퍼바이져가 설치된 형태(Host OS가 없음)
		2. 공유하는 HW가 있고, 그 위에 바로 하이퍼바이져가 있는 형태
		3. Host OS가 있는 형태보다는 오버헤드가 작다(type2대비 오버헤드가 작다)
		4. 예시: Xen,오라클 VM 서버 등...
10. Tpye2: Hosted 하이퍼바이져
		1. Host OS위에 하이퍼바이져가 설치된 형태(Host OS가 돌리는 여러가지 앱중 하나임)
		2. 사용자가 관리하기 편함(사용성이 type1보다 좋음)
		3. 레이어가 1개 더 있기 떄문에 Type1보다 오버헤드가 늘어남
11. 가상화 기법에 따라서 종류
	1. full:
	2. para:
	3. hybrid:
	4. os-level: 도커와 같은 컨테이너 기반
12. 종류1: full virtualization(전 가상화)
	1. 게스트 OS의 **~={red}수정없이=~** 하드웨어 기반의 완벽한 가상화
	2. 게스트 OS의 수정이 필요없다: 게스트 OS가 물리머신에서 도는건지 가상머신에서 도는 건지 **~={red}인식을 못할 정도로 완벽한 가상화=~**
	3. 조건: CPU가 가상화 기술을 **물리적으로 지원**해 줘야함
13. 종류1구현1: 전 가상화-~={red}소프트웨어 기반 전 가상화=~(binary translation)
	1. **소프트웨어적으로 가상화** 하고 제어권을 가짐
	2. Ring 1,2,3-권한에 대한 내용
	3. 소프트웨어가 가상화하기 때문에 오버헤드가 늘어남
14. 종류1구현2: 전 가상화-~={red}하드웨어 기반 전 가상화=~(HVM)
	1. **~={red}물리 CPU 자체가 가상화 지원=~**
15. 종류2: Para-가상화(~={red}반 가상화=~)
	1. ~={red}**수정된 Guest OS를 설치해야함**=~
	2. Gueset OS가 하이퍼바이져와 직접적으로 소통을 해야함
	3. 시스템 콜을 대신해서 하이퍼 콜을 사용하도록 수정
	4. ~={red}하이퍼 콜=~: OS에서 시스템 콜을 하듯이 게스트 OS에서 하이퍼바이져로 직접 콜
	5. **전 가상화이전에 많이 사용함**
	6. **~={red}전 가상화보다 성능이 좋다=~**-게스트 OS가 직접 하이퍼 콜을 요청하기 떄문에
		1. 전 가상화는 수정되지 않은 게스트 OS이기 때문에 하이퍼바이져가 물리 HW로 시스템 콜을 해줘야 하서 반 가상화보다 성능이 낮음
	7. **~={red}모든 시스템 콜에 대해서 각각의 하이퍼콜로 수정해야 한다는 점에서 호환성이 낮다=~**
16. para-가상화의 예제: Zen
	1. 최고 권한 모드인 ring0에서 실행되는 하이퍼바이져
	2. HW access 제어
	3. root layer
	4. 오픈 소스
	5. high-performance excution(실행) 제공
	6. **ring: 리눅스에서 얘기하는 권한 계층**(커널 영역)
17. Ring에 대해서
	1. 숫자가 높을수록 권한이 낮음
		1. Ring0: 모든 시스템 제어 권한, 명령어 실행시 제약 없음
		2. Ring3: 제약이 제일 많음
		3. 리눅스에서 Ring1,2는 거의 안 쓰이고 주로 Ring 0,3만 쓰임
		4. 커널이냐 애플리케이션이냐 이 2가지만 존재함
	2. Dual-Mode 연산
		1. 유저모드에서 커널로 진입 할때 그림
		2. Mode bit를 통해서 알수 있음(0,1)
		3. 모드 비트가 유저인데 커널 연산을 하려 하면 막음
		4. 유저 모드(1): 애플리케이션 실행,HW에 직접적으로 접근 불가
		5. 커널 모드(0):HW에 직접 접근 가능 
		6. ~={red}유저 모드에서 HW에 접근하고 싶으면 시스템 콜을 통해서 trap을 하여야만 HW에 접근 가능하다=~
18. VM환경에서 Trap과 Emulation
	1. **~={red}게스트 OS입장에서 시스템 콜 호출: Guset OS에서 시스템 콜 요청을 Guest OS 커널로 보냄-> 커널에서 exit을 하여 하이퍼바이져로 감 -> trap된 요청을 emulation함(실제로 커널로 진입하는 것 처럼) -> 모든 일이 끝나면 vm enter를 통해서 guest os로 들어감=~**-매우 중요
	2. Non-root 모드인 게스트 커널에서 trap하여 root 모드인 하이퍼바이져로 넘어감
	3. 크게 보면 Guest OS는 유저모드로 돌아가고 있는 하나의 애플리케이션 처럼 생각할 수 있다
19. 
20. **~={red}Binary Translation: 과거에 가상화가 지원되지 않았던 CPU들을 SW적으로 가상화를 했던 기술=~**
	1. 게스트에서 시스템콜 하면 하이퍼바이져에서 하드웨어에 안전한 명령어로 변환해줌
	2. 하드웨어 가상화가 지원되지 않던 시절에 많이 사용했음
	3. 현재도 vCPU와 Binary Tranlaiton을 동시에 사용해서 성능 극대화 하는 것도 있음
21. 계층이 많을수록 성능 저하가 일어날 수 밖에 없다
	1. 가상화 없은 순수 Native > 세미 가상화 > 전 가상화 > 에뮬레이션 순서로 성능이 좋다 
	2. 현재에도 성능을 높히려는 시도가 끊임없이 일어나고 있다
		1. 예시
		2. 서버 가상화 환경에서 하나의 NIC나 IO 장치를 여러 VM에서 직접적으로 공유해줄 수 있는 하드웨어 가상화 기술
22. 클라우드 기반 가상화 보안 아키텍쳐
	1. 하이퍼바이져가 가상화를 시켜주는 것
	2. 하이퍼바이져 보안 = 가상화 보안
	3. 하이퍼바이져에서 많은 보안 문제가 발생한다
23. 가상화 보안 개요
	1. 가상 머신이 3개 있다고 가정
		1. 가상 머신 자체가 악성일 가능성
		2. 애플리케이션 하나가 악성일 가능성
	2. 하나의 가상머신이나 애플리케이션이 악성이면 그 하**나가 다른 게스트 OS나 하이퍼바이져 자체를 공격할 수 있다**.
	3. 가상 보안이 더 중요한 이유: 다른 가상화 데이터들을 공격 할 수 있어서
24. 가상화 기술 이익과 위험과 위험으로 부터 발생가능한 이슈 5개
	1. 손쉬운 가상 머신 생성-VM이 빠르게 많이 생성될 위험
	2. 쉬운 네트워크 세팅-잘못된 네트워크 설정->다른 zone이 공격 당할 수 있음
	3. 등3개
	4. 효율성이 올라간 만큼 복잡성이 증가하고 보안 입장에서 신경쓸게 많음
25. 가상화 공격 타겟
	1. 물리 HW
	2. VM os
	3. VM 하드웨어
	4. VM 구성 파일
	5. 원격 관리/컨트롤 인터페이스
	6. 게스트 OS
	7. 가상화 네트워크
26. 가상화 보안 모델의 발전:impact와 trusted 관점으로
	1. 점점 진화하고 있음
27. 가상화 보안 걱정거리들
	1. 새로 추가한 **OS 자체의 위험**: OS 자체가 보안 위협을 가지고 있음
	2. **네트워크 침입 탐지에 한계**: 가상 OS마다 네트워크 접근을 가지고 있기 때문에
		1. IDS: 패킷 공격 탐지(Detection),IPS: 실시간 방어(IDS보다 강력)
	3. **관리 복잡성**
		1. 가상화 자체에서 오는 복잡성 관리 문제
28. 가상화된 클라우드의 걱정거리들
	1. 치명적 공격의 타겟으로서의 하이퍼바이져
		1. 하이퍼바이져 자체가 공격 당하면 모든 클라우드 전체가 공격 받을 수 있음(하이퍼바이져는 일반 OS의 커널과 비슷한 역할을 하기 때문에)
	2. 리소스 할당 보안 위협
		1. 할당 해제된 리소스에 전에 사용했던 데이터가 남아있으면 데이터 유출
	3. 가상 네트워크 인프라구조 관리
		1. 변경이 일어날 때마나 네트워크를 재 설정해야함
29. 가상화된 클라우드의 걱정거리들2
	1. 동적 네트워크 모니터링
		1. 가상 네트워크가 계속 변하기 때문에 모니터링의 어려움
	2. 구성 및 변경 관리의 복잡성
		1. 이미지 안에 있는 개별 구성요소들이 업데이트를 받을때 문제 발생 가능
