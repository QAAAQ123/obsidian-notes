49. 컨테이너 네트워크 주요 보안 문제
	1. 컨테이너 컨텍스트 손실: 어디서 오는지 알 수 없는 문제-> 악의적인 컨테이너가 정상인척
	2. IP 기반의 접근제어 한계: 주로 iptables를 사용해서 접근 제어함->컨테이너의 IP 주소가 계속 바뀌기 때문에 계속 정책을 변경해줘야함
	3. 네트워크 정책 폭증: 컨테이너가 늘어날수록 정책이 폭팔한다.
50. 보안문제2
	1. 제한없는 호스트 액세스
	2. 제한없는 네트워크 권한이 있는 컨테이너
51. 제안된 시스템-Bastion
	1. 목표: 컨테이터 네트워크 보호/보안문제 악용 위협 방어/통신할 필요가 있는 컨테이너만 연결하도록 분리
	2. 구성 요소
		1. 관리자: 모든 정보 수집(설정,보안정책)
		2. 네트워크 가시성 서비스: 컨테이너를 볼수있는 것을 필요한 만큼만 제한
		3. 트래픽 가시성 서비스: 컨테이너간의 통신을 point-to-point으로 안전하게 격리/다른 컨테이너에게 노출되는것 방지
52. Bastion의 전체 아키텍쳐: 각 컨테이너마다 독립적인 보안 스택 제공/기본 구조를 우회에서 작동 가능(직접 목적지 컨테이너로 전달하게 끔)
53. Bastion manager 동작
	1. 주기적인 업데이트-활성화된 모든 정보 가져옴
	2. 운영자가 수동으로 업데이트 가능
	3. 컨테이너 종속성 맵 처럼 컨테이너간의 통신과 허용되는 포트 설정
	4. **각 컨테이너는 자신과 관련있는 정보만 받는다**
54. manager가 보안스택을 어떻게 관리하는지
	1. 컨테이너 플랫폼에서 정보를 받아 네트워크 맵과 종속성 맵을 생성한다. -> 스택 관리를 통해서 각 컨테이너에 보안 스택을 배포하거나 업데이트 한다.
		1. 새로운 컨테이너는 매니저는 보안 스택을 설치하고 맵을 업데이트
		2. 이미 실행중인 컨테이너는 변화가 생기면 매니저는 해당 컨테이너의 보안 스택의 맵만 업데이트 한다
		3. 서비스 중단없이 업데이트가 이루어질수 있도록 한다.
55. 네트워크 가시성 서비스의 구체적인 동작1
	1. 컨테이너 검색 문제
		1. 컨테이너가 다른 컨테이너를 찾을 때 ARP 검색을통해 네트워크 정보 수집-> 악의적인 컨테이너가 모든 정보 수집할 수 있음-> Driect ARP handler가 이 문제 해결
		2. 통신이 허용된 컨테이너라면 ARP Repley를 생성해서 요청한 컨테이너로 보냄(**ARP 요청이 브로드캐스트 되지 않는다는 점이 중요하다.)** -> 공격자가 네트워크 토폴로지 수집하는것을 원천 차단함
56. 네트워크 가시성 서비스의 구체적인 동작2
	1. 직접 ARP 핸들러의 한계점: 컨테이너 레벨의 격리에만 국한되어있고 이미 종속된 컨테이너간의 악의적인 활동은 막을 수 없다 
	2. 한계점 보안을 위해 컨테이너 인식 네트워크 격리 제안
		1. 목적지 포트를 키로 사용해서 종속 맵을 조회한다 -> 종속성 맵을 조회한다 -> 정책 매치: DP와 TCP가 일치하면 패킷을 forward/drop 한다
		2. 양방향으로 가능함
57. 트래픽 가시성 서비스1
	1. 현재 솔루션들이 소스를 어떻게 확인하고 있는지: iptables에서 패킷 헤더의 소스 IP와 MAC만 확인한다 -> 이방식이 ARP 스푸핑에 취약함(not 연산 미지원,소스에 대한 모든 가능한 흐름 규칙을 정의해야 함)
	2. Bastion에서 제한하는 소스 검증
		1. 그림: 소스 ip,mac 주소,소스 인터페이스 확인함
		2. 컨테이너에서 요청이 들어오면 bastion의 소스 검증이 동작함 
		3. 패킷의 메타데이터(if_index)까지 확인을 함
		4. if_index와 ip,mac주소,소스인터페이스 중 하나라도 일치하지 않는다면 bastion은 패킷은 스푸핑 한것으로 판단함
58. 트래픽 가시성 서비스2
	1. 엔드투 엔트 직접 전달: 소스 컨테이너에서 목적지로 전달 될때 호스트의 네트워크 스택을 거친다.(XDP/eBPF를 사용하면 이 과정 우회 가능)
	2. 원래 방식으로 하면 정보를 볼 수 있다.
	3. Bastion의 엔드투엔드 직접 전달을 사용하면 중간에 컨테이너 네트워크를 우회한다.(다른 컨테이너는 볼 수 없다)
59. 실제 컨테이너 검색
	1. Bastion이 없을 때: arp 명령어 사용하면 배포된 전체 컨테이너 네트워크 정보를 볼 수 있음
	2. Bastion이 있을 때: arp 명령어를 사용해도 실제로 통신하는 컨테이너만 보여준다
	3. 컨테이너간 네트워크 가시성 최소화 -> 공격 대상을 찾는 것을 원천적으로 차단
60. 쿠버네티스: 컨테이너화된 워크로드 오케스트레이션 서비스
	1. 컨테이너 기반 서비스를 조율하고 선언적 구성 및 자동화 기능을 갖춘 가장 강력한 오픈 소스 플랫폼을 제공
61. 쿠버네티스 역할
	1. 컨테이너 실행,관리
	2. 원하는 앱 상태를 선언적으로 표현(웹 서버3개를 실행하라고 선언하면 자동으로 동작)
	3. 원하는 상태 유지
	4. 운영자 책임과 클러스터 운영 책임
	5. 하지 않는 일
		1. PaaS아님
		2. 배포,스케일링,로드밸런싱,로깅,모니터링을 사용자가 선택해서 사용
		3. CI/CD 플랫폼이 아니다
		4. 머신 설정,유지관리,자동 복구 시스템을 제공하지 않음-서버 자체를 관리하지 않음
		5. 단순한 오케스트레이션 시스템이 아니다. 제어 프로세스들로 구성되어있기 때문에
62. 쿠버네티스 동작 원리
	1. 현재 상태를 지속적으로 변경하여 원하는 것 달성
	2. 관찰: 현재 상태 관찰하고 변화도 감지
	3. diff: 차이를 찾아가는 단계(현재 상태와 원하는 상태간의 차이 찾아냄)
	4. act: 행동-원하는 상태로 도달하기 위한 조치를 취함-> Desired state로 수렴함
63. 핵심 기능
	1. 스케일 인/아웃: 필요에 따라 컨테이너수 확장/축소
	2. 로드 밸런서: 들어오는 트래픽을 여러 컨테이너에 균등하게 분산
	3. 롤링 업데이트: 무중단으로 업데이트
	4. 자동 복구: 자동으로 컨테이너 새 컨테이너 생성해서 복구
	5. 지속성 볼륨: 재시작 되더라도 데이터 유지할 수 있게 영구 저장소 제공
	6. 컨테이너 오케스트레이션: 여러 호스트에 분산된 노드들을 중앙에서 통합 관리한다
64. 쿠버네티스 클러스터의 전체 구조
	1. control plane과 worker node로 구성
		1. control plane: 4가지의 핵심 컴포넌트
			1. ectd: 데이터 저장
			2. kube-api-server: 클러스터의 모든 요청을 받아서 처리
			3. kube-scheduler: 새로운 파드를 어느 노드로 배치할지
			4. kube-controller-mananger: 클러스터의 상태 관리
		2. worker node: 실제로 컨테이너가 실행되는 곳
			1. kubelet: 해당 노드의 파드 관리
			2. kube-proxy: 네트워크 트래픽 라우팅
65. 쿠버네티스 핵심 객체
	1. Pod: 구성 가능한 가장 작은 단위:하나 또는 이상의 컨테이너 그룹으로 구성/설정을 공유/고유한 API 주소 할당/동일한 네트워크 네임스페이스 공유/로컬 네트워크를 통해 네트워킹 가능
	2. Service: Pod접근 지점/안정적인 네트워크 인터페이스 제공/클러스터내의 여러 파드로 트래픽 분산하는 로드밸런싱 기능-여러 곳에서 접근 가능한 통합 도메인/여러가지 타입 제공
	3. ReplicaSet: 지정된 갯수의 레플리카를 유지해서 원한는 파드의 수 보장/워커 노드가 실패하거나 불가능해지면 자동으로 새로운 파드 생성(비권장)
	4. Deployment: ReplicaSet의 라이프사이클을 관리하는 상위 수준의 컨트롤러/배포와 버전 관리를 위한 롤링과 롤백 지원/Revision tracking으로 ReplicaSet 변경 이력을 저장해서 롤백 제공/무중단 서비스 제공을 위한 파드 라이프 사이클 관리
66. CaaS(컨테이너 서비스)
	1. 구독 기반형 서비스 모델
	2. 어디서나 컨테이너 관리 가능
	3. 특징
		1. 온프레미스와 쿠버네티스 환경 모두에서 배포 가능
		2. 관리를 위한 API 및 웹 포털 인터페이스,컨테이너화된 애플리케이션 개발
		3. 자동으로 컨테이너 라이프사이클 관리
67. K8S 파드 구서이 어떻게 되는지,어떤 문제가 있는지
	1. 문제1: 각 노드에 존재하는 컨테이너 네트워크가 동일한 IP 대역을 가지고 있는 경우, Pod들이 서로 동일한 IP를 할당받을 가능성이 있다. 하지만 Pod는 모두 고유한 IP를 가져야 한다
	2. 그림의 foo와 baz의 같은 ip를 사용하기 때문에 네트워크에 혼란
68. 문제2:어떤 노드가 목적지인지 ip를 찾을 수 없다,자체 노드에 존재하는 Pod IP만 식별할 수 있기 때문에
	1. 클러스터 전체의 IP 정보를 각각의 노드가 알 수 있어야 함(CNI 플러그인 사용해야 함)
69. K8S 네트워크의 기본 개념과 요구사항
	1. 요구 사항
		1. 모든 Pod는 NAT없이 다른 모든 Pod와 통신 가능해야 한다
		2. 모든 노드는 NAT없이 모든 파드와 통신할 수 있어야 한다(반대도)
		3. 파드가 자신을 보는 IP와 다른 파드들이 자신을 보는 IP가 동일해야 한다(IP의 변화가 없어야 한다)
	2. 개념: **세부사항 나중에 작성**
		1. 컨테이너: 파드안의 네트워크 네임스페이스 공유
		2. 파드: 클러스터 고유 IP가 있는 임시 파드
		3. 서비스: 영구 클러스터 고유 IP
		4. 외부 접근: 클라우드 공급자나 외부 로드 밸랜서에서 관리
70. 네트워킹2
	1. 유형1:컨테이너 to 컨테이너 네트워킹(컨테이너간 통신): 동일한 파드내에 컨테이너간의 통신은 공유된 네트워크 네임스페이스를 통해 이루어진다
		1. 파드안에 모든 컨테이너는 동일한 IP주소와 포트를 공유
		2. 로컬로 통신
	2. 유형2:파드 to 파드 통신(파드간 통신): 클러스터 전체의 고유한 IP주소 사용
		1. 각 파드는 노드가 지정한 CIDR 범위에서 고유한 IP를 받는다
		2. 트래픽은 버츄얼 이더넷 페어와 버츄얼 브릿지를 통해 흐르며 파드와 root 네트워크 네임스페이스를 연결한다
71. k8s의 공격 벡터
	1. 클러스터 레벨의 공격
		1. 머신/VM에 대한 접근: 물리/가상 머신에 직접 접근해서 전체 클러스터 손상
		2. ectd API에 대한 엑세스: ectd에 접근하여 중요한 데이터 공격
72. 공격 벡터2
	1. 노드 레벨의 공격
		1. k8s api또는 프록시를 이용한 접근: API 서버를 통한 무단 접근으로 클러스터의 리소스 조작하는 공격
		2. 컨트롤 플레인 구성요소 공격: kube-apiserver, kube-scheduler와 같은 핵심 구성 요소의 트래픽을 가로채거나 수정
		3. Kubelet API를 통한 액세스: 각 노드에서 Kubelet API를 통해 직접 노드 제어
73. 공격 벡터3
	1. 컨테이너/앱 레벨의 공격
		1. 컨테이너 탈출: 격리를 깨고 호스트로 접근하는 공격,성공하면 호스트의 모든 권한 얻음
		2. 앱 취약점: 앱 코드의 취약점 악용
		3. 앱 트래픽 가로채기: 앱간 통신을 가로채거나 수정
74. 컨테이너 탈출 배경지식
	1. runC: 컨테이너 엔진이 사용하는 모든 시스템을 포함하는 도구/컨테이너 생성 및 실행에 사용/Docker와 같은 컨테이너 소프트웨어에서 주로 사용되지만 독립적으로도 실행가능
	2. 그림은 runC의 정상적인 실행 과정
75. 컨테이너 탈출 배경지식2 - Proc 파일 시스템
	1. 프로세스에 대한 정보를 제공하는 가상의 파일 시스템
	2. 모든 프로세스는 PID를 사용하여 라벨이 지정된 파일 시스템에 폴더를 갖는다
	3. 파일시스템으로 노출되는 시스템 데이터에 대한 인터페이스 역할
		1. 컨테이너도 자체적으로 proc 파일 시스템을 가질 수 있다
		2. 컨테이너 내의 프로세스는 컨테이너 외부의 proc 폴더를 볼 수 없다
	4. 각 프로세스는 자체 디렉토리를 가진다
76. 컨테이너 탈출 배경지식2 - Proc 파일 시스템
	1. proc/self 디렉토리
		1. 현재 실행중인 프로세스의 `/proc/<pid>` 디렉토리를 가리키는 심볼릭 링크
			1. /proc/self/exe - 프로세스가 현재 실행 중인 실행 파일에 대한 심볼릭 링크
			2. /proc/self/fd - 프로세스가 연 파일 기술자가 들어 있는 디렉토리
		2. self/exe가 메모리 상에 프로세스 바이너리 파일을 가리킨다
		3. 이 파일에 접근하면 컨테이너는 링크를 해석하는 대신에 커널 메모리에 직접 파일 데이터를 제공한다
77. 컨테이너 탈출 사례:runC를 통한 도커 브레이크 아웃 공격
	1. runC 컨테이너 이스케이프 취약점을 악용하여 루트 셸 접근 권한을 얻음
	2. 공격 방법: 컨테이너 내부에서 호스트의 runC 바이너리를 덮어씀
	3. host에서 root레벨 공격을 가능하게 한다.
	4. 전제 조건: 컨테이너 내에서 루트 권한이 필요하다
	5. 오른쪽 그림은 runC를 속이는 과정이다
78. 사례-취약점 악용의 2가지 속성
	1. proc/self/exe의 심볼릭 링크
		1. 실행중인 프로세스를 가리킴,접근시에는 파일 직접 제공
	2. 특권 컨테이너
		1. 루트 호스트를 매핑하는 컨테이너
		2. 도커 컨테이너는 기본적으로 특권을 갖는다
	3. **나중에 다시 보기 47분대 4-2**
79. 공격 데모: 직접 바이너리 수정을 통한 공격
	1. runC 파일 자체를 변조하는 방식
	2. 악성 프로그램을 만들어서 컨테이너에서 실행 -> /bin/sh를 /proc/self/exe로 덮어쓰고 runC를 가리키는 프로세스를 찾음 -> docker exec 명령어로 /bin/sh를 실행하면 도커의 runC가 자기 자신을 실행
	3. 왼쪽: 악성 컨테이너를 준비하는 단계(덮어쓰는 과정)
	4. 오른쪽: 도커에서 공격 실행하는 과정
		1. docker exec 명령어로 컨테이너에 접근 -> runc에서 runc init 프로세스 생성 ->host runc를 실행하면 runc fd를 획득해서 host runc 바이너리에 대한 참조를 획득 
80. 공격에서 바이너리로 덮어쓰는 단계
	1. runc가 종료된 후에 바이너리를 열어 악성 코드를 추가 할 수 있다
	2. 악성 코드를 추가하고 그 다음에 runc를 실행하면 악성코드가 루트 권한으로 실행된다.
	3. 영구적으로 시스템 해킹,은밀하게 공격
	4. 컨테이너 재시작,시스템 재부팅해도 공격이 유지됨
	5. 측면 이동 공격도 가능
81. 공격 과정1-**~={red}시험에 나올듯=~**
	1. 도커 exec이 runc를 실행하면 컨테이너 내부에서 요청한 /bin/sh를 찾는다. 
	2. 그 사이에 악성 코드는 runc를 가리키는 `/proc/<pid>/exe`를 찾기 위해 /proc를 스캔하고 있다
82. 과정2
	1. /bin/sh이 self/exe 반환
	2. runc는 호스트에 있는 /proc 디렉토리를 통해 exe를 찾고 runc 바이너리를 가리킨다(proc는 호스트 시스템에 속하기 때문에)
83. 과정3
	1. runc가 컨테이너 내에서 runc 인스턴스를 실행한다.
	2. 이렇게 되면 /proc에 runc를 가리키는 디렉터리가 존재한다
	3. 프로세스가 아직 실행중이기 때문에 바이너리를 직접 쓸수는 없지만,파일 디스크립터를 저장할 수 있다
	4. /proc/self/exe 트릭으로 생성된 runc 복사본이 실제로 호스트의 runc와 동일한 바이너리를 참조하게 된다 -> 이게 악용된 runc 인스턴스가 된다
84. 과정4
	1. /bin/sh만 실행을 했기 때문에 runc에 인자를 주지 않아서 runc가 종료된다
	2. Docker exec는 shell을 실행할 수 없다고 보고한다(/bin/sh를 실행했다고 생각하고 있기 때문에)
	3. 이렇게 획득한 파일 디스크립터를 사용해서 메모리에 아직 있는 runc 바이너리를 쓸 수 있다
85. 방법2-공유 라이브러리 접근법
	1. runc는 그대로 두고 의존성이 있는 라이브러리를 교체
		1. 사용자가 기존 공격자가 제어하는 컨테이너에 명령을 실행하거나 악성 이미지를 실행할 때 작동하도록 하는 방법
		2. 공유 라이브러리중 하나를 자체 버전으로 만들어서 저장한다 -> 새로운 runc는 로컬 라이브러리를 먼저 찾게 된다
		3. 그림: 악성 라이브러리 로드-컨테이너 내부의 runc가 내부의 라이브러리를 로드할 때 악성 라이브러리를 사용한다
86. 실제 사례
	1. 공급망 손상과 컨테이너 탈출을 결합한 공격이 있었다.
	2. 공급망 손상: 신뢰할 수 있는 레지스트리를 통해 배포된 악성 컨테이너 이미지
	3. 컨테이너 이스케이프 실행: 런타임 중에 CVE-2019-5736 악용이 발생함
	4. 컨테이너 시스템의 침투로 완전한 데이터 유출 및 손상
	5. supply chain -> container escape
87. DevOps와 DevSecOps의 차이
	1. DevOps: Development + Operation
	2. 개발과 운영의 결합을 통해 개발주기 단축
	3. 빌드,배포,테스트 프로세스를 자동화
	4. 순환 과정 그림
88. DevSecOps: DevOps에 security 추가
	1. 처음부터 DevOps에 보안 실천 사항들을 통합
	2. 개발과 운영팀 전체에 걸쳐 보안 공유책임을 내재화
	3. 개발 파이프라인에서 보안 테스트를 더 일찍 이동하여 취약점을 더 빨리 식별
	4. 각 단계마다 Secure coding,threat model 등의 보안 활동이 통합되어 있음
89. 도구들
	1. 동일한 단계에서 security tool이 추가됨
90. 쿠버네티스 런타임에서 DevSecOps 과제
	1. 컨테이너화된 앱의 컨텍스트 이해
	2. 컨테이너화된 앱에서 트래픽 흐름 로그 얻기
	3. 앱을 깨지 않고 보안을 확보
	4. 전체적으로 소유와 검증하기
	5. 동적 인프라 환경에서 일관적인 정책 관리
	6. 멀티 클러스터 환경에서 중앙화 되고 통합된 정책 구현