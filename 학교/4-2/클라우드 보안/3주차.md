35. 클라우드 배포 모델 비교
	1. 퍼블릭
	2. 프라이빗
	3. 하이브리드-퍼블릭,프라이빗 반반/~={red}보안관점에서 가장 안전한 방식=~
		1. 중요한 정보는 프라이빗에 저장하고 퍼블릭에는 정보 가공 및 다른 활동하면 중요 정보 보안 가능
	4. 멀티-2개 이상의 퍼블릭 클라우드 배포
36. 퍼블릭 클라우드
	1. 퍼블릭 장점
	2. "" 단점: 자유도가 프라이빗 보다 떨어짐
37. 프라이빗 
	1. 온 프리미스
	2. 제 3자가 제공해주는 클라우드
	3. 완전한 제어권,향상된 보안
	4. 높은 초기 비용
	5. 예시: VMWare,OpenStack(프라이빗 클라우드 가상화 무료 소프트웨어)
38. 하이브리드 클라우드
	1. 반반
	2. 리스크 적음,보안 향상
	3. 관리 복잡성 증가
	4. 예: anthos,stack,out.....
39. 멀티 클라우드
	1. 퍼블릭 클라우드 2개이상 사용한 클라우드
	2. 밴더 락인 피함
	3. 복잡성 증가,오버헤드 증가
40. Iaas의 모습(전반적인 클라우드 모습)
	1. Iaas에서 가상화까지 CSP가 제공함 
	2. 이후부터는 사용자가 사용
41. lass가 제공하는 기술-**~={red}가상화,스토리지,컨테이너 기술=~**
	1. 가상화 기술
		1. 한개의 리소스(HW)를 공유해야 하기 때문에 가상화 필요함
		2. 보안 관점에서 
	2. 스토리지 기술
		1. 블럭,파일,객체를 저장 시스템으로 이용
	3. 컨테이너 기술
		1. VM하나를 대여해주는게 overhead가 큼
		2. 그래서 나온 기술
		3. 게스트 OS필요 없음
42. Pass가 제공하는 기술- **~={red}laaS+프레임워크,Database=~**
	1. 미들웨어까지 세팅하여 제공함(DB,Framework 포함)
	2. 세팅되어있는거 쓰면됨
	3. DB도 PaaS에 속함
43. 가상화
	1. 가상화: 여러 사용자가 한개의 물리 하드웨어를 사용할 수있게 한개의 하드웨어를 여러개의 **논리적 단위로 분리**하여 제공-**~={red}물리 하드웨어로부터 분리(디커플링)=~**
	2. 클라우드 컴퓨팅의 핵심: 가상화(인터넷을 통한 공유)
	3. 가상화의 목적: 효율성
	4. 가상화 기술
		1. **서버 가상화**
		2. **네트웨크 가상화**
		3. **저장소 가상화**
44. 서버 가상화
	1. VMware: 하이퍼바이져의 예시
	2. **한개의 물리 장치를 ~={red}하이퍼바이져=~를 통해 여러개의 VM으로 만든다**
45. 서버 가상화의 진화
	1. 2010년 가상화 기술을 통해 효율화
46. 왜 서버 가상화?
	1. 전통 서버 
		1. 하나의 물리 서버 = 하나의 OS = 하나의 서비스
		2. 리소스 낭비
		3. 스케일 업 문제
	2. 해결: 서버 가상화
47. 서버 가상화의 목표
	1. Equivalence(등가성): 물리적환경과 논리적(가상)환경이 **구분이 되지 않을 정도**로 해야한다
	2. 퍼포먼스: VM위에서 돌아가는 서비스는 물리적 서버가 하이퍼바이져를 통해 가상화 되기 때문에 물리 장치보다 느릴수밖에 없다(퍼포먼스 향상하는 방향으로 발전/오버헤드 감소)-**성능 향상**
	3. 안전성:다른 VM과 완전히 분리되게 하는 것-**완전한 격리성**
48. 서버가상화 장점
	1. Server Consolidation(**서버 강화**): 물리적으로 떨어져 있어도 가상화를 사용하면 한대의 머신을 사용하는 것 처럼 가상화하는것
	   ex) 512gb 4개가 떨어져있는데 한개의 저장장치 처럼 동작
49. 장점2
	1. Encapsulation(**캡슐화**): 모든 정보들이 파일로 저장되어있기 때문에 관리/이식 용이
50. 장점3
	1. Fault Tolerance and High Availablity(**고 가용성**): 복구가 빠름
51. 장점4
	1. **완벽한 isolation**: 하나의 VM이 다른 VM에 접근 불가
	2. 여러개의 OS를 동시에 사용 가능
	3. 같은 OS에 다른 버전을 동시에 사용 가능
52. 서버 가상화의 요소들
	1. 하드웨어(물리 머신)
		1. **~={red}가상화를 지원하는 물리 HW가 있어야 한다.=~**
	2.  하이퍼바이져 타입2인 경우에는 Host OS 필요
53. 가상화의 요소
	1. 하이퍼바이져
		1. 가상화 레벨에서 도는 거대한 CORE SW
		2. VM을 생성,삭제,세팅하는 가상화를 해주는 요소
		3. 하드웨어를 가상화해줌
		4. 2가지 타입 존재
			1. bare-metal: Host OS필요없음,HW위에 바로 하이퍼바이져 있음
			2. hosted:Host OS 필요
54. 서버 가상화의 요소2-하이퍼바이져 상세
	1. 타입1: 왼쪽 그림/2보다 더 좋은 성능
	2. 타입2: 오른쪽 그림/세팅이 1보다 편함
55. 서버 가상화의 요소3
	1. VM
	2. VM은 Guset OS 반드시 필요
	3. 가상 하드웨어 필요
56. 네트워크 가상화1
	1. VM이 본인의 네트워크를 가진것 처럼 네트워크를 가상화하는 기술
	2. 물리적 서버에 하나의 네트워크 입력이 들어오면 네트워크 가상화를 통해 네트워크를 쪼개서 여러개의 VM에 들어가게 한다
57. 네트워크 가상화2
	1. 핵심 장점
	2. 기술 **~={red}=~**
		1. VLAN(용량 한계),VXLAN(VLAN의 확장),VPN(프라이빗 가상 네트워크/VPN을 이용하면 회사 네트워크 망을 집에서 접속 할 수있다)
	3. 가상 네트워크의 요소
		1. bridges,bonded interfaces,vitrual ethernet
58. 네트워크 가상화 발전:VLAN -> VXLAN -> VPN -> SDN -> Cloud-Native Network
	1. 90년대: VLAN(모잘라서 VXLAN나옴)
	2. 00년대: VPN(내부망을 외부에서 안전하게 접근 할 수 있게)
	3. 10년대: VXLAN/SDN개념이 나오면서 네트워크의 모든것이 오픈됨(예전에는 기업마다 SW나 사용법이 달랐음)
	4. 20년대: 컨테이너 기반의 클라우드-네이티브 환경
		1. 컨테이너 기반으로 네트워크를 관리함
59. VLAN
	1. **2계층 환경 내에서 네트워크 격리 및 트래픽 관리 기능을 제공**
	2. 패킷헤더에 태깅으로 망 구분(논리적 망 구분)
	3. 패킷에 VLAN헤더 영역이 있음(Layer2 영역)
60. VLAN의 한계와 VXLAN
	1. VLAN: 4094의 유니크 ID를 사용 가능
	2. ID가 충분하지 않아서 VXLAN이 나옴
	3. VLAN은 layer2,VXLAN은 layer3까지 사용한다
		1. UDP 패킷안에 Layer2를 캡슐화해서 제공
61. VXLAN
	1. 2^24개의 ID
62. VPN
	1. 패킷을 IPSec이나 다른 기술을 통해 인크립션??하여 사용
63. VPN2
	1. Bridge-2계층
	2. 소프트웨어적으로 네트워크를 나눌 수 있음
64. VPN3-가상 네트워킹
	1. 가상 이더넷: 호스트와 컨테이서 사나의 네트워크 조절(하나의 Peer)
	2. Iptables: 리눅스에서 제공하는 기능(패킷 필터링(layer3기반,IP기반))
65. **~={red}저장소 가상화=~**
	1. 물리 저장 장치를 하나로 추상화/중앙 집중 관리/유연한 스토리지 할당
	2. RAID는 여러 개의 물리 디스크를 묶어 ~={red}**데이터 안정성**=~(결함 감내)이나 ~={red}**성능**=~을 향상시키는 기술인 반면, LVM은 물리 디스크(혹은 RAID 볼륨) 위에 논리적인 계층을 두어 파티션 크기 조절이나 스냅샷 생성 등 저장 공간을~={red} **유연하게 관리**=~하는 기술입니다.
	3. RAID,LVM등이 있음
	4. ~={red}**물리적으로는 여러개가 있는 거를 논리적으로 하나로 합쳐주는 것**=~: LVM
	5. 소프트웨어적으로 있는것 처럼 보이는 가상화 
66. RAID-저장소 가상화1
	1. RAID 0-스트라이프(백업 없음)
	2. RAID 1-미러링(이중화)
	3. RAID 5-스트라이프 및 패리티(최소 3개의 디스크)
	4. RAID 6-스트라이프 및 듀얼 패리티(최소 4개의 디스크)
67. LVM-저장소 가상화2
	1. 물리적으로 나눠져 있는 것을 논리적으로 하나로 보이게 하는 것
68.  NAS and SAN
	1. NAS: 장점-초기 구축 비용이 크지만 CSP에 종속적이지 않고 안전하고 구독료 내지 않아도 된다-**~={red}파일 레벨=~** 데이터 저장소
69. ~={red}**RAID**=~는 여러 물리 디스크를 묶어 데이터 **백업 및 성능 향상**을 목표로 하는 기술입니다. ~={red}**LVM**=~은 물리 디스크 구성을 추상화하여 논리적인 볼륨을 **유연하게 관리**(크기 조절, 스냅샷 등)하는 데 중점을 둡니다.
70. 컨테이너 테크놀로지
	1. 도커 등장 이후에 클라우드 네이티브라는 용어가 생김
	2. 클라우드 네이티브: 애플리케이션을 클라우드로 배포할걸 염두하고 개발,배포를 하는것->컨테이너가 나온뒤로 가속화됨
	3. 가상화와의 차이점: 컨터이너는 컨테이너 엔진위에 앱 올라가고 가상화는 하이퍼바이위에 게스트 OS위에 앱이 올라감
	4. 컨테이너가 가상화보다 효율적임
	5. OS 레벨에서 가상화를 해줌(하이퍼바이져 필요 없음)
	6. 컨테이너는 Host os의 커널을 공유한다.-> 커널을 공유하기 때문에 가상화보다 보안의 문제가 생길 위험이 크다
	7. 프로세스 레벨에서 분리(고립) 가능
	8. 가벼운 아키텍쳐
71. VM단점
	1. 유후자원 문제 발생함
	2. **~={red}유후자원 문제를 해결하기 위해 VM이 나온건데 VM도 유후자원이 생김=~**
	3. **~={red}VM의 유후자원 문제를 해결하려고 나온 것이 컨테이너이다=~**
72. Docker
	1. Go 언어로 씌여짐
	2. 컨테이너 관리/생성/실행/배포 등
	3. 없던 것에서 새롭게 만든게 아니라 도커 등장 이전부터 컨테이가 있었지만, 어려웠다
73. **~={red}Docker 아키텍쳐=~**
	1. Server(Docker Damon)-서버
	2. 도커 클라이언트-유저 인터페이스(Docker로 시작하는 명령어)
	3. 도커 레지스트리 -로컬 영역의 이미지 리포지토리-**~={red}이미지 로컬 저장=~**
	4. 도커 허브-원격 영역의 이미지 리포지토리-**~={red}이미지 원격 저장=~**
	5. 이미지-포장된 라이브러리들,실행가능한 파일,소스 코드 등
	6. 컨테이너-인스턴스(**~={red}이미지로부터 인스턴스를 만드는 것=~**)
	   자바에서 클래스=이미지/객체=컨테이너
	7. 이미지-저장(레지스트리 or 허브)-실행(인스턴스)
74. LXC
	1. **~={red}도커 이전=~**에 있던 컨테이너 기술
	2. 사용하기 어려웠음
	3. 초창기에 도커에서 LXC 많이 사용함
75. Cgroup-리눅스에서 원래 제공함-**Control group**
	1. 컨테이너를 가상화하기위해 **~={red}가상화 자원을 할당=~**하는 기준
	2. 가상화 자원 관리(vCPU,vRAM 등)
76. Namespace(중요한 개념)-리눅스에서 원래 제공함
	1. 컨테이너를 구분(Isolation)해주는 실질적으로 해주는 개념
	2. **~={red}컨테이너가 분리되어 작동=~**하게끔 
	3. 네임스페이스가 다르면 다른 것을 보지 못함