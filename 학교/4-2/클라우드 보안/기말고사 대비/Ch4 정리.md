1. 클라우드 인프라스트럭처 보안
	1. 핵심 목표
		1. 클라우드에 호스팅된 데이터,앱,서비스가 위협 행위자로부터 안전하게 보장
        2. 승인된 사용자에게 항상 가용성 보장
        3. 물리적 보안 통제와 가상 보안 통제를 결합하여 보안
        4. 클라우드의 특수한 동적 위협과 잘못된 설정으로 인한 위협 보호
    2. 위험
	    1. 구성 및 관리 위험
		2. 접근 및 신원 위험
		3. 네트워크 위험
		4. 가시성 및 규정 준수 위험
	3. 공격
		1. 설정 기반 공격
		2. ID 및 접근 기반 공격
		3. 네트워크 기반 공격
		4. 리소스 남용 공격
2. 클라우드 서비스 모델 보안
	1. IaaS,PaaS,SaaS
		1. IaaS: OS,애플리케이션,데이터,네트워크 제어
		2. PaaS: 앱 개발, 데이터 보호
		3. SaaS: 데이터 사용,접근 제어 및 사용자 인증
3. 클라우드 인프라 레벨의 보안
	1. 계정 보안
	2. 네크워크 보안
	3. 서버 보안
	4. Kubernetes 보안
4. 도커 
	1. 컨테이너 가상 머신(VM) 비교
	2. 도커:일관된 배포를 위해 종속성을 사용하여 애플리케이션을 패키징하는 컨테이너화 플랫폼
	3. 아키텍처
	4. 컨테이너 런타임
	5. 컨테이너 레지스트리
	6. 컨테이너 격리
		1. 네임스페이스
			1. namespace mount
			2. PID namespace
			3. network namespace
		2. 기능 및 보안
		3. Cgroups
		4. AppArmor/SELinux
	7. 컨테이너 네트워크
		1. 브리지
		2. 브리지 모드
		3. 호스트 모드
		4. 보안 과제
5. Bastion: 보안 강화 네트워크 스택
	1. 목표
		1. 컨테이너 네트워크 보호
		2. 보안 문제 악용 방어
		3. 컨테이너간 통신 분리
	2. 구성 요소
		1. Bastion 관리자
		2. 네트워크 가시성 서비스
		3. 트래픽 가시성 서비스
	3. Bastion 아키텍처
	4. Bastion manager 동작
	5. 보안 스택
		1. 네트워크 가시성 서비스
		2. 트래픽 가시성 서비스
		3. 컨테이너 검색
6. 쿠버네티스
	1. 역할
		1. 컨테이너 실행,관리
		2. 원하는 상태 선언적 표현
		3. 원하는 상태 유지
	2. 하지 않는 역할
		1. PaaS가 아님
		2. CI/CD 플랫폼 아님
		3. 서버 자체 관리하지 않음
	3. 동작 원리
		1. 관찰/행동/비교 반복
	4. 핵심 기능
		1. 스케일 인/아웃
		2. 로드 밸런서
		3. 롤링 업데이트
		4. 자동 복구
		5. 지속성 볼륨
		6. 컨테이너 오케스트레이션
	5. K8S 클러스터 구조
		1. control plane과 worker node
			1. control plane
				1. ectd
				2. kube-api-server
				3. kube-scheduler
				4. kube-controller-manager
			2. worker node
				1. kubelet
				2. kube-proxy
		2. 핵심 객체
			1. Pod
			2. Service
			3. ReplicaSet
			4. Deployment
	6. CaaS
	7. K8S Pod 네트워크 구성
			1. 요구사항
			2. 기본 개념
	8. K8S 네트워킹
			1. 컨테이너간 네트워킹
			2. Pod간 네트워킹
	9. 공격 벡터
		1. 클러스터 레벨
			1. 머신/VM 접근
			2. ectd API 접근
		2. 노드 레벨
			1. K8S API 서버를 통한 무단 접근
			2. control plane 구성 요소 공격
			3. kubelet API를 통한 접근
		3. 컨테이너/애플리케이션 수준
			1. 컨테이너 탈출
			2. 애플리케이션 취약점
			3. 애플리케이션 트래픽 가로채기
		4. 컨테이너 탈출 기본 지식
			1. Proc 파일 시스템
			2. runC
		5. **~={red}컨테이너 탈출 사례: CVE-2019-5736=~**
		6. 컨테이너 탈출 공격 시나리오
			1. 공급망 손상
			2. 컨테이너 탈출 실행
			3. 호스트 시스템 침투
7. DevOps와 DevSecOps
	1. DevOps + security
	2. Shift Left



### 탈출 공격
1. runc의 정상적인 실행과정
	1. runc 실행 명령으로 실행
	2. 컨테이너에서 runc init 프로세스 생성
	3. execve시스템 콜을 통해서 runc init -> user process로 전환됨
2. Proc 파일 시스템
	1. 프로세스의 정보를 제공하는 가상 파일 시스템
	2. 컨테이너도 Proc파일 시스템 가짐
	3. 컨테이너 내부에서는 프로세스 밖의 Proc를 볼 수 없다
	4. proc/self 디렉터리: /proc/'pid'를 가리키는 링크
		1. proc/self/exe: 프로세스가 현재 실행중인 실행 파일에 대한 심볼릭 링크
			1. self/exe는 프로세스의 바이너리 데이터를 가리킨다
			2. self/exe에 접근하면 커널에 직접 파일 데이터를 넣어줌
		2. proc/self/fd: 프로세스가 열어놓은 파일 디스크립터를 포함하는 프로세스


- 과정
	- ~={red}**조건: 컨테이너 내에서 루트 권한이 필요하다**
	- **컨테이너 내부 실행 파일에 /proc/self/exe를 참조하는 악성 스크립트를 덮어씌움**
	- **관리자가 docker exec 명령어 실행**
	- **runc 프로세스가 생성되어 컨테이너를 초기화하고 변조된 악성 스크립트 파일을 실행**
	- **악성 스크립트에 /proc/self/exe는 runc 바이너리를 가리키고 있다**
	- **공격자는 이것을 통해 파일 디스크립터를 확보한다**
	- **runc프로세스가 종료되는 순간 파일 디스크립터를 통해 runc 바이너리를 변조해 runc 바이너리 자체를 변조함=~**


## 1. 클라우드 인프라 보안 개요 & 책임 공유 모델

**핵심:** "누가 무엇을 책임지는가?"는 시험 단골 문제입니다.

- **정의:** 클라우드 기반 시스템, 데이터, 인프라를 무단 접근과 위협으로부터 보호하는 전략 및 정책
- **책임 공유 모델 (Shared Responsibility Model)**
    - **IaaS (Infrastructure as a Service):**
        - **고객 책임:** OS, 애플리케이션, 데이터, 네트워크 설정 (가장 할 일이 많음).
        - **제공자 책임:** 물리적 인프라, 가상화 계층.
    - **PaaS (Platform as a Service):**
        - **고객 책임:** 애플리케이션, 데이터.
        - **제공자 책임:** OS, 미들웨어, 런타임 등 플랫폼 전반.
    - **SaaS (Software as a Service):**
        - **고객 책임:** 데이터 사용, 사용자 접근 제어(IAM).
        - **제공자 책임:** 애플리케이션을 포함한 모든 인프라.

## 2. 주요 보안 위협 및 공격 유형 (암기 필수)

**핵심:** 위협의 종류와 그 내용, 대응 방안을 연결할 수 있어야 합니다.

### A. 주요 설정 오류 (Misconfigurations) - 가장 흔한 위험

- **Unrestricted Ports:** 네트워크 포트 개방 (예: SSH 22번, RDP 3389번 전체 허용).
    
- **Exposed Storage:** S3 버킷 등을 퍼블릭으로 설정하여 데이터 노출.
    
- **Default Credentials:** 기본 ID/PW 사용.
    

### B. 주요 공격 기법

1. **권한 상승 (Privilege Escalation):** 낮은 권한의 계정(예: 읽기 전용)을 탈취하여 관리자 권한을 획득하는 공격.
    
2. **크립토재킹 (Cryptojacking):** 클라우드 자원(VM)을 탈취하여 암호화폐 채굴에 무단 사용 (리소스 남용).
    
3. **자격 증명 대입 (Credential Stuffing):** 유출된 ID/PW 목록을 무차별 대입하여 로그인 시도.
    
4. **AiTM (Adversary-in-the-Middle):** 클라우드간 암호화 되지 않은 통신을 가로챔
    
5. **DDoS 증폭 (Amplification):** 클라우드 리소스를 반사체(Reflector)로 사용하여 타겟을 공격.
    

---

## 3. 서비스 모델별 보안 이슈 및 대응 (표로 정리)

|**모델**|**주요 보안 이슈 (Risks)**|**핵심 대응 전략 (Mitigation)**|
|---|---|---|
|**IaaS**|DoS 공격, VM 탈취/이스케이프, 설정 오류|**강력한 접근 제어(RBAC, MFA)**, 데이터 암호화, 정기 패치, 모니터링|
|**PaaS**|API 취약점, 의존성(라이브러리) 위험, 멀티테넌시 격리 실패|**DevSecOps(시큐어 코딩)**, API 보안 강화, 서드파티 라이브러리 관리|
|**SaaS**|Shadow IT(비인가 앱 사용), 데이터 주권/이동성 문제|**CASB(Cloud Access Security Broker)** 도입, 데이터 공유 정책 수립, 제로 트러스트|

---

## 4. 컨테이너 & 쿠버네티스 보안 (기술 심화)

**핵심:** VM과 컨테이너의 차이, 격리 기술, 네트워크 모드는 서술형 문제로 나오기 좋습니다.

### A. 컨테이너 vs 가상머신(VM)

- **VM:** 하이퍼바이저 위에서 **Guest OS를 포함**하여 실행 (무겁고 부팅 느림, 격리 수준 높음).
    
- **Container:** 호스트 OS의 **커널을 공유**하고, Bin/Lib만 패키징 (가볍고 부팅 빠름, 격리 수준 상대적으로 낮음).
    

### B. 컨테이너 격리 기술 (리눅스 커널 기능)

1. **Namespaces (보이는 것 격리):** 프로세스, 네트워크, 마운트 포인트 등을 격리하여 서로 보이지 않게 함. (PID, Network, Mount, IPC, UTS, User 등)
    
2. **Cgroups (쓰는 것 제한):** CPU, 메모리 등 자원 사용량을 제한.
    
3. **Capabilities & Seccomp:** 불필요한 시스템 호출(Syscall) 제한 및 권한 세분화.
    

### C. 컨테이너 네트워크 모드

1. **Bridge Mode (기본값):** `docker0` 브리지 사용. 컨테이너마다 고유 IP 할당. NAT를 통해 외부 통신.
    
2. **Host Mode:** 호스트의 네트워크 네임스페이스 공유. 별도 IP 없음. 성능은 좋으나 포트 충돌 위험 및 보안 취약.
    

### D. 쿠버네티스 구성 요소 및 공격 벡터

- **Control Plane:** `kube-apiserver`, `etcd` (설정 저장소, 탈취 시 치명적), `scheduler`.
    
- **Worker Node:** `kubelet` (노드 관리 에이전트), `kube-proxy`.
    
- **공격 포인트:** API 서버 접근, Kubelet API 악용, 컨테이너 이스케이프, Pod 간 트래픽 가로채기.
    

---

## 5. 컨테이너 네트워크 보안 기술 (Bastion 연구 내용 포함)

**핵심:** 기존 컨테이너 네트워크의 한계와 이를 해결하기 위한 `Bastion`의 개념을 이해해야 합니다.

### A. 기존 컨테이너 네트워크의 보안 한계

1. **컨텍스트 상실 (Loss of Context):** 패킷이 호스트로 나올 때 어떤 컨테이너에서 왔는지 식별 어려움.
    
2. **IP 기반 제어의 한계:** 컨테이너 IP는 동적으로 계속 바뀜.
    
3. **정책 폭발 (Policy Explosion):** iptables 규칙이 너무 복잡해져 관리 불가능.
    
4. **ARP 스푸핑 취약:** L2 공격에 취약함.
    

### B. Bastion (Security Enforcement Network Stack) 솔루션

- **목표:** 컨테이너 간 통신 샌드박스 구축.
    
- **주요 기능:**
    
    1. **Direct ARP Handler:** ARP 요청을 브로드캐스트하지 않고 보안 스택이 직접 응답 (ARP 스푸핑 방지).
        
    2. **Source Verification:** 패킷 헤더뿐만 아니라 커널 메타데이터(인터페이스 인덱스 등)를 통해 송신자 검증.
        
    3. **End-to-End Direct Forwarding:** 컨테이너 간 의존성이 확인된 경우에만 패킷을 직접 전달 (중간 단계 생략으로 성능 및 보안 확보).
        

---

## 6. 컨테이너 이스케이프 (RunC 취약점: CVE-2019-5736)

**핵심:** 공격 원리를 단계별로 설명할 수 있어야 합니다. (매우 중요!)

- **RunC란?** 컨테이너를 생성하고 실행하는 저수준 런타임 도구.
    
- **취약점 원리:**
    
    1. 공격자가 컨테이너 내부에서 악성 프로그램을 실행합니다.
        
    2. 이 프로그램은 `/bin/sh` 같은 실행 파일을 `/proc/self/exe` (현재 실행 중인 프로세스를 가리키는 심볼릭 링크)로 덮어씁니다.
        
    3. 관리자가 호스트에서 `docker exec` 명령어로 해당 컨테이너에 접속을 시도합니다.
        
    4. 이때 호스트의 **RunC 프로세스**가 컨테이너 내부의 조작된 `/proc/self/exe`를 실행하게 됩니다.
        
    5. 이를 통해 공격자는 **호스트의 RunC 바이너리를 덮어쓰고(Overwrite)**, 호스트의 **Root 권한**으로 임의 코드를 실행할 수 있게 됩니다.
        
- **결과:** 컨테이너를 탈출하여 호스트 시스템을 장악함.
    

---

## 7. DevOps vs DevSecOps

- **DevOps:** 개발(Dev)과 운영(Ops)의 통합. 속도와 효율성 중시.
    
- **DevSecOps:** DevOps에 **보안(Security)**을 통합.
    
    - **Shift Left:** 보안 검사를 개발 초기 단계(왼쪽)로 이동시키는 것.
        
    - **CI/CD 파이프라인 보안:** 빌드/배포 자동화 과정에 보안 스캔(SAST, DAST, 이미지 스캔)을 포함.
        

---

### 🎓 시험 대비 암기 팁 (Summary)

1. **책임 모델:** IaaS(OS부터 내가), PaaS(앱/데이터만 내가), SaaS(접근제어만 내가).
    
2. **13가지 설정 오류:** 다 외우진 못해도 **권한 과다(Excessive Permissions)**, **기본 설정 방치**, **로깅 부재**는 꼭 기억하세요.
    
3. **컨테이너 격리:** **Namespace**는 "보이는 것" 격리, **Cgroup**은 "쓰는 양" 제한.
    
4. **RunC 취약점:** 키워드는 **`/proc/self/exe`**, **File Descriptor**, **Host Binary Overwrite**.
    
5. **Bastion:** ARP 브로드캐스트를 막고(Direct ARP), 의존성 있는 컨테이너끼리만 통신시킨다.
    

이 요약본을 바탕으로 흐름을 이해하고, 슬라이드의 다이어그램(특히 RunC 공격 흐름도와 Bastion 구조도)을 한 번씩 눈에 익히시면 좋은 점수를 받으실 수 있을 겁니다. 화이팅하세요!