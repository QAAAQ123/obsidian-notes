## 접근 컨트롤
2. 개념
	1. 넓은 의미: 보안의 모든 것
	2. 좁은 의미: 특정 시스템에 리소스에 대한 접근을 허용/주체가 리소스의 접근 권한을 부여해줌
	3. 주체는 유저일 수도 있고 유저가 아닌 프로세스나 서비스도 될 수 있다
	4. CIA에 해당하는 행위를 허용할지 말지
3. 접근제어 요소
	1. 주체: 사용자/그룹/소유자 등...
	2. 객체: 시스템의 리소스
		1. 파일,디렉토리,레코드,프로그램 등
	3. 액세스 권한(퍼미션): 읽기,쓰기,실행,삭제,생성,검색 등...
		1. 리눅스에서는 rwx만
4. 접근제어
	1. 왜 중요한지
		1. 사용자 신원 증명(식별),인증,인가
		2. 진짜 유저인지 봇인지 판단(로그인의 Capca)
		3. 악성 활동 감지
		4. 침입 탐지에 도움
		5. 선별적인 엑세스를 통해서 해당 자원의 기밀성 유지를 도와준다
	2. 주요 목표
		1. ~={red}리소스의 무단 사용 방지=~
		2. 허가되지 않은 방법으로 해당 리소스 사용하는 것
		3. 승인된 사용자만 리소스를 사용하는 것
5. 기본사항
	1. 액세스 제어
		1. 네트워크 제어
		2. 호스트 제어: OS 레벨의 기능
		3. 물리 제어: 현실 세계의 관점
		4. 제한된 기능: 고위험 작업(금융 거래 등...)
	2. 리소스 접근은 파일/데이터 이외에도 다음 포함 가능
		1. 애플리케이션 자체,API 콜
		2. 메모리 영역,
		3. 어떻게 정의하느냐에 따라서 다르다
6. 접근제어 요구사항
	1. 직무 분리: 한사람이 모든 기능을 처리할 수 없도록,
	2. ~={red}최소 권한 원칙: ZT개념과 맞닿아 있음,특정 주제에 권한 할당해줄때 최소한의 권한만 부여=~(가장 중요)
	3. 알아야 할 사항
		1. 수정할 필요가 없는 경우 해당 주체는 쓰기 허가를 받아서는 안된다(r권한이 w권한보다 약하다,w는 삭제도 포함하기 때문에)
	4. 실패 안전 기본값: 실패,중단되더라도 서비스가 다운되지 않도록
	5. 완전한 중재: 주체가 객체에 접근할때 지속적으로 권한을 확인해야 한다(오버헤드가 발생하겠지만, 보안 정도에 따라서 필터링 해줘야 한다.)
7. 도식화
	1. 로그인 -> 인증 -> 시스템 리소스 접근 권한 확인(보안 관리자가 모디터링으로 인가 데이터를 통해서 접근 허용/부인할건지 결정)
	2. Auditing(감사):전반적인 행위를 모두 기록하고 관리하는 것
8. 접근 제어 단계
	1. 식별(누구인지)
		1. 본인이 누구인지 시스템에 밝힘(ID,이메일 주소 등..)
	2. 인증(식별한 사람인지 증명하는 것)
		1. 입증하는 것
		2. 인증에 사용 되는 도구들
			1. 알고있는 것:PW,PIN,보안 질문 등
			2. 가지고 있는 것: 토큰
			3. 당신 이라는 것: 목소리,지문 등
			4. 맥락적 단서: 위치,장치,시간 등
			5. 다중 인증 요소: 여러개의 유형을 결합하는 형태
			   ex) 로그인하면 핸드폰으로 구글 인증
9. 단계2
	1. 인가: 인증 후에 어느 권한이 있는지 
		1. 최소권한 원칙
	2. 감사: 무슨 일이 일어났는가?
		1. 로그인 시도 시점부터 인가 일어날때까지 모든 행위 로깅(기록)
10. 단계3
	1. 책임
		1. 혹시 보안 사고가 발생하면 감사 단계의 모든 로그들을 리뷰함
		2. 누가 했는지 등을 파악
11. 접근 제어 메커니즘 타입(ACM)
	1. Bob,Alice,Sam,Accouting program
12. Capbility List(주체가 기준)
	1. 권한을 row로 나타낸 것
13. Access Control list(객체가 기준)
	1. Column으로 나타낸것-~={red}실제에서 더 많이 쓰임=~
14. 모델 발전
	1. DAC
	2. MAC
	3. RBAC
	4. ABAC
	5. PBAC
	6. RAdAC
15. 발전1-DAC
	1. 임의 접근 제어
	2. 객체의 소유자가 나머지 주체들의 접근 권한을 컨트롤
	3. 유연성 보장-일관되지 않은 접근 제어로 이어질 가능성이 있음
16. 발전2-MAC
	1. 중간에 인가 검증하는 기관을 둠
	2. 주체가 객체에 접근하기 위해서 기관에 요청을 보내면 접근을 제어한다.
	3. DAC보다 높은 보안성
	4. 유연성이 낮다
17. 발전3-RBAC
	1. Role-Based Access Control: 역할기반 접근 제어
	2. 주체들에 역할(관리자,슈퍼바이져,직원 등)을 부여해서 역할 기반한 접근 권한 부여
	3. 개인이 아닌 role에 접근 권한을 부여한다
	4. role이 많아지면 복잡해짐
18. 발전3-RBAC 예제
	1. 주체가 해당 역할인지 확인하고 역할에 객체에 접근 권한이 있는지를 파악하여 최종적으로 주체에게 권한을 부여할지 결정한다.
	2. 주체 -> 역할 -> 역할의 권한 확인 -> 주체의 접근 여부 파악하여 제공
19. 발전4-ABAC
	1. 속성 기반 접근 제어
	2. 주체나 객체에 대해서 속성을 할당해준다
	3. 훨씬더 세밀하게 제어 가능 -> 오버헤드와 복잡성 증가
	4. ex) 속성: 30대,여자/30대 여자만 접근 가능한 객체가 있으면 30대 여자만 접근 가능
	5. ~={red}주체와 객체 모두에 속성을 할당해준다=~
20. 발전4-ABAC 예시
	1. 정책
		1. 타이틀 A or B,Prject R,위치가 한국이고 1시부터 5시까지 접근 가능한 정책을 만들 수 있다
		2. 매우 중요한 리소스 일때 이런 것이 좋을 수 있다. 
21. 발전5-PBAC
	1. 정책기반 접근 제어
	2. 속성,역할+a의 모든 것을 포함하여 정책을 결정한다.
	3. 복잡도와 충돌 발생 가능성 많음
	4. 클라우드에서 PBAC에서 많이 사용됨
22. 발전5-PBAC 예시
	1. 복잡한 다중 인증
	2. 객체 view,edit,delete,print등 모두 다르게 권한 부여함
23. 접근 제어,IDS(침입 탐지 시스템),안티 바이러스 비교
	1. 건전성(접근,부인 결정 할 수있는지)
		1. IDS는 확률적으로 진단한다. 확률이 높으면 관리자에게 알리는 방식
		2. IDS의 정확성이 100%가 되면 IPS(access control system)가 된다
	2. 완전성
		1. 접근제어: 이론적으로 특정 속성을 실행해야 한다
		2. 안티바이러스: 블랙리스트 방식으로 동작한다-엄격한 판단을 내니리기가 어려운 방식이다
24. 클라우스 시스템 안에서 접근 제어
	1. MAC,RBAC,PBAC,ABAC모두 클라우드 환경에서 차용하고 있다
25. ㄱㄷ
	1. 클라우드 환경에서 강화된 접근 제어가 필요한 이유?
		1. 어디에서든,언제든 접근 가능
		2. 분산 시스템
		3. 멀티 사용자가 동시에 사용
		4. 동적 스케일링
		5. 원격 제어
	2. 클라우드 전용 보안 강화
		1. 세분화된 권한: IAM 서비스가 대표적이다(AWS IAM,Azure AD,GCP IAM)
		2. 데이터 암호화
		3. 다중 인증 
		4. ABAC기반 정책: 다양한 정보를 기반으로 접근을 판단해야함
26. AWS IAM: 아이덴티티와 퍼미션
	1. 유저,그룹,역할,자격 증명 모두가 아이덴티티(검증이 일어나는 대상)
	2. 정책과 문장 기반으로 접근 제어 
	3. 최소권한 원칙을 적용할 수있도록 지원함(강제는 아니다)
27. Azure Entra ID
	1. 사용자 ID를 보호하고 애플리케이션 전반의 보안을 관리하는 클라우드 ID 및 액세스 관리 서비스
	2. 보안을 위해서 MFA,SSO를 지원하고 있다
28. Google cloud identity,IAM
	1. identity: 사용자 관리,접근 제어
	2. IAM: 권한 관리
29. thrid-party solution-okta
	1. 사용자 인증 및 애플리케이션 통합에 중점을 둔 전문 클라우드 ID 관리 플랫폼
	2. **API 기반 아키텍처**를 통해 작동하며 광범위한 타사 애플리케이션 연결을 통해 효율적인 SSO 기능을 제공합니다.
	3. okta 하나에 접속하면 연동되어있는 **모든 플랫폼을 SSO로 접근**하여 사용할 수 있게 해준다.-개별 서비스에 모든 ID와 PW를 기억하기 귀찮고 어렵기 때문에
30. thrid-party solution-one login
	1. SSO 지원
	2. **중앙 집중식 접근 제어**를 이용
	3. 포괄적인 감시 기능을 제공-로그를 **중앙 집중적으로 관리하기 때문에 보안 분석에 유리**하다
31. IAM
	1. IAM: Identity and Access Management
	2. **적절한 인력이 적절한 시기에 적절한 이유로 적절한 리소스에 접근할 수 있도록 설계된 정책,도구,기술 프레임워크**
	3. IAM은 시스템 및 애플리케이션 전반에서 사용자 ID, 역할 및 권한을 관리하여 보안을 강화합니다.
	4. 왜 필요?
		1. 데이터 침해 위험 감소
		2. 접근 제어 중앙화
		3. 업무 부담 감소
	5. 이점
		1. 사용자 경험 개선
		2. 효율성 향상
		3. 유연성 높아짐
		4. 비용 절감
32. IAM 기본 사항
	1. **누가,무엇을,언제,어디서,어떻게 모두를 정책에 정의 가능**
	2. 정의한 정책을 사용자,그룹,역할에 할당 할 수 있음
	3. 역할:특정 사용자가 아닌 모든 서비스들이 역할이 됨
33. 유저
	1. 클라우드 공급자 **기능을 사용**하는 실제 사람 또는 애플리케이션을 말합니다
	2. 사용자(사람)는 클라우드 공급자 서비스에 액세스할 수 있는 권한이 부여되며 앱이 서비스에 접근하는 방식을 관리한다
34. 그룹
	1. 동일한 권한을 사용하는 IAM 사용자 모음
	2. 그룹에 권한을 부여하면 개별 사용자에게 권한이 부여됨
	3. 그룹 자체를 겹칠수 없다
	4. 하나의 사용자는 여러 그룹에 포함될 수 있다
	5. 자동 정책이 상속된다.
35. IAM 구성요소: 정책
	1. JSON 형태로 구성
	2. 사용자, 그룹 및 역할에 대한 권한을 정의하고 각 AWS 리소스에서 수행할 수 있는 작업을 지정
36. IAM 구성요소: 정책 예제
	1. AWS IAM: 정책을 JSON으로 작성해서 identity(user,role,group)에 부착한다
	2. GCP IAM: 롤이 먼저있고 롤 바인딩을 통해 부착
	3. Azure Entra ID: 롤 정의-> 롤 할당 -> 적용
	4. 알리바바: AWS와 비슷함
37.  IAM 구성요소: 정책 유형
	1. ID기반 정책 
		1. 관리형 정책
			1. 기본 제공 정책:클라우드 제공자가 기본적으로 제공하는 정책
			2. 고객 관리형 정책: 사용자가 만드는 정책
		2. 인라인 정책: 단일 사용자,그룹,롤에 런타임에서 즉각적으로 추가되는 정책
38. ID기반 정책 예시-AWS
	1. 사전 구축 정책
	2. 이미 있는 정책을 할당만 해주면 된다.
39. ID기반 정책 예시-AWS
	1. 커스텀 관리 정책
	2. 사용자가 생성하고 지정한 정책
	3. 해당 계정에서만 사용할 수 있다.
40. ID기반 정책 예시-AWS
	1. 인라인 정책
		1. 1to1정책: 한 아이덴티티에 하나만 정책을 부여해줄 수 있다
		2. 실행 도중에 특정 유저한테 즉각적으로 부여하고, 추후에 부여했던 정책을 재 사용할 수 없어서 안전하다
41. ID 기반 정책-리소스 기반 정책
	1. 리소스에 적용되는 정책