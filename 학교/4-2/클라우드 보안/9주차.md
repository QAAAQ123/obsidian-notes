## Ch4. infrastructure security

1. 클라우드 인프라스트럭처 보안
    1. 조직이 클라우드 기반의 시스템,데이터에 무단으로 접근하거나 외부 위험으로 부터 보호
    2. 핵심 목표
        1. 클라우드에 호스팅된 데이터,앱,서비스가 위협 행위자로부터 안전하게 보장
        2. 승인된 사용자에게 항상 가용성 보장
        3. 물리적 보안 통제와 가상 보안 통제를 결합하여 보안
        4. 클라우드의 특수한 동적 위협과 잘못된 설정으로 인한 위협 보호
    3. 위 목표를 해결하기 위해서는 다층 보안이 필요함
        1. 유저 보안과 모니터링
        2. 정보 보안-데이터 계층
        3. 앱단 보안
        4. 플랫폼과 인프라스트럭쳐 보안
            1. paas나 os레벨의 보안,하이퍼바이져 보안 등
2. 흔히 발생하는 기반인프라 위험-1 
    1. 설정과 관리 위험
        1. 잘못된 설정
        2. 기본 세팅 그대로 설정
        3. 고아 리소스 구성 요소들이 보안 공백 발생시킬 수 있음
        4. 권한 creep(살금살금 상승): 시간이 지남에 따라서 권한 과도한 축척-제거해야하는 권한을 삭제시키지 않고 계속 권한을 쌓음
3. 위험-2
    1. 접근과 Identity(정체성) 위험
        1. 부적절한 iam 컨트롤: 부적절한 신원과 접근 관리
        2. 자격 노출: 자격이나 구성 파일이 하드코딩되어서 노출되는 것
            1. 예시: 실제 하드코딩된 패스워드가 드러난 예
        3. 약한 인증: 패스워드 기반의 접근만 사용하여 보안에 취약해 질 수 있음
        4. 서비스 계청 취약점: over-권한을 받은 계정
4. 위험 -3
    1. 네트워크와 소통 위험
        1. 보호되지 않는 API 사용-API가 공격자의 진입점이 될 수 있음
            1. 취약한 API식별해서 공격자가 보안이 약한 API 엔드포인트를 찾아내서 악성 스크립트를 주입하고 DB에 도달 → App이 악성이 포함된 데이터를 사용자에게 반환되어서 사용자 계층에서 공격자의 코드를 실행하게
        2. 네트워크로 인한 노출
        3. 적절한 암호화 없이 소통
        4. 환경간 네트워크 격리가 부족해지는 문제
5. 위험-4
    1. 가시성과 규정준수 위험
        1. 제한된 모니터링: 인프라 활동에 대한 가시성 부족
        2. 로깅이나 모니터링 능력 불완전→ 감시 및 추적 불안
        3. 규제 및 산업 표준을 충족하지 못함
        4. 관리되지 않는 리소스와 서비스
6. 흔히 발생하는클라우드 인프라스트럭쳐 공격-1
    1. 설정 기반 공격
        1. 잘못된 설정으로 인한 노출
        2. 권한 악용: 권한을 악용하여 중요한 리소스 무단 접근
        3. 리소스 하이재킹: 모니터링되지 않거나 고아 리소스를 악의적인 목적으로 침해
        4. 기본 보안 남용: 기본적으로 보안이 되지 않은 약한 보안 기본 세팅의 취약점 악용
7. 공격-2
    1. 신원 및 접근 기반의 공격    
        1. 크리덴셜 스터핑(Credential Stuffing):웹사이트나 서비스에서 유출된 사용자 계정(아이디와 비밀번호) 정보를 다른 웹사이트나 서비스에 대입해 무단 로그인을 시도하는 사이버 공격 기법
        2. API 토큰 손상: API키를 오용
        3. 서비스 계정 takeover: 자동화된 계정을 얻기 위해서 지속적으로 접근하는
        4. Sessoin 하이재킹: 인증 토큰이나 세션을 가로채서 공격     
        예시: outh 피싱 공격: 악성 로깅 피싱 이메일을 다운 받으면 패스워드 변경시에 ??????    
8. 공격-3
    1. 네트워크 기반 공격
        1. 측면 공격: 리소스간에 측면으로 이동하면서 확장하며 공격
        2. 침해된 네트워크 연결을 통해서 민감한 정보 공격
        3. 중간자 공격: 암호화 되지 않은 통신 가로채서 공격
        4. DNS 조작: 트래픽을 악성 주소로 리다이렉팅하는 공격
        중간자 공격: 정상적인 연결처럼 보이게 하면서 유출된 정보를 탈취하는 방법
        공격자가 피싱 메일 보냄→공격자가 구축한 서버로 연결→ 공격자가 정보(토큰)탈취→다중 인증을 통과하면 사용자는 정상화면처럼 보이게 한다.→공격자는 탈취한 세션을 사용해서 공격자 자신도 접근권한을 얻음
        DNS 공격: 악성 서버로 리다이렉팅 하는 경우
9. 공격-4 자원 남용 공격
    1. 크립토 마이닝: 클라우드 인스턴스 암호와 채굴 프로그램
    2. 디도스 앰플리피케이션: 다른 타겟에 대한 공격을 증폭시키기 위해 클라우드 리소스 악
    3. 스토리지 남용: 악성 데이터를 임시 보관하기 위해 침해된 스토리지 활용
    DDos 증폭 공격: 클라우드 리소스를 주로 활용/출발지를 위조하여 다수의 VM에게 영향을 미침
10. 클라우스 서비스 모델 보안-**보안 모델로 나눠서 살펴봄|누가 관리하는지에 초점을 맞춤**
    1. IaaS,PaaS,SaaS
    2. 오른쪽 그림: 서비스가 실제로 어떻게 배치되면서 어디서 보안 위협이 발생할 수 있는지
        1. 내부 공격자가 악의적인 VM 생성
        2. VM자체도 잠재적 위험
11. 클라우드 서비스별 보안 책임
    1. IaaS:고객이 많은 보안 책임
    2. PaaS: 코드 무결성 이나
    3. SaaS: 데이터 기밀성 관리
12. IaaS 책임,위협,완화
    1. 고객에 OS,앱,데이터,네트워크를 직접 관리
    2. 주요 보안 우려사항
        1. 클라우드 리소스를 대량의 트래픽으로 공격하여 서비스 중단시키는 경우
        2. 침해된 클라우드 인스턴스 문제: 가상머신이 본넷화 되어 공격에 사용된 경우
        3. 제한된 인프라 통제권: 기반 인프라 모니터링이 부족하고, 제공자에게만 보안을 의존해야하는 문제
13. IaaS 우려사항 2
    1. 보안 잘못 설정
    2. VM/컨테이너 탈출
14. IaaS 완화 전략
    1. 강한 접근 통제: RBAC,ZT등 적용
    2. 데이터 암호화: at rest(저장됨)와 in transit(이동중) 상태 모두에 암호화를 적용해야 한다.
    3. 정기적인 취약점 관리와 패치: 지속적인 업데이트
    4. 모니터링과 로깅
    5. DDos 보호: 디도스 공격 보호
15. PasS 책임,위협,완화 전략
    1. 고객은 app과 데이터만 책임짐
    2. 우려사항
        1. 앱 보안: 잘못된 API나 엔드포인트
        2. 데이터 보호 문제
        3. 플랫폼 설정 위험: 잘못 설정된 플랫폼과 미들웨어/로깅과 모니터링이 위협 탐지 못하는 문제
16. PaaS 우려사항 2
    1. 의존성과 공급망 위험
        1. 취약한 3자 라이브러리나 구성요소 사용하여서
    2. 멀티-태넌시 보안
        1. 서로다은 앱간에 격리가 부적절한 경우 발생
        2. 데이터 유출 문제도 발생 가능
17. PaaS완화 전략
    1. 역할기반접근제어와 강력한 접근 통제
    2. 데이터 암호화와 키 관리
    3. DevSecOps: 운영 통합-개발단계부터 보안고려하고, 자동화된 취약점 탐
    4. 정기적인 업데이트와 패치: 서드파티 등
    5. API 보안
18. SasS 책임,위협,완화 전략
    1. 고객은 데이터 사용과 접근만 책임진다
    2. 우려사항
        1. 신원관리및 접근 관리: 약한 사용자 인증이나 권한 통제/역할기반 이 부적절
        2. 데이터 통치(gorvernance)와 규정준수: 데이터 처리와 가시성이 제한되는 문제/요구사항 충족하기 여려울때
        3. 통합 보안 위협: 안전하지 않은 API
19. 우려사항-2
    1. 밴더락과 데이터 이동성: 데이터 내보내기와 통제권이 제한됨/밴더에 보안과 정책에 따라야함
    2. 그림자 IT와 무단사용:
20. SaaS 완화 전략
    1. 다중 인증: 강력한 IAM시스템 강화
    2. ZT 아키텍져 적용
    3. 자동화된 보안 모니터링
    4. 데이터 공유 거버넌스-반드시 검토 절차를 거치고 API가 규정 준수하는지 확인
    5. 정기적인 감사-사용자에게 지속적인 교육
21. 클라우드 인프라 계층 기반 보안-**계층적인 관점에서의 보안|무엇을 어떻게 보호할지**
    1. 데이터/앱/네트워크/호스트 총 4개의 계층으로 나눔
    2. Data
        1. 최상단 계층
        2. Data in transit과 Data at rest로 구성
    3. Application-이번장
        1. 하드웨어/소프트웨어
        2. Accounts: IAM과 접근
        3. 쿠버네티스:이번장 중점
    4. Network
    5. host: 이미 했음
22. ㄷ
23. 계정 관리와 아이덴티티 관리
	1. 공격 표면
		1. 환경 전반에서 다수의 계정이 걸처져있다
		2. API 토큰과 키 관리: 관리 복잡
		3. cross-service 접근: 하나의 계정이 여러개의 클라우드 리소스에 접근 하는 경우가 생긴다
		4. 자동화된 일처리: CI/CD나 자동화 툴로 서비스 계정을 관리함
	2. 취약점
		1. 권한이 있는 접근: 높은 권한을 가지고 있는 사용자 계정
		2. 기본 설정: 자동으로 설정되는 계정은 약한 인증을 요구하기 때문에
24. 취약점2
	1. 자격 증명 관리: 하드코딩된 자격 증명 파일
	2. 수명 주기 관리: 종료된 서비스에도 방치된 계정에서 보안 갭
	3. 계정 하이재킹: 인증되지 않은 접근을 하는데 사용
	4. 왼쪽: 정상
	5. 오른쪽 해킹: 악성스크립트가 포함된 페이지 반환한다
25. 계정 관리 모범 사례
	1. IAM 정책 적용
	2. 구성 모니터링: 보안이 취약한 요소 감지
	3. 활동 모니터링: 사용패턴 추적
	4. 정기 감사: 주기적으로 사용하지 않는 계정 정리 및 권한 검토
26. 네트워크 보안
	1. 공격 표면
			1. 퍼블릭 네트워크 연결: 퍼플릭으로 서비스할때 엔드포인트
			2. 가상 네트워크 바운더리
			3. 서비스간 통신: 컴포넌트 간의 트래픽
			4. 보안 그룹 종속성: 컴퓨팅 리소스에 연결된 계정이 적절하게 관리되지 않을때 문제가 생길 수 있음
	2. 취약점
		1. 잘못 구성된 보안 그룹
		2. ACL 우회: 보안 구멍
		3. 측면 이동: 미세 분할이 부족해서 공격을 전파시킴
		4. 구성 드리프트: 보안 기준선에서 벗어난 정책을 사용할 때
27. 네트워크 보안 모범 사례
	1. 심층 방어: 다중 보안 계층 마련
	2. 네트워크 세분화: 마이크로 네트워크와 ZT
	3. 자동 모니터링
	4. 트래픽 분석: 이상 탐지와 위협 대응을 위한 지속적 모니터링
28. 서버 보안
	1. 공격 표면
		1. 공개 네트워크 노출: 제어 없이 인터넷에 접근가능한 서버
		2. 암호화되지 않은 통신: 보안이 없는 프로토콜을 이용한 통신
		3. 비밀번호 기반 인증: 무차별한 대입공격 및 자격 증명 도용에 취약
		4. 과도한 권한 접근: 루트 사용자 및 과도한 권한 사용자
29. 서버 보안 핵심 취약점
	1. 네트워크 구성 격차: 부적절한 인,아웃바운드 트래픽 제어
	2. 프로토콜 보안 취약점: 보안이 없는 프로토콜 사용
	3. 접근 제어 실패: 취약한 인증 매커니즘 및 권한 상승 위협
	4. 패치 관리 지연: 보안 업데이터를 지연하면 공격 가능한 시간이 늘어남
	5. 그림: 서로 다른 사람이 다른 이유로 구성을 변경하면 구성 기준이 무너진다
30. 서버 보안 모범 사례
	1. 네트워크 분할: 필요한 네트워크에만 제어
	2. 암호화된 통신: 모든 전송에 암호화
	3. SSH 키 인증: 비밀번호를 키 암호화로 대체
	4. 권한 최소화: 최소 권한 접근을 구현한다
31. K8S보안
	1. 공격 표면
		1. API서버 노출:여러 엔드포인트에서 접근 가능한 표면이 있음
		2. 컨테이너 런타임 취약성: 클러스터 노드 이미지와 런타임 보안 문제
		3. 서비스 메시 통신: Pod간의 통신
		4. 다중 계층 종속성: 코드,컨테이너,클러스터,클라우드가 복잡하게 얽혀있음
		5. 그림은 쿠버네티스 공격 표면들이다
32. k8s 주요 취약점**~={red}(RBAC-역할기반 접근제어/권한을 역할에 따라서 부여)=~**
	1. 클러스터 구성 오류: 불안전 API서버 및 ectd 구성
	2. RBAC 오류: 권한 과도하게 부여
	3. 네트워크 정책 격차: Pod간에 제한없는 통신을 악용한 취약점
	4. 런타임 보안: 악의적으로 컨테이너 활동 및 권한 상승
	5. 그림: RBAC이 제대로 생성되지 않았거나 어떤 지점에서 공격이 발생할수 있는지 다이어그램
		1. 중요한 서비스에 대한 접근: RBAC이 제대로 안되있는 경우
		2. 노드 자체 접근: RBAC 잘못/master노드에 직접 접근 가능
		3. k8s 서버나 프록시를 통한 무단 접근
		4. ECTD(데이터 저장 컴포넌트)에 접근 가능: RBAC이 약해지면 중요 데이터인 ectd에 접근 가능
		5. 가로채기/수정/주입 컨트롤 플레인: 컨트롤 플레인간 통신할때 가로채기,변조,악성 명령 주입
		6. 컨테이너에서 호스트로 탈출하는 공격: RBAC으로 막을수 없고 권한이 높을 수록 위험함
		7. 앱단의 트래픽 조작하는 공격
		8. 앱 코드 자체의 취약점을 악용
		9. 결론: RBAC이 무너지면 클러스터의 모든 부분이 공격 지점이 될 수 있다(RBAC이 첫번째 방어선 같은 느낌)
33. k8s 보안 모범 사례
	1. 4C 보안 강화
	2. RBAC: 역할을 더 세분화 해야 한다
	3. 네트워크 정책: Pod 커뮤니케이션을 제어하고 서비스 매쉬 보안 구현
	4. 지속적인 규정 준수
34. 쿠버네티스
	1. 컨테이너: 앱 실행에 필요한 모든것(구성,코드,런타임,환경,라이브러리)을 포함하고 있는 패키지
		1. 프로세스 레벨의 격리 환경 제공
		2. 라이브러리와 런타임 실행을 위해 공유된 호스트 커널을 사용
		3. VM에 비해서 작은 사이즈,성능 우수
35. 비교
	1. 컨테이너: 가상화가 필요없음,격리 메커니즘이 없어서 문제 발생이 쉬움
36. 도커: 앱을 패키징해서 일관된 배포를 제공하는 플랫폼
	1. 오른쪽 도커 워크 플로우: 빌드를 해서 컨테이너 만듦->푸시해서 레지스트리에 저장 -> 다른 호스트에서 pull해서 도커 엔진으로 실행해서 똑같은 환경에서 실행 할 수있다.
37. 도커 아키텍쳐★★★★★★★★★★★★★★★★★★★★
	1. 도커 클라이언트: 도커 Deamon과 상호작용하기 위한 인터페이스(CLI)
	2. 도커 데몬(dockerd):컨테이너,이미지,네트워크,볼륨을 관리하고 API 요청 처리
	3. gRPC를 통해 컨테이너d로 연결
	4. 컨테이너d
		1. 높은 레벨에 있는 컨테이너 런타임이고 컨테이너 슈퍼바이져
		2. 컨테이너 생명주기 관리
		3. 시스템 콜을 통해서 shim으로 연결
	5. shim: OCI 규정을 준수하는 프로세스 감독자(데몬이 죽은 후에도 컨테이너가 계속 실행되도록 하는 것)
	6. runc: 저수준 컨테이너 런타임(커널 기본 요소에 대한 인터페이스)
	7. 실행중인 컨테이너: cgroup,네트워크,네임스페이스 등
	8. ~={red}**도커 상위 레벨: 사용자 인터페이스와 관리 기능 담당**=~
	9. ~={red}**도커 하위 레벨: 실제 컨테이너 실행과 격리 매커니즘 담당**=~
38. 컨테이너 런타임
	1. 다양한 컨테이너 런타임
	2. 컨테이너d: CNCF 산하의 프로젝트,대부분의 k8s 배포판의 기본 값
	3. cri-o: k8s 전용 경량 런타임
	4. runc: 저수준 oci 표준 런타임,containerd와 docker의 핵심 엔진
	5. docker engine: 고수준 런타임,개발자 친화적이지만 containerd에 의존하는 경향이 있음
39. 컨테이너 런타임의 진화과정
	1. 전반적으로 버전이 높아지면서 간결해짐
40. 컨테이너 레지스트리
	1. 컨테이너 이미지를 위한 저장 및 배포 시스템
	2. 이미지는 공개or 비공개로 저장되어 쉽게 접근 가능
	3. 컨테이너 레지스트리 사용 이유: 이미지 저장소 위치에 대한 제어 유지,개발 워크플로우와 원할하게 통합
	4. 정형화된 레지스트리: 도커 허브,하버 등
41. 컨테이너 격리: k8s에서 보안 구성의 핵심 요소
	1. 네임스페이스: 시스템 리소스 격리
	2. 기능 및 보안: 시스템 콜 제한
	3. Cgroups: 컨테이너의 리소스 제한
	4. AppArmor/SELinux: 파일 접근을 엄격하게 제한
42. ~={red}Mount namespace: 파일 시스템 뷰를 호스트나 다른 컨테이너에서 분리=~
	1. pivot_root 시스템 콜(중요): 루트 파일 시스템 전환/ chroot(2)보다 안전
		1. 컨테이너는 자신만의 루트를 가지게 됨
	2. mount namespace자체 만으로는 host시스템 파일을 보호하지 못한다.-> 추가적인 보안 매커니즘이 필요
43. ~={red}PID namespace: 호스트 프로세스를 컨테이너로 부터 숨기고,컨테이너의 시스템 뷰를 격리시킨다.=~
	1. PID namespace 안에
		1. nginx가 PID가 1로 보임
		2. sshd,dockerd,containerd,containd-shim은 컨테이너 환경에서는 안보임 -> 컨테이너 안의 앱이 호스트 프로세스와 상호작용 하는것을 막음
44. ~={red}network namespace: 컨테이너가 고유한 IP주소 가지고 같은 호스트에 있는 컨테이너는 브릿지를 통해 통신할 수 있도록 하며 컨테이너 포트를 인터넷에 노출 시킬수 있음(iptables사용)=~
	1. 호스트의 실제 네트워크 인터페이스
	2. 브릿지의 도커 인터페이스가 ip를 가지고 있다
	3. 브릿지를 통해서 컨테이너간 통신을 한다
	4. 각 컨테이너는 veth(버츄얼 이더넷) pair를 통해 연결된다
	5. veth pair는 한쪽은 브릿지에 한쪽은 컨테이너에 연결되어 있다
	6. 네트워크 들어오면 iptables가 적절하게 라우팅 해줌
	7. **중요한 점: 네트워크 인터페이스는 추상적인 Unix소켓을 격리한다**
	8. ~={red}network namespace: 각 컨테이너가 독립적인 네트워크 환경을 가질 수 있게 해준다=~
45. **멀티 호스트 환경에서의 network namespace**
	1. 컨테이너들은 각 가상 인터페이스 pair를 통해 호스트와 연결됨
	2. VXLAN과 같은 기술을 통해서 여러 호스트간의 network namespace를 통합 할 수 있다
	3. 각 컨테이너는 network namespace를 통해 통신하고 컨테이너간의 통신은 도커 브릿지를 통해서 통신한다 docker bridge는 또 host network의 이더넷과 통신한다
	4. ~={red}결론: 여러개의 host에 분산된 컨테이너도 하나의 네트워크처럼 동작을 할 수 있다=~
46. 컨테이너 네트워크에서의 브릿지의 역할
	1. 데이터 링크 계층의 기기
	2. 네트워크를 세그먼트로 나눔
	3. 세그먼트: 작은 단위로 나눈 네트워크
	4. 브릿지: 네트워크 트래픽간의 세그먼트 전달
	5. 세그먼트간 프레임을 필터링 할 수 있다
	6. 브릿지가 세그먼트1,2를 연결하고 있음
	7. 각 세그먼트 안에는 여러개의 디바이스가 연결되어 있음
	8. 세그먼트1의 기기와 세그먼트2의 기기가 통신하려면 반드시 브릿지를 거쳐야 한다.
	9. 필요한 트래픽만 다른 세그먼트로 전달/불필요한 트래픽 차단
47. 컨테이너 네트워크-브릿지 모드: 도커의 기본 네트워킹 방식
	1. 컨테이너1과 2는 기본 브릿지에 있고 모든 브릿지는 최종적으로 이더넷 인터페이를 통해서 외부와 연결된다.
	2. 커스텀 브릿지를 만들면 별도의 네트워크 구성 가능
48. 컨테이너 네트워크-호스트 모드
	1. 호스트가 네트워크 네임스페이스를 그대로 공유하는 방식
	2. 네트워크 네임스페이스를 격리하지 않음
	3. 컨네이너별로 ip주소도 할당하지 않기 때문에 **~={red}host의 네트워크 환경을 그대로 사용=~**한다
	4. 여러 컨테이너가 같은 포트를 사용할 수 없다는게 문제-잘못 설정하면 **포트 충돌 발생 가능성**
	5. network namespace를 분리하지 않기 때문에 network overhead가 발생하지 않는다-> 성능 향상 장점