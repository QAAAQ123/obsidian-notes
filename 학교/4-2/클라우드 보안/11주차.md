2. IT 운영의 최대 과제
	1. 장애
	2. 성능 저하
	3. 변경 지연: 기능이 추가되어서 업데이트 될 때 다운 타임 발생
	4. 1,2,3 대응
	5. +보안,규제-최소한으로만 하고 싶어함
3. 장애
	1. 장애에서 자유로운 것은 없음(피할 수 없음)
	2. 대응 전략을 잘 정립해둬서 피해를 최소화하는게 중요
	3. 장애 요인 분석/제거 -> 복잡도로 인한 문제가 남아있음
	4. 자원 소요 분석/확충 -> 복잡도문제 그대로 승계
4. 성능
	1. 성능저하->DB 관점에서는 확충
	2. 클라우드에서는 스케일 아웃(리소스 확장)
	3. but, 복잡성 증가
5. 변경 지연: 서비스 변경에서 오는 지연
	1. 복잡도 증가
6. 복잡도
	1. 핵심: 복잡도
	2. 활동이 활발할 수록 시스템 복잡도 증가
	3. 복잡도 증가 -> 장애,성능 저하,변경 지연의 확률 높아짐
	4. 결론: 시스템 구조 관점에서 낮은 복잡도를 유지하도록 설계하는 것이 해답
7. 복잡도
	1. 일반적인 조직의 시스템은 매우 복잡
	2. 서비스 하나를 컨테이너 하나에 담아서 하는 경우 한 줄을 변경하면 전체를 다시 배포하는 경우 발생
8. 구조적 대응
	1. 조직이 거대하게 구조를 디자인 하면 대응 자체가 힘들다 인력/자원 소모가 크다
9. 구조적 대응 eBay
	1. 건수가 기하급수적으로 상승함에 따라, 아키텍처를 지속적으로 개선
	2. 구조,DBMS,프로그래밍 자체도 과감하게 변경했다
10. 모델링 기술 흐름
	1. 모든 컴포넌트를 하나에 담아서 서비스
	2. OOAD->CBD->SOA->MSA
		1. SOA(service orinted articture): 컴포넌트 인터페이스 위에 서비스 인터페이스 추가/컨테이너 복잡도,원격 통신 문제
		2. MSA(Micro service articture): 컴포넌트 간에 통신이 RESTful 통신을 하게 변경(독립성 확보)
11. 현실
	1. 컴포넌트를 쪼개서 서비스 하더라도 의존성이 생겨서 관리 자체가 어렵다
12. MSA1-WAS 단점
	1. WAS 단점들
		1. Scale-out 어려움
		2. 실질적으로 컴포넌트 안에 복잡도가 높은 일체식으로 되어있다
		3. 등...
13. MSA2-MSA 장점
	1. WAS 단점 해결하고자 MSA 나옴
	2. 서비스 기반으로 쪼갠다음 서비스 사이에서도 별도의 통신 계층을 추가해서 **의존성을 최대한 낮추었다**
	3. DB자체도 서비스별로 구축한다음 통신하게 되어있다.
	4. 서비스 별 Scale-out
14. 발전 과정
	1. 무늬만 컴포넌트 -> 실제로 잘 설계한 컴포넌트(DB 공유 문제) -> 마이크로 서비스 구조(웹 컨테이너와 서비스 계층 분리하여 RESTful 인터페이스로 통신)
15. 모놀리식 아키텍쳐 VS MSA
16. 모놀리식 아키텍쳐 VS MSA-그림
	1. 모든 컴포넌트가 하나에서 돌아감
	2. MSA: 모든 서비스를 쪼개서 API 게이트웨이를 두고 서비스마다 별도의 DB구축해서 의존성을 낮추었다. 
17. MSA 예시-넷플릭스
	1. Big Java,Big Oracle
	2. DB Corruption이 일어났더니 서비스가 중단되어 손실이 커짐
18. 넷플릭스 예시2
	1. 2008년부터 15년까지 7년동안 MSA로 전환
19. 넷플릭스 MSA 그래프
20. MSA 예시2-아마존
	1. 블록 하나 하나가 모두 하나의 서비스이다
21. MSA 주요 특성
	1. 단일 역할만 담당
	2. 자신의 데이터 저장소에 대한 ownership가지고 있다
	3. 일련의 메시지와 동작을 자율적으로 구성하고 책임
22. MSA 통신 흐름
	1. 유저 입장에서는 Oders service 요청함
		1. oders service는 DB에 저장
		2. 다른 트랜잭션 서비스 호출 -> 트랜잭션 DB에 저장
		3. 서비스 호출 -> DB에서 할 일 함
23. 기본 속성
	1. 각 서비스 독립 배포 가능
	2. 서비스 교체 가능
24. 핵심 원칙
	1. 자율성(Autonomy)
		1. 독립적 변경,운영
		2. 느슨한 결합
		3. 독립적으로 배포 가능
25. 느슨하게 결합된 서비스
	1. 느슨한게 가능한 이유: 서비스간 Contract를 선언하고 지키기 때문에
	2. 규칙만 지키면 상대방이 어떻게 변경되던지 상관하지 않음
26. 핵심원칙2
	1. 회복성
		1. 장애가 났을때 격리 시켜줌
		2. 수정해서 다시 업로드해주면서 회복 가능
	2. 투명성
		1. 언제,어떻게 장애가 발생했는지 로그 정보 띄움
27. 핵심원칙3
	1. 자동화
		1. 개발이 복잡함 -> 자동화 필수
	2. 동기화(개발자와 실제 운영자 사이의 생각 일치)
		1. 개발팀의 노력을 올바른 방향으로 동기화 하는 것이 매우 중요
28. SOA VS MSA
	1. SOA: 수직적 분해(가시층,비즈니스 층,데이터 층 등..)
	2. MSA: 수평적 분해(서로 다른 서비스는 독립적)
29. MSA를 선택해야 하는 이유
	1. 기술의 혼재성이 커지면 마이크로서비스 아키텍쳐가 더 대응을 잘 한다
	2. 개발의 마찰 감소
	3. 마찰과 위험을 줄여줌
	4. 설계할 때는 어렵지만, 구축을 해놓으면 이후에 수정해야할게 적을 수 있다
30. 문제점
	1. 아키텍쳐에 대한 이해(도메인 사전 지식이 필요)
	2. 서비스간의 경계와 계약을 식별하기 어렵고, 한번 정한후에 수정이 어려움
	3. 등...
31. 설계 상의 어려움
32. 범위 정의의 어려움
	1. 마이크로 서비스는 각각 단일 역량을 가진다.
	2. 어디까지를 하나로 볼것인지를 합의해야함
33. 마이크로서비스 범위
	1. 부정확한 서비스 범위 결정으로 인해 서비스 경계가 복잡해짐 -> 리팩터링 비용이 상승함
34. 서비스간 계약 유지
	1. 계약을 노출해야 한다
	2. 좋은 계약이란?
		1. 완전성
		2. 충분성
		3. 예측성
35. 마이크로서비스 = 분산 시스템
	1. 마이크로서비스 자체가 분산 시스템과 비슷하다
36. 운영상의 도전 과제들
	1. ㄷ
37. 도전 과제-장애 가능성
	1. 네트워크/라우터 장애 자체(모든 아키텍쳐의 문제)
	2. 과부하
	3. 하드웨어 장애
	4. 하위 의존성 장애
38. 정리-서비스의 자율적 구성
	1. 자율적으로 아키텍쳐를 구성할 수 있다
39. 방법1-event driven articture로 구성한 예시
	1. event queue를 만들어서 이벤트 기반으로 동작
40. 방법2-서비스의 외부 노출
	1. 서비스를 외부에서 사용하게끔도 가능하다
	2. API gateway를 통해서 하는게 더 좋다
41. 분산 시스템의 개념
	1. 이벤트,API gateway,load balancing까지 끼워넣어서 분산함