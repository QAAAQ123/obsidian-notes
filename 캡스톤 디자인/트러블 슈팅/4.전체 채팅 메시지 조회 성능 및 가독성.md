- 문제
	- 한 사용자의 전체 채팅 기록에서 키워드를 포함한 메시지를 검색하는 로직 작성 중
- 고민  
	- @Query로 키워드있는 메시지만 DB에서 꺼내올지 
	- 해당하는 chat session을 전부 꺼내서 키워드를 포함하는 메시지만 꺼낼지
- 해결
	- 몇 만건 이하의 메시지 내역에서는 2의 방법에도 성능에 크게 문제가 있지 않고
	- 나중에 내역이 많아지만 MongoTemplate로 변경
	- @Query는 가독성이 좋지 않아서 포기
---
### **📝 트러블 슈팅: NoSQL 문서 구조에서의 검색 효율성과 가독성 간의 트레이드오프(Trade-off)**

#### **1. 배경 및 문제 (Problem)**

- **현상:** MongoDB의 Document 내 `messages` 배열(Array)에 저장된 채팅 기록 중, 특정 키워드가 포함된 메시지만 검색해야 하는 요구사항 발생.
    
- **문제점:** RDB와 달리 NoSQL(MongoDB)의 배열 내부 요소를 필터링하여 반환하려면 단순 `find`가 아닌 복잡한 프로젝션(Projection)이나 집계(Aggregation) 연산이 필요함.
    

#### **2. 고민 및 접근 (Consideration)**

- **DB 레벨 필터링 (`@Query`):**
    
    - 장점: 필요한 데이터만 네트워크로 전송하므로 I/O 효율이 좋음.
        
    - 단점: `@Query` 내부에 `$filter`, `$project` 등 복잡한 JSON 연산자를 문자열로 작성해야 하여 **가독성이 떨어지고 문법 오류 발생 가능성**이 높음.
        
- **애플리케이션 레벨 필터링 (Java Stream):**
    
    - 장점: Java의 `Stream API`를 사용하여 비즈니스 로직이 직관적이며 유지보수가 쉬움.
        
    - 단점: 해당 세션의 전체 메시지를 메모리에 로드해야 하므로, 데이터 양이 수십만 건 이상일 경우 **메모리 오버헤드(Memory Overhead)** 우려.
        

#### **3. 해결 및 결과 (Solution & Result)**

- **가독성 우선 선택 (Readability First):** 현재 서비스 규모(세션당 수만 건 이하)에서는 애플리케이션 레벨 필터링의 성능 저하가 미미하다고 판단하여, **Java Stream 방식**을 채택.
    
- **단계적 개선 전략 (Iterative Improvement):** 향후 데이터 규모가 커져 성능 병목(Bottleneck)이 발생할 경우, 가독성이 나쁜 `@Query` 대신 타입 안전성(Type-safety)과 동적 쿼리 구성이 가능한 **`MongoTemplate`(Aggregation)**으로 리팩토링하기로 기술 부채를 정의함.
    
- **성과:** 복잡한 쿼리 작성 시간을 단축하여 **개발 생산성(Productivity)**을 높였으며, 명확한 코드로 팀원 간의 로직 이해도를 향상시킴.