## 문제
- Access Token만료시 프론트에서 API 요청을 보내면 자동으로 새로운 Access,Refresh Token을 발급해주어야 한다.
- API 요청할때 이미 만료된 Access Token이 있기 때문에 ExpiredJwtException이 발생한다.

## 해결
- Security filter chain에 끼워넣은 JWTFilter에는 Token없음과 Bearer로 시작하는지만 검사하게 되어있었다
- JWTFilter에 try-cath문으로 ExpiredJwtException를 잡아서 해결
- `try{....} catch(ExpiredJwtException e){....}`
- 토큰이 만료되지 않았을 때에만 MemberDto및 객체 생성,등록할 수 있게 변경

## 진행 흐름
1. 프론트에서 API 요청 보냄(Access Token 만료)
2. 만료된 Access Token을 JWT Filter의 try-catch문이 잡아내서 AuthenticationEntryPoint로보냄
3. AuthenticationEntryPoint는 401을 프론트로 보냄
4. 프론트에서 401을 받으면 /auth/refresh로 api요청을 보냄
5. 서버는 Access,Refresh Token을 재발급하여 전송함
6. 프론트에서 다시 Token들을 저장하고 API요청을 완료함(Access Token 재발급 완료)

```java
try {
//1. 만료 여부 먼저 확인
if (jwtUtil.isExpired(token)) {
throw new ExpiredJwtException(null, null, "만료된 토큰");
}

//2. 토큰이 유효할 때만 정보 추출
String email = jwtUtil.getEmail(token);
String role = jwtUtil.getRole(token);
//3. Member Dto 생성
MemberDto memberDto = new MemberDto();
memberDto.setEmail(email);
memberDto.setRole(role);
memberDto.setName("User");

//4. 인증 객체 생성 및 저장
// 4.1 UserDetails에 담아 Authentication 생성
CustomOAuth2User customOAuth2User = new CustomOAuth2User(memberDto);
Authentication authToken = new UsernamePasswordAuthenticationToken(customOAuth2User, null, customOAuth2User.getAuthorities());
// 4.2 세션에 사용자 등록
SecurityContextHolder.getContext().setAuthentication(authToken);

} catch(ExpiredJwtException e){
log.info("JWT Filter - 토큰 만료 감지: {}", e.getMessage());
request.setAttribute("exception", "TOKEN_EXPIRED");

}catch (Exception e){
log.info("JWT Filter - 유효하지 않은 토큰: {}" ,e.getMessage());
request.setAttribute("exception", "INVALID_TOKEN");
}
```
---
## AI 답변
#### 1. 문제 (Problem)
- **Before:** "ExpiredJwtException이 발생한다."
- **After:** "ExpiredJwtException이 발생했을 때 **이를 적절히 처리하지 못해 500 에러(서버 내부 오류)가 반환**되었고, 이로 인해 프론트엔드의 **Interceptor(재발급 로직)가 401 상태 코드를 감지하지 못해** 토큰 갱신이 불가능했다."
    - _이유:_ 예외 발생 자체는 문제가 아닙니다. 그 예외가 **500 에러로 둔갑**한 게 진짜 문제입니다.

#### 2. 해결 (Solution)
- **Before:** "try-catch문으로 잡아서 해결"
- **After:** "JWTFilter 내 로직을 `try-catch`로 감싸 예외를 포착하고, `request.setAttribute`로 예외 유형을 저장한 뒤 **`chain.doFilter`로 다음 필터에 넘겼다.** 이후 **`AuthenticationEntryPoint`에서 해당 속성 값을 확인하여 올바른 401 응답(JSON)을 내려주도록** 개선했다."
    - _이유:_ `try-catch`만 한 게 아니라, **EntryPoint로 책임을 넘긴 것**이 핵심 기술입니다

**수정 제안 (진행 흐름 상세화):**
1. 프론트엔드: 만료된 Access Token으로 API 요청 시도.
2. **JWT Filter:** `ExpiredJwtException`을 포착(Catch)하고, `request` 속성에 "TOKEN_EXPIRED" 기록 후 필터 체인 통과.
3. **AuthenticationEntryPoint:** 인증 실패를 감지하고, 속성 값을 확인하여 **401 Unauthorized (Code: TOKEN_EXPIRED)** 응답 반환.
4. 프론트엔드(Interceptor): 401 응답 감지 후 `/auth/refresh`로 토큰 재발급 요청 (Cookie 사용).
5. 서버: Refresh Token 검증 후 새로운 Access Token 발급 (**200 OK**).
6. 프론트엔드: 재발급된 토큰으로 원래 하려던 API 재요청 (**200 OK**).