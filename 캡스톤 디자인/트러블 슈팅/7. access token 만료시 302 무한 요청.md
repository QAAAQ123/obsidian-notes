#accessToken
## 문제
- 프론트와 API 연동 테스트 중 accessToken가 만료되면 프론트 side에서 302(/login)요청이 무한으로 들어오는 상황 발생

## 문제 원인
- js기반의 React에서는 fetch나 Axious로 302는 처리할 수 없어서 accessToken이 재발급되기 전까지 무한으로 302(/login)요청을 보냄
- 이로 인해 ngrok의 한달 사용량인 20k를 넘어버림

## 문제 해결
- 백엔드에서 security filter chain에서 accessToken이 만료되어 오는 302 요청을 401로 바꿔서 프론트엔드로 전달
- 프론트에서는 401응답이 오면 token 재발급 api인 /api/refresh 요청을 백그라운드로 보내서 accessToken을 다시 받아옴
	- accessToken을 재발급 받은 상태에서 다시 api요청하여 정상 응답을 받도록 함

## 요약
- js는 302요청을 처리하지 못하고 401를 처리 할 수 있음
- 백엔드에서 302 요청이 들어오면 401로 변경해서 응답해야함
- 프론트에서 401응답이 오면 백그라운드에서 토큰 재발급을 해줘야함

----
## AI 답변
### 1. 문제 원인 (상세 보완)

- **브라우저의 강제성:** `Axios`나 `Fetch` 같은 JS 라이브러리의 문제가 아니라, **브라우저의 기본 동작** 때문입니다. 브라우저는 302 응답을 받으면 프론트엔드 코드(JS)에게 알리지 않고 **자동으로** 해당 `Location`(/login)으로 이동해버립니다.
    
- **결과:** 프론트엔드 코드는 302 상태 코드를 보는 게 아니라, 리다이렉트 끝에 도착한 **로그인 페이지의 HTML(200 OK)**을 응답으로 받게 됩니다.
    
- **오류 발생:** JSON 데이터를 기대했던 코드가 HTML을 받으면서 파싱 에러가 나거나, 에러 처리가 꼬여서 재요청을 반복(무한 루프)하게 됩니다.
    

### 2. 문제 해결 (백엔드)

- **정확한 표현:** "302 요청을 401로 바꾼다"기보다는, **"인증 예외 발생 시 스프링 시큐리티가 수행하던 기본 동작(로그인 페이지로 리다이렉트/302)을 가로막고, 대신 401 에러를 내려주도록 `AuthenticationEntryPoint`를 재정의했다"**가 더 정확한 표현입니다.
    

### 3. 문제 해결 (프론트엔드)

- **Silent Refresh:** 401을 받으면 사용자에게 티 내지 않고 백그라운드에서 `/refresh`를 수행한다는 점이 핵심입니다.
    
- **Retry:** 재발급 성공 후 **"실패했던 원래 요청을 다시 수행한다"**는 점까지 포함되어야 완벽한 해결입니다.
    

---

### ✅ 최종 수정 제안 (문서화용)

## 요약

- **문제:** 브라우저(JS)는 보안상 302 리다이렉트를 자동으로 따라가기 때문에, API 요청 시 토큰이 만료되면 401 에러를 잡을 수 없고 HTML 응답을 받게 됨.
    
- **Backend:** 인증 실패 시 302 리다이렉트 대신 명확한 **401 Unauthorized (JSON)** 응답을 보내도록 `AuthenticationEntryPoint` 적용.
    
- **Frontend:** Axios Interceptor를 통해 401 응답을 감지하면, 백그라운드에서 토큰을 재발급(`/refresh`)받고 원래 요청을 재시도(Retry)함.