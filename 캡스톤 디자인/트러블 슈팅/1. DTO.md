- 문제: 각 Controller에 맞는 DTO를 하나씩 만들다 보니 DTO디렉터리를 관리하기 어려운 상황 발생
- 고민: 클래스 하나마다 하나의 dto를 만들지, 공통분모를 만들어서 안에서 inner class로 해결할지 고민
- 해결
	- 도메인(chatSession,chat)당 하나의 공통 Class를 만들고, 그 안에 Inner class로 해결
	- java 16에서 가능한 record를 이용하고, DTO.from()메서드 명명 규칙을 적용해 일관화한 형식으로 해결
---
### **📝 트러블 슈팅: DTO 파편화 문제 해결 및 구조 개선**

#### **1. 배경 및 문제 (Problem)**

- **현상:** 각 API(Controller)의 요청/응답 스펙에 맞춰 개별 DTO 클래스를 생성하다 보니, 프로젝트 내 DTO 파일 개수가 급격히 증가함.
    
- **문제점:** `MemberUpdateDto`, `MemberResponseDto`, `MemberDetailDto` 등 파일이 너무 많아져 디렉토리 탐색이 어렵고, 도메인별 응집도(Cohesion)가 떨어져 유지보수 효율이 저하됨.
    

#### **2. 고민 및 접근 (Consideration)**

- **패키지 구조화 vs 단일 파일 관리:** 단순히 패키지로 묶을 것인가, 아니면 관련된 DTO를 하나의 클래스 안에 모을 것인가를 비교.
    
- **Inner Class 전략:** Java의 `Inner Class` (또는 `static nested class`)를 활용하면 연관된 DTO를 한눈에 파악할 수 있다는 장점에 주목.
    

#### **3. 해결 및 결과 (Solution & Result)**

- **Inner Record 패턴 도입:** Java 16의 `record`를 활용하여 불변성(Immutability)을 보장하고 보일러플레이트 코드를 제거함.
    
- **도메인 중심 응집:** `ChatSessionDTO`라는 부모 클래스 안에 `Create`, `Response`, `Detail` 등을 `static record`로 선언하여 도메인 단위로 관리.
    
- **팩토리 메서드 통일:** 생성자가 아닌 `static from()` 메서드를 통해 Entity → DTO 변환 로직을 캡슐화하고 일관성 확보.
    
- **성과:** DTO 파일 개수를 획기적으로 줄이고(File Explosion 해결), 도메인별 API 명세를 한 파일에서 직관적으로 파악 가능해짐.