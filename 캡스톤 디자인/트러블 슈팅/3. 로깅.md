- 문제: `log.info("'{}' MyInfo 내 정보 수정을 위한 닉네임 검사 요청: {}",email,nickname);`와 같은 로깅 방법을 사용하고 있었는데, 코드를 작성하다보니 나중에 입력 요청 한개마다 1개 이상의 info 로그가 나온다면 로그 기록이 너무 많아질 것 같다는 생각
- 고민: 로깅 레벨을 다르게 해야하는데, 어떤 기준으로 나눠야 할지와 어떤 로깅 레벨이 있는지 몰라서 배워야하는 상황
- 해결: AI로 로깅 레벨이 있는지와 어떤 기준으로 나눠야 하는지 공부함
---
### **📝 트러블 슈팅: 로그 폭주 방지 및 운영 효율을 위한 로깅 전략 수립**

#### **1. 배경 및 문제 (Problem)**

- **현상:** 개발 초기 단계에서 디버깅을 위해 모든 요청(Request)과 데이터를 `log.info` 레벨로 기록함.
    
- **문제점:** 닉네임 중복 체크와 같은 빈번한 조회 요청(Read Operation)까지 모두 INFO 레벨로 남길 경우, **로그 파일 용량이 급증(Log Flooding)**하고 정작 중요한 에러나 비즈니스 이벤트를 식별하기 어려운 **'로그 노이즈(Log Noise)'** 현상이 우려됨.
    

#### **2. 고민 및 접근 (Consideration)**

- **로그 레벨의 기준 부재:** `INFO`, `DEBUG`, `WARN`, `ERROR` 등 각 레벨의 명확한 역할과 사용 기준에 대한 이해가 필요했음.
    
- **가시성(Visibility) vs 비용(Cost):** 개발 단계에서는 자세한 정보가 필요하지만, 운영(Production) 환경에서는 디스크 I/O 비용 절감과 핵심 정보 위주의 모니터링이 필요하다는 점을 인식.
    

#### **3. 해결 및 결과 (Solution & Result)**

- **표준 로깅 전략(Logging Standard) 수립:** AI와 공식 문서를 통해 로그 레벨의 표준을 학습하고 프로젝트에 적용.
    
    - **ERROR:** 시스템이 복구 불가능하거나 즉시 조치가 필요한 예외 상황.
        
    - **INFO:** 데이터 상태가 변경되는 중요한 비즈니스 이벤트(Create, Update, Delete).
        
    - **DEBUG:** 단순 조회(Read)나 개발 단계의 데이터 흐름 추적용.
        
- **환경별 분리:** `application.yml` 설정을 통해 로컬에서는 `DEBUG`까지, 운영 환경에서는 `INFO` 이상만 남기도록 제어 가능하게 설계.
    
- **성과:** 불필요한 로그 적재를 방지하여 시스템 리소스를 절약하고, 이슈 발생 시 핵심 로그만 빠르게 파악할 수 있는 **유지보수성(Maintainability)** 확보.ㄴ