https://curiousjinan.tistory.com/entry/spring-filterchain-dofilter#1.%20doFilter%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1
#filter 

```java
import jakarta.servlet.*;
import java.io.IOException;

public class SpringFilterExample implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 필터 초기화 시 필요한 작업을 여기서 수행
        Filter.super.init(filterConfig);
    }
    @Override
public void doFilter(...) {

    // [1구역] 입장 (Request)
    // 컨트롤러(Servlet)로 가기 '전'에 실행됨
    // 예: JWT 검사, 시간 측정 시작, 로그 남기기
    long startTime = System.currentTimeMillis(); 
    System.out.println("Request Processing Started");

    // -------------------------------------------------------
    // [중요] "야, 다음 타자 나와!" (혹은 컨트롤러 실행해!)
    // 여기서 코드가 '일시 정지' 되고, 컨트롤러가 일을 다 끝낼 때까지 기다립니다.
    chain.doFilter(request, response); 
    // -------------------------------------------------------

    // [2구역] 퇴장 (Response)
    // 컨트롤러가 일을 다 마치고 돌아오면 실행됨
    // 예: 실행 시간 계산, 응답 데이터 암호화
    long endTime = System.currentTimeMillis();
    System.out.println("Request Processing Completed");
}
    @Override
    public void destroy() {
        // 필터 종료 시 필요한 작업을 여기서 수행
        Filter.super.destroy();
    }
}
```
### init: 서버가 켜질 때 **딱 1번** 실행(매 요청마다 아님)
## doFilter()
- 사용자가 요청할 때마다 매번 실행됨
- doFilter이전에 startTime을 찍고 doFilter를 실행함
- ~={red}**doFilter()가 끝나기 전까지 현재 객체의 코드 실행이 멈춤**=~
- doFiler가 끝난 후에 endTime이 찍힘
### destory: 서버가 종료될 때 딱 1번 실행


## doFilter가 ServletRequest를 사용하는 이유
- ServletRequest interface는 다양한 프로토콜에 대한 요청을 처리할 수 있기 때문에 사용한다. 
- HTTP,FTP 등 다양한 프로토콜 요청을 동일하게 처리한다

## HttpServletRequest를 사용하고 싶을 때
#### HttpServletRequest
- ServletRequest를 확장한 인터페이스
- HTTP 프로토콜에 특화된 추가 기능 제공
- HTTP 요청 헤더,쿠키,메시지 바디 등에 쉽게 접근
#### 사용법
- ServletRequest를 HttpServletRequest로 캐스팅하여 사용
```java
if (request instanceof HttpServletRequest) {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        // 여기서 HTTP 요청에 특화된 작업을 수행한다.
    }
```