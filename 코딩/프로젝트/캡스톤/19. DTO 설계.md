#DTO설계
지금까지 논의한 **Member/Chat 도메인의 DTO 설계 전략**을 코드는 제외하고, **구조와 역할, 그리고 원리** 중심으로 깔끔하게 정리해 드립니다.
이 내용은 프로젝트의 **설계 표준 문서(Design Guideline)**로 활용하시면 좋습니다.

### **1. 최종 설계 구조 (Structure & Roles)**

모든 채팅 관련 응답 객체는 **`ChatSessionResponse`** 라는 하나의 클래스 내부에 **`record`** 형태로 정의하여 관리합니다.
- **`ChatSessionResponse` (포장지 클래스)**
    - 채팅 도메인에서 사용되는 모든 응답 DTO를 감싸는 컨테이너 역할을 합니다.
    - 관련된 DTO들을 한 파일에 모아두어 관리 편의성을 높입니다.
    - **① `SummaryDto` (목록 조회용)**
        - **역할:** 채팅방 목록을 보여줄 때 사용합니다.
        - **특징:** 데이터 전송량을 줄이기 위해 무거운 메시지 내용은 제외하고, **식별자(ID), 제목, 시간** 등 핵심 정보만 담습니다.
        - **필수:** 클릭 시 상세 화면으로 이동해야 하므로 **`chatSessionId`**가 반드시 포함되어야 합니다.
    - **② `DetailDto` (상세 조회용)**
        - **역할:** 특정 채팅방에 들어갔을 때 전체 대화 내용을 보여줍니다.
        - **핵심:** 내부에 포함된 메시지 리스트를 엔티티 그대로 내보내지 않고, **`MessageDto` 리스트로 변환**하여 담습니다.
    - **③ `MessageDto` (내부 데이터 보호용)**
        - **역할:** `DetailDto` 내부에서 사용되는 메시지 단위의 객체입니다.
        - **목적:** DB의 엔티티 구조와 프론트엔드 간의 **완충재(Buffer)** 역할을 합니다. 엔티티가 변경되어도 이 DTO만 수정하면 프론트엔드는 안전합니다.
    - **④ `SearchedMessageDto` (검색용)**
        - **역할:** 키워드 검색 결과로 나온 특정 메시지들을 보여줍니다.


### **2. 핵심 설계 원칙 (Key Principles)**

이 구조가 **"유지보수하기 좋고 안전한 이유"** 3가지입니다.

#### **A. 구조: Inner Record (내부 레코드 방식)**

- **방식:** 클래스 안에 `static record`를 정의하는 방식.
- **이점:** 파일 하나만 열면 채팅 관련 DTO를 모두 볼 수 있어 **응집도**가 높고, 패키지 구조가 지저분해지지 않습니다.
- **Record:** 데이터 불변성(Immutable)을 보장하여, 데이터가 중간에 변조될 위험을 원천 차단합니다.

#### **B. 변환: Static Factory Method (`from`)**

- **방식:** `new` 연산자를 직접 쓰지 않고 `Dto.from(entity)` 형태로 호출.
- **이점:**
    - **가독성:** "이 엔티티로부터 DTO를 만든다"는 의도가 코드에 명확히 드러납니다.
    - **메모리 효율:** 변환을 위해 별도의 변환기 객체(Converter)를 생성할 필요가 없습니다. (Static 메서드는 공유 메모리에 상주)

#### **C. 안전장치: Decoupling (결합도 낮추기)**

- **방식:** 엔티티를 바로 반환하지 않고, 반드시 **DTO로 한 번 감싸서** 반환.
- **이점:**
    - **방어:** DB 컬럼명이 바뀌거나 구조가 변경되어도, DTO 매핑 로직만 수정하면 프론트엔드 코드는 깨지지 않습니다.
    - **보안:** 비밀번호나 관리자 메모 같은 민감한 정보가 실수로 노출되는 것을 막아줍니다.

### **3. 메모리 동작 흐름 (Memory Lifecycle)**

`SummaryDto.from(session)`을 호출했을 때, 자바 메모리 내부에서 일어나는 일입니다.

1. **Ready (Method Area):** 프로그램 시작 시 `from()` 메서드의 **설명서(코드)**가 한 번 로딩되어 대기합니다.
2. **Call (Stack):** 메서드가 호출되면 **임시 작업대(Stack Frame)**가 잠깐 생깁니다.
3. **Reference (Stack → Heap):** 작업대는 Heap에 있는 **실제 데이터(Entity)**를 참조(포인터)하여 값을 읽어옵니다.
4. **Create (Heap):** 데이터를 바탕으로 **새로운 DTO 객체(완제품)**가 Heap에 생성됩니다.
5. **Return & Clear:** 생성된 DTO의 주소만 반환하고, Stack의 **임시 작업대는 즉시 소멸**합니다.

