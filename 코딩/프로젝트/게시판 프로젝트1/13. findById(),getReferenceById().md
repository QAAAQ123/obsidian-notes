## findById()
`Optional<T> findById(ID id)`
- 엔티티 실제 조회->영속성 컨텍스트에 로드하고 반환->엔티티 존재하지 않으면 Optional.empty반환
[[Optional 클래스]]
**반환 타입:** ==`Optional<T>`를 반환==하므로, **엔티티의 존재 여부를 명확하게 확인**할 수 있습니다.
- **장점:**
    - **안전성:** 엔티티가 실제로 데이터베이스에 존재하는지 즉시 확인할 수 있습니다. 엔티티가 존재하지 않으면 `NoSuchElementException` (Optional 처리 시) 등의 예외를 발생시켜 잘못된 업데이트를 방지할 수 있습니다.
    - **명확성:** 업데이트를 진행하기 전에 대상 엔티티의 최신 상태를 확실히 가져와서 작업할 수 있습니다.
- **단점:** 항상 데이터베이스 조회 쿼리가 발생합니다.

## getReferenceById()
`public T getReferenceById(ID id)`
- ==엔티티를 실제로 조회하지 않음==
- 해당 ID를 가진 엔티티의 프록시 객체를 즉시 반환함-> 실제 데이터가 필요할 때 쿼리를 실행해 데이터 로드
- 실제 엔티티가 없으면 쿼리 실행할때 EntityNotFoundException 발생

- **반환 타입:** ==실제 엔티티 타입(`T`)을 반환==합니다.
- **장점:**
    - **성능 최적화:** 실제 데이터베이스 조회를 지연시키므로, 단순히 외래 키 참조를 설정하는 등 엔티티의 ID만 필요한 경우에 유용합니다. 불필요한 쿼리를 줄여 성능을 최적화할 수 있습니다.    
- **단점:**
    - **오류 인지 지연:** ID에 해당하는 엔티티가 존재하지 않더라도 즉시 알 수 없고, 나중에 프록시 객체의 실제 데이터에 접근하려고 할 때 예외가 발생합니다.
    - **`EntityNotFoundException`:** 엔티티가 존재하지 않는 경우, `findById()`처럼 `Optional`로 존재 여부를 검사할 수 없고, 접근 시점에 예외가 터지므로 예외 처리가 필요합니다.

## 차이점
FindById() 는 무조건 해당 SQL을 곧바로 실행하고, getReferenceById()는 만약에 함수를 호출하고서, 실제로 그 데이터를 출력하거나 사용할때 SQL이 실행됩니다. (다만, ID값을 호출할경우 SQL이 필요하지 않습니다.)
일반적인 상황에서는 FindById()를 통해 Optional 한 값을 활용하여 예외처리를 진행하는것이 좋아보입니다.
단순히, Entity 의 ID값만 필요한 상황이라면,  getReferenceById()를 통해 Select문이 실행되는 처리를 제외할 수 있으므로 getReferenceById()를 통해 처리하는것도 고려하는것이 좋을 것 같습니다. 이러한 상황에서는, EntityNotFoundException을 피하기 위해 반드시 DB에 해당 데이터가 있는 상황이라는 것도 고려할 필요가 있습니다.

*참고* getOne() = getReferenceById()
JPA는 엔티티를 저장할 때 객체와 연관관계를 만들어주는 측면이 조금 불편하다. 보통 findById()를 사용하면 데이터의 조회가 이뤄져서 연관관계의 엔티티를 조회하기 위한 select + insert쿼리가 수행된다. 이를 개선하기위해 엔티티의 id값만 설정한 임시 엔티티를 만들어주는 방식과 getOne()을 사용한 방식이 있다. 임시로 엔티티를 만들어서 연관 관계를 만드는 방법은 기존의 db데이터와 불일치 문제를 야기할 수 있다. 반면, getOne()을 사용할시 다른 필드에 접근했을 경우 db에 존재하지 않는다면 예외를 반환하고 존재하는 경우 lazy방식으로 조회하기 때문에 데이터의 불일치 문제를 해결할 수 있다. 따라서 **연관 관계를 갖는 엔티티를 저장할 때, 연관된 엔티티 조회시 getOne()을 사용하는 것이 성능 개선에 도움이 된다.**

(https://passionfruit200.tistory.com/386)

