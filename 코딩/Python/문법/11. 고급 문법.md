## 1. 반복자

### 1. 열거 가능 객체(Iterable 객체)
- for문과 range()는 모두 내부적으로 iterable로 구현된다. 
- python에서 iterable 객체는 Class 메서드에 `__iter__`과 `__next__`를 작성해주면 iterable 객체가 된다. 

### 2. 반복자를 더 간단하게 만든 Generator
- yield로 리턴한다.
- yield: return문과 유사하지만 **~={red}변수의 마지막 값과 상태를 저장=~**한다. 
- 내부에서 자동으로 `__iter__`과 `__next__`를 생성한다.
- 더 저장 할게 없을 때는 `StopIteration`예외를 던진다.
```python
def seqgen(data):
	for index in range(0,len(data),2):
		yield data[index:index+2]
		
# 더 간단하게 작성
data = "xxxxxxxxxxxxxxxxxx"
for k in (data[index:index+2] for index in range(0,len(data),2)):
	print(k,end = ', ')
```

#### 리스트 컴프리헨션과 제네레이터 표현식
```python
#리스트 컴프리헨션
for n in [i for i in range(100)]:
	print(n,end = ', ')
print("\n")
#제네레이터 표현식
for n in (i for i in range(100)):
	print(n,end = ', ')
```
- `()`를 이용해 만든것이 제네레이터 표현식이고 `[]`를 이용해서 만든게 리스트 컴프리헨션이다.
- 리스트 컴프리헨션은 **리스트를 생성해두고** 반복을 시작한다.
- 하지만 제네레이터는 iterator 방식으로 동작한다. 
- 매우 큰 범위를 돌리거나 반복을 중간에 빠져 나갈 경우 iterable 방식이 훨씬 빠르다

## 2. 데코레이터

### 1. 일급시민
- 파이썬은 함수도 변수와 똑같은 방식으로 다루어지며 다음과 같은 동작이 가능한다.
	1. 이름가짐
	2. 다른 변수에 대입 가능
	3. 인수로 전달 가능
	4. 리턴 가능
	5. 컬렉션에 저장 가능
	```python
	def calc(op,a,b):
		op(a,b)
	def add(a,b):
		print(a+b)
	def multi(a,b):
		print(a*b)
		
	calc(add,1,2)
	calc(multi,1,2
	```
### 2. 지역 함수
- 지역 함수는 함수 안의 함수이다. 지역 함수는 해당 지역 함수를 주인으로 하는 범위 내에서만 사용이 가능하다. 
```python
def makeHello(message):
	def hello(name):
		print(message + ", ", name)
	return hello
	
enghello = makeHello("Good Morning")
hanhello = makeHello("안녕하세요")

enghello("Mr Kim")
hanhello("홍길동")
```
- 위의 hello는 계속 메모리에 유지된다. 따라서 결과는
- Goog Moring, Mr kim
  안녕하세요, 홍길동 이 된다.
- 지역 변수가 지속기간이 긴 함수에 의해 계속 사용된다면 해석기는 이 변수를 없애지 않고 Closure라는 특수 구조를 만들어 계속 유지한다.


### 3. ~={red}함수 데코레이터=~
- 함수의 앞뒤에 원하는 코드를 추가하는 기법
- 함수를 Wapper하여 원하는 코드를 추가하고 Wapper 함수에서 원래 함수를 호출하는 방식으로 동작한다.
- 함수 데코레이터의 변천 과정
```python
#inner 함수가 주체인데 대상처럼보인다. 
def inner():
	print("결과를 출력합니다")

def outer(func):
	print("-"*20)
	func()
	print("-"*20)

outer(inner)

#Wapper 함수를 명시적으로 표현한다
def inner():
	print("결과를 출력합니다.")

def outer(func):
	def warpper():
		print("-"*20)
		func()
		print("-"*20)
	return warpper

wrapper = outer(inner) #inner = outer(inner)로 써도 무방하다
wrapper() #inner()와 같은 말이다

#데코레이터를 사용해 더 보기 쉽게 변경
def outer(func):
	def warpper():
		print("-"*20)
		func()
		print("-"*20)
	return warpper

@outer
def inner():
	print("결과를 출력합니다.")
	
inner()
```
1. inner를 대상인것 처럼 보이게 하는 warpper 코드
2. warpper를 명시적으로 작성하여 inner를 주체로 보이게 하는 코드
3. **~={red}데코레이터 `@outer`를 달아주어 가독성이 좋은 코드(`@outer`는 outer를 warpper로 가진다는 것을 `@`(데코레이터)를 통해 명시)=~**

```python
#함수 데코레이터 사용 예시
def para(func):
	def warpper():
		return "<p>" + str(func()) + "</p>"
	return warpper

@para
def outname():
	return "김상형"

@para 
def outage():
	return "29"

print(outname())
print(outage())
```

1. 하지만 변수 여러개를 리턴한다면 위와 같은 형태로 할 수 없음 ex)`return "이름: " + name + "님" 
2. 이것을 가변 인수와 가변 키워드와 데코레이터 `@wraps`를 통해 해결
3. `@wraps`를 붙혀주지 않으면 내부 함수의 모듈 이름인 `__name__`이 warpper로 변하고`__doc__`속성도 바뀐다.
```python
from functools import warps

def para(func):
	@wraps(func)
	def warpper(*args, **kwargs):
		return "<p>" + str(func(*args, **kwargs)) + "</p>"
	return warpper
	
@para
def outname(name):
	return "이름:" + name + "님"
	
@para
def outage(age):
	return "나이:" + str(age)

print(outname("김상형"))
print(outage(29))
print(outname.__name__)
```

### 4. 클래스 데코레이터
- 객체를 `객체()`형태로 호출하면 클래스의 `__call__`특수 메서드가 자동으로 호출 된다. 이것을 이용해 객체의 데코레이터를 만든다
```python
class Outer:
	def __init__(self,func):
		self.func = func
		
	def __call__(self):
		print("-"*20)
		self.func()
		print("-"*20)
	
def inenr():
	print("결과를 출력합니다")

inner = Outer(inner)
inner()

#데코레이터 이용
class Outer:
	def __init__(self,func):
		self.func = func
		
	def __call__(self):
		print("-"*20)
		self.func()
		print("-"*20)
	
@Outer	
def inenr():
	print("결과를 출력합니다")

inner()
```



## 3. 동적 실행 코드
### 1. eval
- 문자열 형태로 된 파이썬 코드 표현식을 실행중에 분석 및 실행하는 방식으로 동작
### 2. repr
- 객체로 부터 문자열 표현식을 생성
- str과 유사하지만 '표현식'이라는 면에서 더 엄격
- ~={red}**문자열 자체를 리턴한다**. =~
```python
str('korea')
#결과 korea -> 문자열 표현식을 문자열로 보여줌
repr('korea')
#결과 "'korea'" -> 'korea'라는 문자열 자체를 보여줌 

eval("'korea'")
#결과 'korea' -> 'korea'를 ""로 감싼 문자열 형태여서 문자열인 'korea'를 보여줌
eval('korea')
#결과 에러 -> 'korea'형태는 문자열이 아닌 korea 변수로 해석한다.
```
- **~={red}객체를 문자열 표현식으로 바꾸는 `__repr__` 특수 메서드를 제공한다.=~**
```python
class Human:
	def __init__(self,age,name):
		self.age = age
		self.name = name
	def __str__(self):
		return "이름 %s, 나이 %d" % (self.name,self.age)
	def __repr(self):
		return "Human(" + str(self.age) + ",'" + self.name + ",)"

kim = Human(29,"김상형")
print(kim)
kimexp = repr(kim)
kimcopy(eval(kimexp))
print(kimcopy)
```
- 객체를 표현식으로 바꿔 네트워크로 전송하거나 데이터베이스에 저장 할 수 있고, 표현식으로 부터 객체를 다시 만들어 낼 수 있다
- 객체를 자유자재로 관리할 수 있다는 면에서 의미가 있다

### 3. exec
- 파이썬 코드를 실행중에 실행
- eval함수는 표현식을 실행하지만 exec는 동작을 수행하는 문장을 실행 할 수 있다.
- 계속 실행할 코드를 미리 컴파일러로 해석해 놓을 수 있다.
- `complie(source,filename,mode)`