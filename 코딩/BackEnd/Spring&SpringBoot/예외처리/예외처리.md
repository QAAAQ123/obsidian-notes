- ~={red}**@ControllerAdvice와 @ExceptionHandler의 핵심 차이점은 적용 범위이다**=~
	- @ControllerAdvice는 **~={red}컨트롤러 전체=~**에서 같은 Exception을 처리한다
	- @ExceptionHandler는 **~={red}한개의 컨트롤러=~**에서 같은 Exception을 처리한다
- 결국 모든 응답은 Controller를 거쳐야 하기 때문에 모든 예외 처리를 Controller에서 해줘야 한다
	- 스프링 MVC에서 권장하는 패턴이다
	- try-catch를 사용하지 않고 **~={red}컨트롤러 계층까지 전파=~**시키는 것이다

## 스프링부트의 기본적인 예외 처리
- 스프링 부트는 `BasicErrorController` Bean을 가지고 있다. 
- `BasicErrorController`은 간단히 말하면 /error 엔드포인트의 요청을 전담하는 컨트롤러이다. 이 컨트롤러의 return 값을 커스텀해주면 HTTP 에러코드를 전담하는 HMTL을 만들 수 있게 된다. 
- ex)/templates/5xx.html,404.html
  404에러가 난다면 BasicErrorController가 404.html로 연결해준다
- BasicErrorController는 Exception별로 세부 에러메시지,통합 에러메시지를 설정해 줄 수 없기 때문에 `@(Rest)ControllerAdvice`와 `@ExceptionHandler`를 사용한다

## 처리 방식
- `@ControllerAdvice`는 **전역 예외 처리 클래스 지정**
- `@ExceptionHandler`는 **예외 처리 메서드 지정**
- 커스텀 예외는 `@ExceptionHandler`로 처리하며, 전역으로 적용하려면 `@ControllerAdvice` 안에서 사용


![[Pasted image 20251003183653.png]]
- AroundHubException-무시

## 예외 클래스
![[Pasted image 20251004130906.png]]
- 모든 예외 클래스는 Throwable을 상속 받고 있다. 
- Checked와 Unchecked Exception의 차이
	- Checked: 애플리케이션 실행 전의 예외
	- Unchecked: 애플리케이션 발생중 예외(RuntimeException이 대표적인 예)

## Spring의 예외 처리
### @ControllerAdvice와 @RestControllerAdvice
- 전역 
- Controller나 RestController에서 발생하는 예외를 한곳에서 관리
- 범위 지정 가능(기본값은 모든 컨트롤러) 
- **예외 결과를 JSON으로 반환하려면 `@RestControllerAdvice`를 사용해야 함**
- 그 외에는 @ControllerAdvice

### @ExceptionHandler
![[Pasted image 20251004131826.png]]
- 특정 예외(Exception)가 발생했을 때, 해당 예외를 처리할 메서드를 지정해주는 어노테이션이다.
- 특징
	1. 더 자식인 Exception클래스의 우선순위가 높다
	2. 컨트롤러 내부에서의 예외처리가 글로벌 예외처리(`@ControllerAdvice`)보다 우선순위가 높다

## **~={red}예외 처리=~**
- 예외 처리를 직접 할 수 있는 경우에는 try-catch를 이용해 처리하는 것이 가장 우선이고, 옳다
- Exception 처리는 에러메시지를 어떻게 통합해서 관리할 것이냐에 대한 것이다
	- 오류를 처리하지 않고 오류 발생했다고 클라이언트로 오류발생을 전달해주는 역할만 해야 한다.
- 만약 @ControllerAdvice나 @ExceptionHandler를 통해 예외 처리를 직접 해주면 경우의 수가 많아지기 때문에 의미가 없다


## 예시
### @ExceptionHandler만 이용한 예외 처리
```java
@RestController
@RequestMapping("/plays")
public class WebController {

    private final GameService gameService;

    // 생성자 주입
    public WebController(GameService gameService) {
        this.gameService = gameService;
    }

    /**
     * 비즈니스 로직 메서드 1: 성공 경로에만 집중하고, 예외는 그냥 던집니다.
     */
    @PostMapping
    public ResponseEntity<PlayResponse> play(@RequestBody @Valid PlayRequest playRequest) { // @Valid 추가
        PlayResponse playResponse = gameService.playRacing(playRequest.getNames(), playRequest.getCount());
        return ResponseEntity.ok(playResponse);
    }

    /**
     * 비즈니스 로직 메서드 2: 역시 성공 경로에만 집중합니다.
     */
    @GetMapping
    public ResponseEntity<List<PlayResponse>> plays() {
        List<PlayResponse> allGameHistory = gameService.showGameHistory();
        return ResponseEntity.ok(allGameHistory);
    }

    // --- 여기서부터는 예외 처리 전담 메서드들 ---

    /**
     * 이 컨트롤러 내에서 발생하는 IllegalArgumentException을 처리합니다.
     * @PostMapping, @GetMapping 메서드 양쪽에서 발생하는 예외를 모두 여기서 처리합니다.
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException e) {
        return ResponseEntity.badRequest().body(e.getMessage());
    }

    /**
     * @Valid 검증에 실패했을 때 발생하는 MethodArgumentNotValidException을 처리합니다.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<String> handleValidationException(MethodArgumentNotValidException e) {
        // 실제 프로젝트에서는 e.getBindingResult()를 통해 더 상세한 에러 메시지를 만드는 것이 좋습니다.
        return ResponseEntity.badRequest().body("요청 입력값이 유효하지 않습니다.");
    }
}
```

- 위 코드는 `ExceptionHandler`를 잘 활용한 예시이지만, 이 컨트롤러 안에 있는 Exception만 처리할 수 있다. 여러개 컨트롤러에서 같은 Exception을 처리할 때 `ControllerAdvice`를 사용한다
### @ControllerAdvice를 이용한 예외 처리
- 다른 컨트롤러에서도 같은 Exception을 처리하고 있다고 가정한다
- ControllerAdvice의 적용 범위를 변경 할 수 있다.(default는 컨트롤러 전체)
```java
@RestController
@RequestMapping("/plays")
public class WebController {

    private final GameService gameService;

    public WebController(GameService gameService) {
        this.gameService = gameService;
    }

    @PostMapping
    public ResponseEntity<PlayResponse> play(@RequestBody @Valid PlayRequest playRequest) {
        PlayResponse playResponse = gameService.playRacing(playRequest.getNames(), playRequest.getCount());
        return ResponseEntity.ok(playResponse);
    }

    @GetMapping
    public ResponseEntity<List<PlayResponse>> plays() {
        List<PlayResponse> allGameHistory = gameService.showGameHistory();
        return ResponseEntity.ok(allGameHistory);
    }
}
///-----------------------------------------------------------------------------------------------

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException e) {
        ErrorResponse errorResponse = new ErrorResponse("INVALID_INPUT", e.getMessage());
        return ResponseEntity.badRequest().body(errorResponse);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        // 실제로는 e.getBindingResult()에서 더 구체적인 첫 번째 에러 메시지를 추출하는 것이 좋습니다.
        String message = e.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", message);
        return ResponseEntity.badRequest().body(errorResponse);
    }
    
    // 필요하다면 다른 전역적인 예외들도 이곳에 추가할 수 있습니다.
    // @ExceptionHandler(AuthenticationException.class)
    // ...
}
///-----------------------------------------------------------------------------------------------

// Java 17의 record를 사용하면 매우 간결하게 작성할 수 있습니다.
public record ErrorResponse(String errorCode, String message) {
}

/*
// 일반 클래스로 작성한다면 아래와 같습니다.
public class ErrorResponse {
    private String errorCode;
    private String message;

    // 생성자, Getter
}
*/
```

