## REST 엔드포인트 다중 사용 이유
실제 서비스 웹 앱에서 백엔드 앱은 다른 백엔드 앱의 클라이언트 역할을 하는 경우가 많다. 따라서 서버간 노출된 REST 엔드포인트를 호출하여 사용해야 한다. ex)클라이언트<->앱<->결제 서비스

#### REST 엔드포인트 호출 도구
1. OpenFeign
2. RestTemplate
3. WebClinet


## OpenFeign
- **사용자가 Interface를 작성하면 OpenFeign이 구현해준다**
- 사용자가 할일: 경로,HTTP 메서드,매개변수,헤더 및 본문 요청/OpenFeign활성화
```java
//OpenFeign사용
@FeginClient(name="payments",url="${name.service.url}")
public interface PaymentsProxy{
	@PostMapping("/payment")
	Payment createPayment(
		@RequestHeaders String requestId,
		@RequestBody Payment payment);
}

//활성화
@Configuration
@EnableFeginClients(basePackages="com.example.proxy")
public class ProjectCofig{}

//사용
@RestController
public class PaymentController{
	private final PaymentsProxy paymentProxy;
	
	public PaymentsController(PaymentProxy paymentProxy){
		this.paymentProxy = paymentProxy;
	}
	
	@PostMapping("/payment")
	public class createPayment(@RequestBody Payment payment)
	{
		String requestId = UUID.randomUUID().toString();
		return paymentsProxy.createPayment(requestId,payment);
	}
}
```

## RestTemplate
- RestTemplate는 더 많은 기능이 필요해졌기 때문에 최근에 잘 사용되지 않는다. 
- RestTemplate는 종료되었고, 유지보수 단계로 전환되었다
- RestTemplate대신 OpenFeign을 사용해야 한다.

과정
1. HttpHeaders 인스턴스를 생성 및 구성하여 HTTP 헤더를 정의한다
2. 요청 데이터(헤더와 본문)를 나타내는 HttpEntity 인스턴스를 생성한다
3. exchange() 메서드를 사용하여 HTTP 호출을 전송하고 HTTP 응답을 수신한다.

```java
@Component
public class PaymentsProxy{
	private final RestTemplate rest;
	
	@Value("${name.service.url}")
	private String paymentsServiceUrl;
	
	public PaymentProxy(RestTamplate rest){
		this.rest = rest;
	}
	
	public Payment createPayment(Payment payment){
		String uri = paymentServiceUrl + "/payment";
		
		//요청 헤더 정의
		HttpHeaders headers = new HttpHeaders();
		headers.add("requestId",UUID.randomUUID().toString());
		
		//요청 바디 정의
		HttpEntity<Payment> httpEntity =
							new HttpEntity<>(payment,headers);
					
		//HTTP 요청 전송,HTTP 응답 값 받음		
		ResponseEntity<Payment> response =
								rest.exchange(uri,
											HttpMethod.POST,
											httpEntity,
											Payment.class);
											
		return response.getBody();
	}
}

@RestController
public class PaymentsController{
	private final PaymentsProxy paymentsProxy;
	
	public PaymentsController(PaymentsProxy paymentsProxy){
		this.paymentsProxy = paymentsProxy;
	}
	
	@PostMapping("/payment")
	public Payment createPayment(@ReqeustBody Payment payment)
	{
		return paymentsProxy.createPayment(payment);
	}
}
```

## WebClient
- 리액티브 방법론을 기반으로한 도구이다
- 리액티브 앱이 아니라면 OpenFeign사용 권장

- 리액티브 앱: Task를 독립적인 것으로 간주하고 여러 스레드와 협업하여 여러 Task로 구성된 비즈니스 흐름을 만드는 것
- 스레드의 유후 상태가 오래 지속되는 것을 제거하는 방법
  ex)사용자 정보를 내부와 외부 API에서 불러와야 할 때, 내부와 외부 작업을 하나의 Task로 하지 않고 2개 이상의 Task로 나누어 처리

- ### 리액티브 앱의 핵심

- **논블로킹(Non-blocking):** 리액티브 앱의 핵심은 스레드가 작업을 기다리며 유휴 상태에 빠지는 것을 방지하는 것입니다.
    
- **비동기(Asynchronous):** 작업을 여러 개의 비동기적인 단위(Task)로 나누어 처리합니다. 하나의 스레드가 여러 작업을 동시에 진행할 수 있습니다.
    
- **독립적인 Task:** 말씀하신 대로, 각 Task를 독립적인 단위로 간주하고, 여러 스레드가 이 Task들을 협력하여 비즈니스 로직을 완성합니다. 예를 들어, 사용자 정보 로딩 작업을 내부 DB 조회와 외부 API 호출이라는 두 개의 독립적인 Task로 나누면, 두 작업을 동시에 시작하고 먼저 끝나는 작업부터 결과를 받아 처리할 수 있습니다.

```java
@Configuration
public class ProjectCofnig{
	@Bean
	public WebClient webClient(){
		return WebClient
				.builder()
				.build();
	}
}

@Component
public class PaymentsProxy{
	
	private final WebClient webClinet;
	
	@Value("{name.service.url}")
	private Strin url;
	
	public PaymentsProxy(WebClient webClinet){
		this.webClient = webClinet;
	}
	
	public Mono<Payment> createPayment(String reqeustId,Payment payment){
		return webClient.post()
				.uri(url + "/payment")
				.header("requestId",reqeustId)
				.body(Mone.just(payment),Payments.class)
				.retireve()
				.bodyToMono(Payment.class);
	}
}

@RestController
public class PaymentsController{
	private final PaymenstProxy paymentsProxy;
	
	public PaymentsProxy(PaymentsProxy paymentsProxy){
		this.paymentsProxy = paymentsProxy;
	}
	
	@PostMapping("/payment")
	public Mono<Payment> create Payment(@RequestBody Payment payment){
		String requestId = UUID.randomUUID().toStirng();
		return paymentsProxy.createPayment(requestId,payment);
	}
}
```