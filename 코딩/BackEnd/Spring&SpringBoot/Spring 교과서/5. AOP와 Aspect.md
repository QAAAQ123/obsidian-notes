Aspect: 메서드의 호출을 가로채고 메서드의 실행을 변경 할 수 있는 방법
Aspect-Oriented-Programming(AOP)

## Aspect 작동 방식

### 용어
1. 가로채서 실행하는 코드 정의: Aspect(애스펙트)
2. 언제 Aspect 로직을 실행할지 정의: Advice(어드바이스)
3. 어떤 메소드를 가로챌건지 정의: Pointcut(포인트 컷)
4. Aspect 실행의 트리거하는 이벤트: Joint point(조인트 포인트)(스프링에서는 항상 메서드 호출)
5. 가로챌 대상이 되는 빈: Target object(대상 객체)

### 작동 방식
- **~={red}빈이 Aspect 대상이면 Proxy 객체에 대한 참조를 제공한다=~**. 이렇게 실제 빈에 Proxy 객체를 감싸는 방식을 위빙(weaving)이라고 한다.
- getBean(실제빈.class)요청이 들어오면 실제 빈의 주소가 아닌 실제 빈을 감싼 프록시 객체의 주소를 넘겨준다.
- 이때 getBean을 통해 얻은 클래스 타입은 EnhacerBySpring타입이다(CGLIB이용할 경우)
- `**프록시 객체**는 **타겟 객체**를 감싸고 있으며, **애스펙트**가 정의한 로직을 프록시 객체의 특정 메서드에 적용합니다. 이 프록시 객체의 타입은 JDK 동적 프록시나 CGLIB에 의해 동적으로 생성된 타입입니다. CGLIB를 사용한 경우, 클래스 이름에 $$EnhancerBySpringCGLIB$$와 같은 식별자가 포함됩니다.`
-~={red} **동작 방식: 실제 메소드처럼 보이는 프록시 메서드 호출 -> 프록시가 Aspect로직 실행 -> 프록시가 실제 메서드로 위임-> 실제 메소드 로직 실행**=~

### 전체 작동 방식
1. main에서 메서드 호출
2. Aspect가 호출을 가로챔(메서드 매개변수도 가로챔)
3. Aspect에서 로직 실행
4. 로직 실행 중에 메서드로 실행 위임(매개변수도 보냄)
5. 메서드에서 반환값을 Aspect로 보냄
6. Aspect에서 main으로 반환값을 보냄
7. **~={red}main에서는 Aspect의 존재를 알지 못하여 직접 메소드를 호출 하는것 처럼 보임=~**
![[Aspect 진행 과정.jpg]]


## Aspect 구현 방식
조건: spring-aspect 의존성을 추가

### 구현 단계
1. 앱에서 Aspect를 @EnableAspectJAutoProxy로 Aspect 활성화
```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
```
2. Aspect 클래스를 생성하고 컨텍스트에 Aspect 빈을 추가
   **~={red}★★★★★@Aspect는 스테레오타입 어노테이션이 아니다. 따라서 직접 Aspect Bean을 반드시 추가해야 한다.★★★★★=~**
```java
@Aspect
public class LoggingAspect{
	public void log(){...}
}

//@Configuration에 Aspect를 빈으로 등록
```
3. Aspect 로직을 실행할 메서드 정의하고 Advice를 통해 언제,어떤 메서드를 가로 챌 것인지 어노테이션을 통해 정의(여기서는 AspectJ 표현식 사용)
```java
@Aspect
public class LoggingAspect{
	@Around("execution(* services.*.(..))")//어떤 메소드를 언제 가로챌지 정의
	public void log(ProceedingJoinPoint joinPoint){
		joinPoint.proceed(); //가로챔 당한 메소드의 실행을 위임한다.(실제 메소드 실행)
	}
}
```
4. Aspect 로직 구현
```java
@Aspect
public class LoggingAspect{

private Logger logger = Logger.getLogger(LoggingAspect.class.getName());

	@Around("execution(* services.*.(..))")//어떤 메소드를 언제 가로챌지 정의
	public void log(ProceedingJoinPoint joinPoint){
		logger.info("Method will execute");//가로채고 실제 메소드로 위임전 실행할 로그
		joinPoint.proceed(); //가로챔 당한 메소드의 실행을 위임한다.(실제 메소드 실행)
		logger.info("Method executed");//가로채고 실제 메소드로 위임을 끝내고 실행할 로그
	}
}
```
1. proceed() 메소드는 발생하는 예외를 모두 던지도록 설계되었다.(throws Exception)
2. joinPoint.proceed() 가 없다면, Aspect는 메소드에 실행을 위임하지 않고 메서드 호출자는 실제 메서드가 실행되지 않았다는 것을 모른다. -> 이것을 통해 권한 부여나 보안을 할 수 있다.

### Aspect의 가로챈 메서드의 실행 변경 
Aspect는 메서드의 실행을 변경 할 수 있다.
1. 메서드로 전송된 매개변수 값 변경
2. 호출자가 받는 반환값 변경
3. 호출자에게 예외를 던지기
4. Aspect에서 메서드의 에러 catch 및 처리

#### 매개변수 가져오기
```java
String methodName = joinPoint.getSignature().getName();
Object [] arguments = joinPoint.getArgs();
```

#### 리턴값 변경하기
- **~={red}Aspect 메소드에 return 값 대로 호출자에게 리턴 값이 들어간다.=~**
```java
@Aspect
public class LoggingAspect { 
	@Around(xxxxx)
	public Object log(ProceedingJoinPoint joinPoint) throws Throwbale{
		//.....
		return "변경된 리턴 값";
	}	
}
```
이렇게 Aspect 메소드에서 리턴을 하게 되면 원래 메소드의 리턴 값이 아닌 Aspect 메소드의 리턴값이 호출자에게 되돌아간다.

#### 매개변수 변경하기
**~={red}joinPoint.proceed(변경한 매개변수들)로 실제 메소드의 매개변수를 변경 할 수 있다.=~**
```java
//방법1. 가져온 매개변수를 변화시켜 준다.
String methodName = joinPoint.getSignature().getName();
Object [] arguments = joinPoint.getArgs();


//방법2. 새로운 매개변수를 만든다
Object [] newArguments = {xxxx,xxxx};

//변경된 매개변수 값 전달
joinPoint.proceed(modifiedArgs);
```


#### 커스텀 어노테이션 가로채기
`@Around("@annotation(커스텀어노테이션)")`으로 Advice하면됨. 다른건 위와 똑같음

### Advice 어노테이션들-필요할때 찾아보기
1. @Before
2. @AfterReturing
3. @AfterThrowing
4. @After
5. @Around


## Aspect 실행 체인
Aspect가 한 메소드에 2개 이상 있을 때는 순서가 중요하다. 
- @Order 어노테이션으로 실행 순서를 정한다.
```java
@Aspect
@Order(1)
public class xxxAspect{...}

@Aspect
@Order(2)
public class xxxAspect{...}
```


## 요약
1. Aspect를 사용하면 메서드 실행과 같이 실행되는 로직을 완전히 분리해서 작성 할 수 있다.
2. Aspect는 잘못 사용하면 오버엔지니어링이 된다. 따라서 사용할 때에는 실제로 도움이 되는지 반드시 확인해야 한다.
3. Aspect로직을 구현하는 클래스에 @Aspect를 추가하고, 수동으로 Aspect 타입 Bean을 추가해야 한다.
4. Aspect 클래스 안에 메소드에 Advice어노테이션을 통해 언제,어떤 메소드를 가로챌 것인지 정의한다.
5. Aspect로 실제 메소드에 로직 추가,매개변수 변경,리턴값 변경,에러 처리 등을 할 수 있다.
6. 여러개의 Aspect가 동일한 메소드를 가로 챌 수 있다. 이때는 @Order를 통해 실행 순서를 정의한다.
