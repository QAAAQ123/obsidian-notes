### REST 
REST 엔드포인트: 단순히 두 앱 간 통신을 구현하는 방법,HTTP 메서드와 경로에 매핑된 컨트롤러 액션
- 뷰가 없이 데이터만 전달하기 때문에 6의 그림에서 뷰 리졸버와 관계만 없애면 된다. 

### REST 엔드포인트에 수반될 수 있는 통신 문제
1. 컨트롤러 작업에 시간이 오래 소요되면 HTTP 타임아웃이 되어 통신 중단 가능성
2. HTTP 한번의 요청에 대량의 데이터를 전송하면 호출이 타임아웃되에 통신 중단 가능성
3. 동시 호출이 과도하면 통신 중단 가능성
4. 네트워크 자체의 이유로 REST 엔트포인트 호출이 실패할 가능성은 항상 존재

## REST 엔드포인트 구현
- 컨트롤러안의 메서드에 `@ResponseBody`어노테이션을 추가하면 REST 엔드포인트가 된다. 
- `@ResponseBody`: 메소드의 반환 값을 뷰가 아닌 **~={red}데이터를 직접 전송한다고 명시=~**
- `@Controller`와 `@ResponseBody`를 **합친 것이 `@RestController`이다**

### REST 방식의 HTTP 응답 
HTTP 요청에 대한 응답을 할때 필요한 데이터
1. 응답 헤더: response header
2. 응답 본문: response body -> `@RequestBody`로 HTTP 요청 바디의 데이터를 받음(DTO)
3. 응답 상태: response state(HTTP 상태 코드)

- 객체를 응답 데이터로 보내려면 ~={red}DTO(Data Transfer Object)에 담아서 보내야 한다.=~
- ★★★★★**~={red}리턴 타입을 ResponseEntity 타입으로 해야 한다.=~**★★★★★
- ResponseEntity는 HTTP 상태 코드,헤더,바디를 설정 할 수 있다
```java
//예시
return ResponseEntity.status(상태코드).header(데이터).header(데이터).body(데이터);
```

### 엔드포인스 수준에서 예외 관리
1. Try-catch문으로 예외를 관리(단순하고 코드 중복 적을 때 적합)
	- 이때 ResponseEntity는 400이나500번대 상태 코드를 사용하고 바디에 에러 내용을 넣어주는게 좋다.
```java
public ResponseEntity<Entity타입> anyMethod(){
	try{
		//컨트롤러 로직
		return ResponseEntity
				.status(HttpStatus.OK)
				.body(데이터);
	} catch (anyException e){
		//에러 처리
		//에러 객체 생성 및 데이터 setter
		return ResponseEntity
			.badRequest()
			.body(에러엔티티);
	}
}
```
1. **~={red}RestController 어드바이스를 이용하여 예외 처리(AOP)=~**
	- 예외 관리 책임 분리
	- 중복 제거
	- 예외만 모아서 관리하기 편함
	- `@RestControllerAdvice`어노테이션 사용
```java
@RestControllerAdvice
public class ExceptionControllerAdvice{

	@ExceptionHandler(커스텀or기존 Exception.class)
	public ResponseEntity<에러객체> exceptionXXXXHandler(){
		ErrorDetails errorDetails = new ErrorDetials();
		errorDetails.setMessage("에러메시지");
		return ResponseEntity
				.badRequest()
				.body(errorDetails);
	}
}
```