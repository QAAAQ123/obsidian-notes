- 찾으려는 내용을 효율적을 찾아낼 수 있도록 도와주는 데이터 구조
- 쿼리 속도를 향상시킬 수 있다
- Binary Search Tree -> B-Tree -> B+ Tree

## ★★★★★인덱스 동작 과정★★★★★
1. **인덱스 생성 쿼리**
2. **선택된 열을 복사(=Copy 데이터)**
3. **Copy 데이터를 순서대로 정렬함**
4. **Copy 데이터들을 B-Tree나 B+ Tree 구조에 넣어 놓음**
5. **쿼리로 요청이 들어오면 Tree에서 찾음**
6. **Tree에서 찾은 데이터의 포인터(또는 주소)를 이용해 원본 테이블의 해당 행을 찾음**
7. **원본 테이블에서 찾은 완전한 행 데이터를 사용자에게 반환**


## B-Tree
- 이진 탐색 트리를 개선한 자료 구조
- 최대 M개의 자식 노드를 가지는 B-Tree를 M차 B-Tree라고 한다(최대 M개의 자식)
- [B-Tree](https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC)

### B-Tree의 특징
1. 노드는 최대 M개의 자식을 가질 수 있다
2. 노드는 최대 M-1개의 키를 가질 수 있다
3. 각 노드는 최소 ⌈M/2⌉개의 자식 노드를 가진다(root,leaf 노드 제외)
4. 각 노드는 최소 ⌈M/2⌉-1개의 키를 가진다. (root 노드 제외)

### B-Tree 데이터 삽입### (삽입,수정,삭제 과정 필요할 때 공부)
- 과정
	1. 트리가 비어있다면 root 노드를 할당하고 Key를 삽입한다
	2. 트리가 비어있지 않다면, 데이터를 넣을 적절한 leaf노드를 탐색한다
	3. leaf 노드에 데이터를 넣고 leaf 노드가 적절한 상태에 있다면 종료한다
	4. leaf ==노드가 넘친 상태면 분리==한다
- 추가는 항상 leaf 노드에 한다
- 노드가 넘치면 가운데 키를 기준으로 ==좌우 키를 분할==하고 ~={red}★★**가운데 키는 승진★★**=~한다
- 노드가 넘친다?: 각 노드에 있는 ==key의 개수가 M-1개보다 커지는 것==

### B-Tree 데이터 삭제
- Case
	1. leaf 노드에서 삭제하고 재 조정이 필요 없는 경우
	2. leaf 노드에서 삭제하고 key수 여유 있는 형제 노드가 있을 경우
	3. leaf 노드에서 삭제하고 key수 여유 있는 형제 노드가 없을 경우(부모 노드의 지원)
	4. leaf 노드가 아닌 곳에서 삭제가 일어나는 경우
	5. 루트 노드를 삭제할 경우
	6. 등등...


## B+ Tree(삽입,수정,삭제 과정 필요할 때 공부)
- B-Tree를 개선한 자료구조이다.
- ~={red}**★★모든 Key와 Data가 leaf 노드에 있다★★**=~
- ~={red}**★★leaf 노드간 링크가 되어있다.★★**=~
- ==내부 노드는 순수하게 인덱스 역할==만 한다.
- 내부 노드의 키가 leaf에도 중복되어 존재한다.(모든 데이터가 leaf에 있으므로)
- ==검색 시 항상 leaf 노드까지 내려가야 한다.==
- [B+ Tree](https://velog.io/@kyeun95/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-B-Tree%EB%9E%80)