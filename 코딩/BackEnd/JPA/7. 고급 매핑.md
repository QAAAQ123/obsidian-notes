- 상속관계 매핑,@MappedSuperclass,복합 키와 식별 관계 매핑,조인 테이블,엔티티 하나에 여러 테이블 매핑하기

## 7.1 상속 관계 매핑(~={red}**@Inheritance,@DiscriminatorColumn,@DiscriminatorValue 사용법**=~)

데이터 베이스의 슈퍼타입과 서브타입 관계 매핑 전략
- ~={red}각각의 테이블로 변환(조인 전략)=~
- ~={red}통합 테이블로 변환(단일 테이블 전략)=~
- 서브타입 테이블로 변환(구현 클래스마다 테이블 전략)


### 조인 전략(Joined)
- 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략
- 조회 할 때 조인을 사용하기 때문에, 조인 전략이라고 한다.
- 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해서 타입을 추가한다.
- ~={red}부모테이블에서 받아온 자식 테이블의 기본 키 컬럼 명을 변경하고 싶으면 @PrimaryKeyJoinColumn을 사용한다.=~
- 예시: 아이템,(앨범,영화,책-> 자식)
```java
//부모 객체
@Entity
@Inheritance(strategy = InheritanceType.JOINED) //상속 매핑 전략을 조인으로 설정
@DiscriminatorColumn(name = "DTYPE") //구분 컬럼의 속성 이름을 DTYPE으로 지정
public abstract class Item{ //실제로 사용하지 않기 때문에 추상 클래스로 작성 가능
	@Id @GeneratedValue
	@Column(name = "ITME_ID")
	private Long id;

	private String name;
	private int price;
	...
}

//자식 객체 Album
@Entity 
@DiscriminatorValue("A") //저장시 모든 Album테이블의 DTYPE 속성 값이 A로 저장됨
public class Album extends Item{
	private String artist;
	...
}

//자식 객체 Movie
@Entity
@DiscriminatorValue("M") //A와 마찬가지로 테이블에 저장되는 모든 Movie.DTYPE 값은 M이 됨
public class Movie extends Item{
	private String director;
	private String actor;
	...
}
```

- 장점
	- 테이블 정규화
	- 외래 키 참조 무결성 제약조건 활용
	- 저장 공간 효율적 사용
- 단점
	- 조회할 때 조인 사용되므로 성능 저하 가능성
	- 조회 쿼리 복잡
	- 데이터 등록시 INSERT문 두 번 사용

### 단일 테이블 전략(Single_table)
- 테이블 하나만 사용하는 전략
- 구분 컬럼으로 어느 자식이 저장되었는지 구분
- ~={red}**자식 엔티티가 매핑한 컬럼은 모두 null 허용 해야함**=~(다른 자식은 다른 속성을 사용하기 때문에 ex)영화,앨범 자식 엔티티가 있다고 했을때 영화에 데이터가 들어가면 앨범의 속성에는 null이 들어가야 한다.)
```java
//부모 entity Item
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item{
	@Id @GeneratedValue
	@Column(name = "ITEM_ID")
	private Long id;

	private String name;
	private int price;
	...
}

//자식 엔티티 Album
@Entity
@DiscriminatorValue("A")
public class Album extends Item{ ... }

//자식 엔티티 Book
@Entity
@DiscriminatorValue("B")
public class Book extends Item{ ... }
```

장점
- 조인이 필요 없으므로 조회 성능이 빠르다
- 조회 쿼리가 단순하다
단점
- 자식 엔티티가 매핑한 컬럼은 모두 null 허용
- 테이블 커질 가능성 존재 -> 상황에 따라서 조회 성능이 오히려 느려짐
특징
- 구분 컬럼 사용 필수(@DiscriminatorColumn)
- @DiscriminatorValue설정하지 않으면 엔티티 이름을 값으로 사용한다.


### 구현 클래스마다 테이블 전략(Table_per_class)
- 자식 엔티티마다 테이블을 만드는 전략이다. 추천하지 않는 전략이다


## 7.2 @MappedSuperclass(~={red}**@MappedSuperclass,@AttributeOverrides,@AssocationOverrides 사용법**=~)
- 부모 클래스는 테이블과 매핑하지 않고 자식 클래스에게 매핑 정보만 제공함
- 위 7.1에서 했던 엔티티 부모 추상 클래스는 테이블과 매핑되지만, @MappedSuperclass는 실제 테이블과 매핑되지 않는다.
- 단순히 상속 목적으로 사용된다

```java 
@MappedSuperclass
public abstract class BaseEntity {
	@Id @GeneratedValue
	private Long id;
	private String name;
	...
}

@Entity
public class Member extends BaseEntity{....}

@Entity
@AttributeOverride(name = "id",column = @Column(name = "MEMBER_ID"))
public class Member extends BaseEntity{....}

@Entity
@AttributeOverrides({
	@AttributeOverride(name = "id",column = @Column(name = "MEMBER_ID"))
	@AttributeOverride(name = "name",column = @Column(name = "MEMBER_NAME"))
})
public class Member extends BaseEntity{....}
```
- 매핑 정보 재정의 하려면 @AttributeOverrides나 @AttributeOverride 사용
- 연관관계를 재정의 하려면 @AssocationOverrides나 @AssocationOverride 사용
- 특징
	- ~={red}테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.=~
	- ~={red}@MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용 할 수 없다=~
	- ~={red}추상 클래스로 만드는 것을 권장=~


## 7.3 복합 키와 식별 관계 매핑
- 식별 관계: 부모 테이블의 기본 키를 자식 테이블의 기본 키 + 외래 키로 사용
- 비식별 관계(주로 사용)
	- 부모 테이블의 기본 키를 자식 테이블의 외래 키로만 사용
	- 필수적 비식별 관계: 외래 키에 NULL 비허용,연관관계 필수
	- 선택적 비식별 관계: 외래 키에 NULL 허용,연관관계 선택

### 복합 키 클래스(~={red}**@IdClass,@EmbeddedId 사용법**=~)
- JPA는 영속성 콘텍스트에 보관할 ~={red}**식별자를 구분하기 위해서 equals와 hashCode를 사용하여 동등성 비교**=~를 한다.
- 따라서 ~={red}식별자가 2개 이상이면 별도의 식별자 클래스=~를 만들고 equals와 hashCode를 override하여 작성해야 한다.
- JPA는 복합 키를 지원하기 위해 @IdClass와 @EmbeddedId를 제공한다

#### @IdClass로 ~={green}비식별=~ 관계 매핑
**관계형 데이터베이스에 가까운 방법이다**
```java
public class ParentId implements Serializable {
	private String id1;
	private String id2;

	public ParentId(){}
	public parentId(String id1,String id2){this.id1 = id1; this.id2 = id2;}

	@Override
	public boolean equals(Object o){ ... }
	@Override
	public int hashCode() { ... }
}

@Entity//부모 엔티티
@IdClass(ParentId.class) //ParentId 클래스를 식별자로 지정
public class Parent {
	@Id
	@Column(name = "PARENT_ID1")
	private String id1; //ParentId.id1과 연결

	@Id
	@Column(name = "PARENT_ID2")
	private String id2; //ParentId.id2와 연결

	private String name;
	...
}

@Entity//자식 엔티티
public class Child{
	@Id
	private String id;

	@ManyToOne //예시
	@JoinColumns({
		@JoinColumn(name = "PARENT_ID1",
			referencedColumnName = "PARENT_ID1"),
		@JoinColumn(name = "PARENT_ID2",
			referencedColumnName = "PARENT_ID2")
	})
	private Parent parent;	
}
```
- @IdClass 식별자 클래스 조건
	- 식별자 클래스의 속성명과 엔티티의 식별자 속성 명이 같아야 한다
	- Serializable 인터페이스를 구현(implements)해야 한다
	- equals,hashCode를 구현해야 한다
	- 기본 생성자가 있어야 한다
	- 식별자 클래스는 public이여야 한다
- 자식 클래스
	- 부모 테이블이 복합 키이므로, 자식 테이블의 외래 키도 복합 키다.
	- @JoinColumns 어노테이션을 사용하여 매핑 해야 한다

#### @EmbeddedId로 ~={green}비식별=~ 관계 매핑
**객체지향적인 방법이다**
```java
@Embeddable //식별자 클래스 embeddable로 작성
public class ParenId implements Serializable{
	@Column(name = "PARENT_ID1")
	private String id1;
	@Column(name = "PARENT_ID2")
	private String id2;

	//equals,hashCode 구현
}

@Entity
public class Parent{
	@EmbeddedId
	private ParentId id;

	private String name;
	...
}
```
- @EmbeddedId는 식별자 클래스에 기본키를 직접 매핑한다
- @EmbeddedId 식별자 클래스 조건
	- @Embeddable 어노테이션 
	- Serializable 인터페이스 구현
	- equlas,hashCode 구현
	- 기본 생성자 
	- 식별자 클래스 public 
- @IdClass,@EmbeddedId 중에 취향에 맞는 것 일관성 있게 사용


#### @IdClass로 ~={green}식별=~ 관계 매핑
```java
@Entity
public class Parent{...}

@Entity
@IdClass(ChildId.class)
public class Child{...}

public class ChildId implements Serializable{...}

@Entity
@IdClass(GrandChildId.class)
public class GrandChild{...}

public class GrandChildId implements Serializable{...}
```

#### @EmbeddedId로 ~={green}식별=~ 관계 매핑
```java
@Entity
public class Parnet{...}

@Entity
public class Child{...}

@Embeddable
public class ChildId implements Serializable{...}

@Entity
public class GrandChild{...}

public class GrandChildId implements Serializable{...}
```
- @EmbeddedId는 @Id 대신에 @MapsId를 사용한다. @MapsId는 외래 키와 매핑한 연관관계를 기본키에도 매핑하겠다는 뜻이다

#### 비식별 관계로 구현
```java
@Entity 
public class Parent{...}
@Entity
public class Child{...}
@Entity
public class GrandChild{...}
```
식별 관계의 복합 키를 사용한 코드와 비교해서 매핑도 쉽고 코드도 단순하다

#### 일대일 식별 관계
- 일대일 식별 관계의 자식 테이블의 기본 키 값은 부모 테이블의 기본 키 값을 사용한다. 따라서 부모 테이블의 기본 키가 복합 키가 아니면 자식 테이블의 기본 키도 복합키로 구성하지 않아도 된다.
```java
@Entity
public class Board{
	@Id @GeneratedValue
	@Column(name = "BOARD_ID")
	private Long id;

	@OneToOne(mappedBy = "board")
	private BoardDetail boradDetail;
}

@Entity
public class BoradDetail{
	@Id
	private Long boardId;

	@MapsId //BoardDetail.boardId 매핑
	@OneToOne
	@JoinColumn(name = "BOARD_ID")
	private Board board;

	private String content;
	...
}
```

##### 식별,비식별 관계의 장단점
- DB 설계 관점에서 비식별 관계 선호
	- 식별 관계는 기본 키를 자식 테이블로 전파하면서 기본 키가 점점 늘어남-> SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커짐
	- 식별 관계는 2개 이상의 컬럼을 합해 복합 기본 키를 만들어야 하는 경우가 많다
	- 비즈니스 요구 사항은 시간이 지남에 따라 언젠가는 변한다. 그래서 비즈니스와 전혀 관계 없는 대리 키를 주로 사용한다
	- 식별 관계는 부모 테이블의 기본 키를 자식 테이블의 기본 키로 사용하므로 비식별 관계보다 테이블 구조가 유연하지 못하다
- 객체 관계 매핑 관점에서 비식별 관계 선호
	- 일대일 관계를 제외하고 식별 관계는 2개 이상의 컬럼을 묶은 복합 기본 키를 사용해야 한다. 컬럼이 하나인 기본 키를 매핑하는 것 보다 많은 노력 필요
	- 비식별 관계의 기본 키는 주로 대리 키를 사용하는데 JPA는 @GeneratedValue처럼 대리키를 생성하기 위한 편리한 방법 제공
- 선택적 비식별 관계보다 필수적 비식별 관계를 사용하는 것이 좋다.(선택적 비식별 관계는 NULL 허용함으로 외부 조인 사용,필수적 관계는 NOT NULL로 내부 조인 사용)

## 7.4 조인 테이블
- 데이터베이스 테이블의 연관관계 설정 방법 
	- 조인 컬럼 사용(외래 키)
	- 조인 테이블 사용(테이블 사용)
- 조인 컬럼은 단순히 외래 키 컬럼만 추가해서 연관관계를 맺음
-  조인 테이블은 연관관계를 관리하는 조인 테이블을 추가하고 여기서 두 테이블의 외래 키를 가지고 연관관계를 관리함
- ~={red}조인 테이블은 주로 다대다 관계를 일대다와 다대일 관계로 풀어내기 위해 사용한다=~

## 7.5 엔티티 하나에 여러 테이블 매핑
- @SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑 할 수 있다
```java
@Entity
@Table(name="BOARD")
@SecondaryTable(name = "BOARD_DETAIL",
	pkJoinColumns = @PrimaryKeyJoinColumn(name = "BOARD_DETAIL_ID"))
public class Board{
	@Id
	@GeneratedValue
	@Column(name = "BOARD_ID")
	private Long id;

	private String title;

	@Column(table = "BOARD_DETAIL")
	private String content;
	...
}
```
- @SecondaryTable.name: 매핑할 다른 테이블의 이름
- @SecondaryTable.pkJoinColumns: 매핑할 다른 테이블의 기본 키 컬럼 속성
- @SecondaryTables를 사용하면 더 많은 테이블들을 매핑 할 수 있다
- ~={red}@SecondaryTable을 사용해 두 테이블을 하나의 엔티티에 매핑하는 방법 보다는 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장=~

## 정리
- 객체의 상속 관계를 데이터베이스에 매핑하는 방법
- 매핑 정보만 상속하는 @MappedSuperclass
- 복합 키 매핑 방법
- 식별,비식별 관계
- 조인 컬럼,조인 테이블
- 엔티티 하나에 여러 테이블 매핑
- 상속 관계 매핑과 @MappedSuperclass만 주로 사용함