## 프록시  
~={red}★★★**지연 로딩을 하기 위해 사용하는 가짜 객체**★★★=~
#### 프록시
- 데이터베이스 조회를 지연할 수 있는 가짜 객체
- 실제 클래스를 상속 받아 만들어짐
- 클래스와 똑같은 메소드를 가짐-> 프록시도 요청을 받을 때 메소드를 사용해야 하기 때문이다
- 클래스와는 다른 필드 Entity target(참조)를 가진다.(실제 객체를 참조하는 필드를 가진다)

#### 프록시 구조
- 초기화 전 필드: Entity target = null;
- 초기화 후 필드: ~={red}Entity target = 실제 엔티티=~;
- 메소드: 참조하는 엔티티와 똑같음

#### 프록시 초기화
- ~={red}★★★프록시 초기화: target이 실제 엔티티를 참조하는 것(실제 엔티티 생성됨)★★★=~
- 프록시는 생성되고 바로 Persistence context에 저장되는 것이 아니다.
- 실제 사용될때 즉. 프록시 메소드를 사용할때 초기화가 된다.
- ~={red}**과정: 프록시 객체.method()를 호출 -> 실제 데이터 조회 요청 -> 실제 엔티티 없으면 영속성 콘텍스트에 실제 엔티티 생성 요청(초기화) -> 실제 엔티티 객체를 프록시의 target에 보관 -> 프록시 객체가 실제 엔티티의 method를 호출해서 결과 반환**=~


#### 프록시 특징
- 처음 사용할 때 한 번만 초기화된다
- 프록시 객체를 초기화 하면 프록시 객체가 실제 엔티티에 접근 할 수 있게 된다
- 영속성 콘텍스트에 이미 실제 엔티티가 있으면 프록시의 method를 요청해도 실제 엔티티의 결과를 반환한다
- 초기화는 영속성 콘텍스트의 도움을 받아야 가능하다. 
- 준영속 상태의 프록시를 초기화 하면 문제가 발생한다


## 즉시 로딩과 지연 로딩
#### ★★★즉시 로딩★★★
- **엔티티 조회시 ~={red}연관된 엔티티 모두 조회**=~
- 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다
- 조인 쿼리를 사용

#### ★★★지연 로딩★★★
- **조회시 ~={red}연관된 엔티티는 조회하지 않음**=~
- 연관된 엔티티를 ~={red}프록시로 조회=~한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이슬 조회한다
- fetch 타입을 Lazy로 설정해야함


#### JPA 기본 fetch 전략
- @ManyToOne,@OneToOne: 즉시 로딩(FetchType.EAGER)
	- 연관된 엔티티가 1개이기 때문
- @OneToMany,@ManyToMany: 지연 로딩(FetchType.LAZY)
	- 연관된 엔티티가 n개 이기 때문

## 영속성 전이:CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 같이 영속 상태로 만드는 것
- 쉽게 말하면 부모 엔티티를 저장 할 때 자식 엔티티도 함께 저장할 수 있다
- 영속성 전이를 활성화 하는 옵션은 cascade = CascadeType.PERSIST
- 옵션 설정 방법: orphanRemoval = true

## 고아 객체
- ~={red}고아 객체:부모 엔티티와 연관관계가 끊어진 자식 엔티티=~
- 고아 객체를 자동으로 삭제하는 기능을 고아 객체 제거라고 한다
- **부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다**


### 영속성 전이+고아 객체
- CascadeType.ALL, orphanRemoval = ture를 동시에 사용하면 부모 엔티티를 통해서 자식의 생명주기를 관리 할 수 있다
- 자식을 저장하려면 부모에 등록만 하면 되고,자식을 삭제하려면 부모에서 제거하면 된다.