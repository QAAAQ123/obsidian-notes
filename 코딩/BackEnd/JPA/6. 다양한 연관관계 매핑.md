### 5장 정리
- 연관관계 매핑할 때 고려사항
	- 다중성
		- 다대일,일대다,일대일,다대다(거의 사용하지 않음)
	- 단방향,양방향
		- 테이블은 외래 키를 사용하면 항상 양방향이다. 
		- 객체는 한쪽만 참조하면 단방향,양쪽다 참조하면 양방향
	- 연관관계의 주인
		- 객체의 단방향에서는 주인이 없어도 된다. 
		- 객체 양방향에서는 연관관계를 관리하는 곳이 2개라서 하나를 정해 테이블의 외래 키를 관리하게 한다. 
- 모든 연관관계
- | 다대일 | 일대다 | 일대일 | 다대다 |
  |----|----|----|----|
  |단방향,양방향|단방향,양방향|주 테이블 단방향,양방향| 대상 테이블 단방향,양방향 | 단방향,양방향|

## 6.1 다대일 
- 다대일 단방향,다대일 양방향

### 6.2.1 다대일 ~={red}단방향=~[N:1]
- N쪽에 외래키 둠
- 다대일 관계의 반대 방향은 항상 일대다 관계
- 1:N 관계에서 외래 키의 주인(외래 키 관리)은 반드시 N쪽에 있다
- **~={red}@JoinColumn(name = "xxxx")를 이용해 Member.team 객체와 MEMBER.TEAM_ID 외래 키를 매핑 시킨다=~**

### 6.2.1 다대일 ~={red}양방향=~[N:1,1:N]
- N쪽에 외래키 둠
- [N:1] 단방향 매핑을 한것의 반대 [1:N]관계의 엔티티에 **~={red}@OneToMany(mappedBy = "xxx")=~**를 하면 된다.
- 외래 키를 사용 할 때 연관관계의 주인만 사용한다.**~={red}주인이 아닌 객체는 조회를 위한 JPQL이나 객체 그래프 탐색시에만 사용한다.=~**
- 양방향 연관관계는 **항상 서로를 참조**해야 한다. ~={red}**setter와 adder도 알맞게 작성해야 한다=~**.(Team에는 addMember,Member에는 setTeam 메소드)


## 6.2 일대다
* 일대다 단방향,일대다 양방향

### 6.2.1 일대다 단방향[1:N]
- 1쪽에 외래키 둠
- 반대쪽 테이블에 있는 외래 키를 관리 한다. 
```java
  @OneToMany
  @JoinColumn(name = "xxxx")
  ```
 - 일대다 단방향 매핑의 단점
	 - 객체가 관리하는 외래 키가 다른 테이블에 있다는 점이다
	 - 처리를 할때 2번 해주어야 한다.
- **~={red}결론: 일대다 단방향 매핑보다 다대일 양방향 매핑을 권장=~**

### 6.2.2 일대다 양방향[1:N,N:1]
- 일대다 양방향 매핑은 존재하지 않는다. 정확히 말하면 @OneToMany는 주인이 될 수 없다. 항상 N쪽에 외래키가 있기 때문이다. 
- 1:N 단방향 매핑 반대편에 같은 외래 키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 추가하면 된다. 
- 6.2.1의 코드의 반대 엔티티에 아래의 코드를 추가하면 된다. 
  ```java
	@ManyToOne
	@JoinColumn(name = "xxxx", insertable = false,updateable = false)
	```

- 일대다 단방향 매핑이 가지는 단점을 그대로 가지기 때문에 다대일 양방향 매핑 사용을 권장한다.


## 6.3 일대일[1:1]
- 일대일 관계는 어느 곳이나 외래 키를 가질 수 있다.
	- 주 테이블의 외래 키(객체지향 개발자 선호)
	- 대상 테이블에 외래 키(DB 개발자 선호)
	- 주 테이블 설정 기준: 접근 빈도,비즈니스 로직,의존성,성능, 확장성(일대다로 변경 가능성)

### 6.3.1 주 테이블에 외래 키
#### 단방향
- ```java
  @OneToOne
  @JoinColumn(name = "XXXX")```
- 단순하게 @JoinColumn 어노테이션 작성을 통해 설정 가능

#### 양방향
- ```java
  //주 테이블
  @OneToOne
  @JoinColumn(name = "XXXX")
  
  //대상 테이블
  @OneToOne(mappedBy = "xxxx")```
- 양방향이므로 @JoinColumn과 mappedBy를 사용해야 한다.

### 6.3.2 대상 테이블에 외래키
#### 단방향
- 매핑 방법도 없고, 지원하지 않는다.

#### 양방향
- ```java
  //주 엔티티
  @OneToOne(mappedBy = "XXXX")
  //대상 엔티티
  @OneToOne
  @JoinColumn(name = "xxxx")```
- 주 엔티티에 mappedBy,대상 엔티티에 @JoinColumn을 사용해서 상관관계를 설정


## 6.4 다대다
**~={red}*★★객체는 @ManyToMany로 테이블은 연결 테이블로 다대다 관계를 표현한다.★★=~***

- RDB에서는 테이블로 다대다 관계를 표현 할 수 없다.
- 다대일 관계로 풀어내는 ~={red}**연결 테이블**=~을 사용한다.
- ~={red}**하지만 엔티티에서는 변형 없이 @JoinTable을 사용한다.**=~
- 예시: 고객-상품은 다대다 관계이다. 고객-고객_상품-상품으로 연결 테이블 고객_상품을 만든다.

### 다대다 단방향
```java
@ManyToMany
@JoinTable(name = "MEMBER_PRODUCT",
	joinColumns = @JoinColumn(name = "MEMBER_ID"),
	inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"))
	private String name;
```
1. @ManyToMany로 다대다 연결
2. @JoinTable: @JoinColumn을 하지 않고,다대다에서는 테이블을 연결 해주는 것이니 @JoinTable을 사용해야 한다.
	1. name = "MEMBER_PRODUCT": 고객_상품 테이블을 조인
	2. joinColumn~={red}s=~: 정상 방향의 매핑할 컬럼 정보들 지정(여기서는 1개의 컬럼만 조인)
	3. inverseJoinColumn~={red}s=~: 역 방향의 매핑할 컬럼 정보들 지정(여기서는 1개의 컬럼만 조인)

### 다대다 양방향
* 다대다 단방향에서 다대다 관계를 작성하지 않은 곳에 mappedBy를 작성하여 이 엔티티는 주인이 아니다라고 알려준다
```java
@ManyToMany(mappedBy = "xxxx")
```
- 양방향 관계는 편의 메소드를 추가하여 관리하는 것이 편하다.
```java
public void addProduct(Product product){
	...
	products.add(product);
	product.getMembers().add(this);
}
```

### 다대다 매핑의 한계,연결 엔티티 사용
- 실무에서는 연결 테이블에 단순히 아이디로 구성된 연결 테이블로 끝나지 않는다. 그 안에 기본키가 아닌 다른 속성들도 더 들어가야 한다. -> 다대다를 다대일,일대다 2개로 풀어야 한다.
- 고객과 상품을 다대다 관계로 맺고 있을때, 연결 테이블로 고객상품구매 테이블을 만들었다고 하자.
	- 연결 테이블의 기본 키가 아닌 속성도 들어가야 한다. 
	- 따라서 Member,Product,MemberProduct **~={red}★★3개의 엔티티를 만들어야 한다.★★=~**
- 고객상품구매(memberProduct)는 식별자 클래스로 만들어야 한다.
```java
@Entity
@IdClass(MemberProductId.class) //★★★복합 기본 키 매핑★★★
public class MemberProduct {
	@Id
	@ManyToOne
	@JoinColumn(name = "MEMBER_ID")
	private Member member;//MemberProductId.member와 연결

	@Id
	@ManyToOne
	@JoinColumn(name = "PRODUCT_ID")
	private Product product;//MemberProductId.product와 연결

	private int orderAmount;
	....
}

public class MemberProductId implements Serializable {
	//★★★해당 클래스는 MemberProduct의 복합 기본 키를 만들어주는 클래스이다.★★★
	private String name;
	private String product;

	//must override hashCode and equals method 
}
```
- **~={red}★복합 기본 키★=~**
	- 복합 기본 키는 별도의 식별자 클래스로 만들어서 엔티티에 넣어야 한다.
	- Serializable를 implement해야한다.
	- equals와 hashCode 메소드를 override해야 한다.
	- 기본 생성자가 있어야 한다.
	- 식별자 클래스는 public이여야 한다.
	- @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다. @EmbeddedId는 객체 관점의 복합 기본 키 생성 방법이고, @IdClass는 테이블 관점의 복합 기본 키 생성 방법이다.
- **~={red}★★★식별 관계★★★=~**
	- 부모 테이블의 기본 키를 받아서 자신의 기본 키,외래 키로 사용하는 것을 데이터베이스 용어로 식별 관계라고 한다.
- ~={red}MemberProduct는 식별 관계이고 복합 기본 키를 사용한다.=~

### 다대다: 새로운 기본 키 사용
* 위의 다대다 양방향에서 복합 기본키와 식별 관계를 사용하는 것은 개발과 관리 측면에서 비효율적이다.
* 연결 테이블에 새로운 대체 기본 키를 사용하는 것을 추천한다.
* MemberProduct에 orderId를 대체키로 추가하면 memberId,productId는 외래 키로만 존재하면 되고 복잡한 코드를 작성하지 않아도 된다. 

## 6장 정리
- N:1 단방향은 N쪽에 외래 키가 있다. 
- N:1 양방향은 다대일 단방향 코드에 1쪽에 외래 키의 주인이 아님(mappedBy)을 명시하면 된다. 양방향은 단지 객체 역방향 그래프 탐색 기능을 추가해 준다.

- 1:N 단방향과 양방향은 비효율적이기 때문에 N:1 양방향을 사용하는 것이 낫다

- 1:1 관계는 주 테이블,대상 테이블을 구분하고 주와 대상 중 어디에 외래 키를 넣을 것인지 결정하면 된다.

- N:M 관계를 테이블에서는 표현 할 수 없어서 **연결 테이블을 사용하여** 표현한다.
- N:M 관계
	- N:M 단방향: @JoinTable 어노테이션을 이용해서 연결 테이블 매핑
	- N:M 양방향 비식별 관계(대체 기본 키): 연결테이블 엔티티,기존 엔티티 2개 3개의 엔티티를 작성
	- N:M 양방향 식별 관계(복합 기본 키): 연결테이블 엔티티,기존 엔티티 2개 총 3개의 엔티티 작성 + 복합 기본 키 클래스 작성(연결 테이블 엔티티에 사용,@IdClass)
	- 양방향 관계에서는 대체 기본 키 사용을 권장