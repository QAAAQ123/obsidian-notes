## 스프링 컨테이너의 영속성 컨텍스트 전략
- 스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 제공하는 전략에 따라야 한다.
- 스프링 컨테이너는 ~={red}**트랜잭션 범위의 영속성 컨텍스트 전략**=~을 기본으로 사용한다.
- 트랜잭션 범위의 영속성 컨텍스트 전략: 프리젠테이션 계층(컨트롤러,View 등)은 준영속 상태,트랜잭션 범위(Service,Repository)는 영속상태 + 영속성 컨텍스트 생존(~={red}★★★service와 repository에서만 영속 상태★★★=~)
- 트랜잭션 범위의 영속성 컨텍스트 세부 전략
	1. 트랜잭션이 같으면 같은 영속성 콘텍스트를 사용한다. 
	2. 트랜잭션이 다르면 다은 영속성 콘텍스트를 사용한다.

## 준영속 상태와 지연 로딩
- 보통 비즈니스 로직은 서비스 계층에서 끝내기 때문에 프레젠테이션 계층에서 변경 감지 기능이 동작하지 않아도 문제가 되지 않는다
- 준영속 상태(프레젠테이션 계층)에서 지연 로딩일 때 뷰를(조회)사용하려고 하면 ==프록시 객체가 초기화 되지 않아서 LazyInitalizationException 예외가 발생==한다.
- 준영속 상태의 지연 로딩 문제를 해결하는 방법
	- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
	- OSIV를 사용해서 엔티티를 항상 영속 상태를 유지하는 방법

### 뷰가 필요한 엔티티를 미리 로딩해두는 방법
1. 글로벌 fetch 전략 수정: 지연 로딩 전략을 즉시 로딩 전략으로 변경
2. JPQL fetch 조인: JPQL의 fetch 조인을 사용해서 미리 로딩
3. 강제로 초기화: 트랜잭션 상태일때 사용할 프록시를 미리 getter통해 초기화
	1. 프록시를 미리 초기화 하는 것은 프리젠테이션 계층을 위한 일이다. 그런데 이 로직을 서비스 계층에서 담당하는 것은 서비스 계층 역할의 침범이다.
	2. 따라서 프록시 초기화를 위한 FACADE 계층을 만들어 프록시 초기화만 담당한다. 

### FACADE 계층 추가
- 뷰가 필요한 엔티티 미리 로딩해두는 전략 중 강제 초기화 전략을 사용하면 서비스 계층을 침범한다. 
- 따라서 초기화 전략을 사용할 때는 프록시 초기화 역할을 하는 FACDE 계층을 추가해야 한다.
- 역할과 특징
	- 프리젠테이션 계층과 도메인 모델 계층 간의 논리적 의존성을 분리해준다
	- 프리젠테이션 계층에서 필요한 프록시 객체를 초기화한다
	- 서비스 계층을 호출해서 비즈니스 로직을 실행한다
	- 리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다
- 하지만 이 방법도 오류가 발생할 가능성이 높다.그리고 물리적으로 FACADE와 서비스로직이 나뉘어 져있지만 논리적으로는 서로 의존한다. 
- 이 모든 문제는 엔티티가 프리젠테이션 계층에서 준영속 상태이기 때문에 발생한다. -> 프리젠테이션 계층까지 영속 상태로 열어두면 (지연 로딩 문제가) 해결 된다.
- 이것이 OSIV이다

## OSIV
- OSIV:Open Session In View
- 영속성 컨텍스트를 뷰까지 열어둔다는 뜻

### 과거 OSIV: 요청 당 트랜잭션
- 모든 범위를 트랜잭션 상태에 두고 영속 상태를 계속 유지하는 방법
- 프레젠테이션 계층이 엔티티를 변경 할 수 있다는 문제점 가짐
- 해결 방법
	- 엔티티를 읽기 전용 인터페이스로 제공
	- 엔티티 레핑
	- DTO만 반환

## ~={red}★★스프링 OSIV: 비즈니스 계층 트랜잭션★★=~
- ==모든 범위에서 영속성 컨텍스트를== 유지
- 프레젠테이션 계층에서는 ==수정 불가이지만 영속 상태==
- 비즈니스 로직 구현 계층을 ==트랜잭션 범위이고 수정 가능==하게 만든다
- 프레젠테이션 계층에서 엔티티를 수정한 직후에 트랜잭션을 시작하면 엔티티가 변경 된다.->트랜잭션을 시작하고 마지막에 엔티티를 수정하여 해결

#### OSIV 정리
- 스프링 OSIV의 특징
	- 한번 조회한 엔티티는 요청이 끝날 때 까지 영속 상태를 유지한다
	- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작하고, 트랜잭션이 없는 프리젠테이션 계층에서는 지연 로딩과 조회를 할 수 있다.
- 스프링 OSIV의 단점
	- 같은 영속성 콘텍스트를 여러 트랜잭션이 공유할 수 있다
	- 프리젠테이션 계층에서 엔티티 수정후 바로 비즈니스 로직을 실행하면(트랜잭션을 실행 하면)엔티티가 수정 될 수 있다.
	- 프리젠테이션 계층에서 지연 로딩에 의한 SQL이 실행된다. 따라서 성능 튜닝시에 확인해야 할 것들이 많다
- OSIV를 사용하는 것이 만능은 아니다
	- 복잡한 화면을 구성할 때는 이 방법이 효과적이지 않을 때가 많다. 이럴 때는 JPQL로 필요데이터들만 DTO로 반환하는 것이 더 낫다
- OSIV는 JVM을 벗어난 상황에서 사용할 수 없다
	- 클라이언트에서 연관관 엔티티를 지연 로딩하는 것이 불가능 하다. 결국 클라이언트가 필요한 데이터를 모두 JSON으로 생성해서 반환해야 한다.

## ★★API★★
1. 외부 API: 외부에 노출한다. 한 번 정의하면 변경이 어렵다. 서버와 클라이언트를 동시에 수정하기 어렵다
   ex) 타 팀과 협업하기 위한 API,타 기업과 협업하는 API
2. 내부 API: 외부에 노출하지 않는다. 언제든지 변경 할 수 있다. 서버와 클라이언트 동시에 수정할 수 있다.
   ex) 같은 프로젝트에 있는 화면을 구성하기 위한 AJAX 호출


# 정리
1. 준영속 상태(프레젠테이션 계층)에서 지연 로딩일 때 뷰를(조회)사용하려고 하면 프록시 객체가 초기화 되지 않아서 LazyInitalizationException 예외가 발생
2. 이 문제를 해결 하기 위해 뷰가 필요한 엔티티를 미리 로딩해두는 방법 사용(글로벌 fetch,JPQL fetch join,강제 초기화(FACADE 계층 추가)) 
3. 뷰가 필요한 엔티티를 미리 로딩해 두는 방법에는 논리적 의존이 발생해 스프링 컨테이너에서는 스프링 OSIV 사용