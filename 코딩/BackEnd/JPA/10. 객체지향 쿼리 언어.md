## 검색 방법
1. 식별자로 조회(EntityManager.find())
2. 객체 그래프 탐색(a.getC())
3. JPQL
4. SQL ...

## 객체지향 쿼리
- 객체지향 언어인 Java에서 SQL로 데이터를 관리하는 방법은 비효율적이다
- ~={red}JPQL: 테이블 대상 검색 언어인 SQL대신에 객체를 대상으로 검색하는 쿼리=~
- ==JPQL 쿼리 사용 -> JPA가 JPQL 분석해서 SQL을 만듬 -> SQL로 DB 조회 -> 조회 결과로 엔티티 객체를 생성해서 반환==
- JPQL은 한마디로 객체지향 SQL이다

#### JPA가 공식 지원하는 기능
1. JPQL:Java Persistence Query Language
2. Criteria 쿼리: JPQL을 편하게 작성하도록 도와주는 API와 빌더 클래스의 모음 + ~={red}동적 쿼리 생성에 유리=~
3. 네이티브 SQL: JPA에서 직접 SQL 사용
4. 공식 지원하지 않는 기능: QueryDSL,JBDC직접사용,SQL 매퍼 프레임워크


## JPQL 
- 엔티티 객체를 조회하는 객체지향 쿼리
- 특정 데이터베이스에 의존하지 않음
- DB 방언만 변경하면 DB변경 가능
- 결국 SQL로 변환됨
- 크게 정적 쿼리와 동적 쿼리로 구분 됨

### JPQL 문법 및 기능(필요할 때 찾아보기)
1. Insert문 없음(persist() 메소드 사용)
2. SELECT문
	1. TypeQuery: 반환 타입 지정
	2. Query: 반환 타임 미지정
3. 파라미터 바인딩(필수)
	1. 이름 기준 파라미터 바인딩
	2. 위치 기준 파라미터 바인딩
4. 프로젝션: 조회 대상 지정
	1. 엔티티 프로젝션
	2. 임베디드 타입 프로젝션
	3. 스칼라 타입 프로젝션
	4. 여러 값 조회
	5. NEW 명령어
5. 페이징 API
		1. setFirstResult(int startPosition)
		2. setMaxResult(int maxResult)
6. 집합과 정렬
		1. 집합 함수
		2. Group By,Having
		3. 정렬(ASC,DESC)
7. JPQL 조인
		1. 내부 조인
		2. 외부 조인
		3. 컬렉션 조인
		4. 세타 조인
		5. ~={red}fetch 조인: 메인 객체 뿐만아니라,Join을 하는 보조 객체도 영속 상태로 올려두는 조인(기본 내부 join은 join의 주체인 객체만 영속상태로 올려둔다)=~
		6. 엔티티 fetch 조인
8. 경로 표현식
	1. 상태 필드
	2. 연관 필드
		1. 단일 값 연관 필드
		2. 컬렉션 값 연관 필드
9. 서브 쿼리
10. 조건식
	1. 타입 표현: 문자,숫자,날짜,Boolean
	2. 연산자 우선 순위
	3. 논리 연산과 비교식
	4. Between,IN,LIKE,NULL
	5. 컬렉션 식
	6. 스칼라 식
	7. CASE 식
11. 다형성 쿼리
	1. TYPE
	2. TREAT
12. 사용자 정의 함수 
13. 엔티티 직접 사용
	1. 기본 키 값
	2. 외래 키 값
14. Named 쿼리

## Criteria
- ~={red}JPQL을 생성하는 빌더 클래스=~
- 장점
	- 컴파일 시점에 오류 발견 가능
	- IDE 코드 자동완성 
	- 동적 쿼리 작성하기 편함
- 장점이 많지만 사용하기 불편하고 코드가 한눈에 들어오지 않는다는 단점이 있음
- 결국 JPQL의 생성을 돕는 클래스 모음(JPQL과 많이 중복됨)

### Criteria 문법 및 기능(필요할 때 찾아보기)
1. Criteria API는 javax.persistence.criteria 패키지에 있음
2. 조회
	1. 조회 대상 한 건,여러 건 지정
	2. DISTINCT
	3. NEW,construct()
	4. 튜플
3. 집합
	1. GROUP BY
	2. HAVING
4. 정렬
5. 조인
6. 서브 쿼리
	1. 상호 관련 서브 쿼리
7. IN 식
8. CASE 식
9. 파라미터 정의
10. 네이티브 함수 호출
11. 동적 쿼리
12. 여러 가지 함수
	1. JPQL 함수를 코드로 지원
	2. 조건 함수
	3. 스칼라와 기타 함수
	4. 집합 함수
	5. 분기 함수
13. Criteria 메타 모델 API


## QueryDSL
- ~={red}JPQL 빌더 역할=~
- 코드 기반이고 단순하며 사용하기 쉬움
- JPA 표준이 아닌 ~={orange}오픈소스 프로젝트=~이다

### QueryDSL 문법 및 기능(필요할 때 찾아보기)
1. 검색 조건 쿼리
2. 결과 조회
3. 페이징과 정렬
4. 그룹
5. 조인
6. 서브 쿼리
7. 프로젝션과 결과 반환
8. 수정,삭제 배치 쿼리
9. 동적 쿼리
10. 메소드 위임

## 네이티브 SQL
-~={red} 다양한 이유로 JPQL을 사용할 수 없을 때 SQL을 직접 사용 할 수 있는 기능=~
	- DB에 종속적인 기능
	- 인라인 뷰
	- 스토어드 프로시저 등 ....
- ~={red}네이티브 SQL을 사용하면 엔티티 조회 할 수 있고 JPA가 지원하는 영속성 콘텍스트의 기능을 그대로 사용할 수 있다=~
- JDBC API를 직접 사용하면 단순히 데이터의 나열을 조회할 뿐임


### 네이티브SQL 문법 및 기능(필요할 때 찾아보기)
네이티브 쿼리 API
- 결과 타입 정의
- 결과 타입을 정의 할 수 없을 때

1. 엔티티 조회(영속성 콘텍스트에서 관리)
2. 값 조회(영속성 콘텍스트에서 관리하지 않음)
3. 결과 매핑 
4. 결과 매핑 어노테이션
	1. @SqlResultSetMapping
	2. @EntityResult
	3. @FieldResult
	4. @ColumnResult
5. Named 네이티브 SQL


## 스토어드 프로시저(JPA 2.1)
- ???
- Named 스토어드 프로시저 

## 객체지향 쿼리 심화
1. ~={red}★★벌크 연산: 한 번에 여러 데이터 수정★★=~
2. 영속성 컨텍스트와 JPQL
	1. **JPQL로 조회한 엔티티는 영속 상태**
	2. **영속성 콘텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환**
	3. **JPQL은 항상 테이터베이스부터 조회**
3. 플러시 모드
	1. FlushModeType.COMMIT 모드는 트랜잭션 커밋할 때만 플러시 한다. 플러시가 너무 자주 일어나는 상황에 이 모드를 사용하면 플러시 횟수를 줄여 성능을 최적화 할 수 있다.
	2. JDBC를 사용하여 SQL을 실행하면 JPA가 쿼리를 인식하지 못한다. 따라서 JDBC를 사용하여 SQL을 실행하기 전에 수동으로 flush해줘야 한다

## 정리
1. ==JPQL은 SQL을 추상화해서 특정 데이터베이스 기술에 의존하지 않는다==
2. Criteria나 QueryDSL는 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 핵심은 JPQL이다
3. ==Criteria나 QueryDSL을 사용하면 동적으로 변하는 쿼리를 편리하게 작성할 수 있다==
4. Criteria는 JPA가 공식 지원하는 기능이지만 직관적이지 않고 사용하기에 불편하다. 반면에 QueryDSL은 공식 지원하는 기능은 아니지만 직관적이고 편리하다
5. ==JPA도 네이티브 SQL을 제공하므로 직접 SQL을 사용할 수 있다. 하지만 특정 데이터베이스에 종속적인 SQL을 사용하면 다른 데이터베이스로 변경하기 쉽지 않다. 따라서 최대한 JPQL을 사용하고 그래도 방법이 없을 때 네이티브 SQL을 사용하자==
6. ==JPQL은 대량 데이터를 수정하거나 삭제하는 벌크 연산을 지원한다==