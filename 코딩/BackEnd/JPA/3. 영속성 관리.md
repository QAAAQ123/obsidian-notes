JPA가 제공하는 기능

1. 엔티티와 테이블 매핑(설계)
2. 엔티티 실제 사용

엔티티 매니저: 엔티티와 관련된 모든 일 처리한다. 개발자 입장에서 **엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스**로 생각하면 된다.

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저

**Entity manager factory, Entity manager**

- entity manager 생성 과정
    1. Persistence.createEntityManagerFactory("xxx");로 **entity manager factory를 생성**한다  
        (createEntityManagerFactory method를 호출하면 META-INF/persistence.xml에 있는 정보를 바탕으로 entity manager factory를 생성한다)
    2. 필요할 때마다 entity manager factory에서 **entity manger를 생성**한다
- Entity manager factory를 만드는 비용은 상당히 크다. 따라서 **한 개만 만들어서 애플리케이션 전체에서 공유**한다.
- Entity manager factory는 **여러 스레드가 동시에 접근해도 안전**하다
- Factory에서 엔티티 매니저를 **생성하는 비용은 거의 들지 않는다**.
- JPA 구현체들은 **factory를 생성할 때 커넥션풀도** 만든다(J2SE환경)
- Entity manger는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 **스레드 간에 절대 공유하면 안 된다**.
- Entity manger는 DB 연결이 꼭 **필요한 시점 이전에 커넥션을 얻지 않는다**.

## 3.2 영속성 컨텍스트

**Persistence context**
![[JPA영속성 관리.png]]
- JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트(persistence context)이다
- '엔티티를 영구 저장하는 환경'이라는 뜻
- persist() method는 엔티티 매니저를 사용해 엔티티를 영속성 콘텍스트에 저장한다
- 영속성 콘텍스트는 논리적인 개념이다
- persistence context는 엔티티 매니저가 생성될 때 만들어지고, **엔티티 매니저를 통해서 영속성 콘텍스트에 접근하고 관리**한다.

영속성 컨텍스트(persistence context) 단어의 뜻

- 영속성: 오래 계속되는 성질
- Persistence Context: **A set of managed entity instances** in which for any persistent entity identity, there is a unique entity instance.(**JPA가 관리하는 엔티티 인스턴스들의 집합이며, 특정 식별자(ID)에 대해 하나의 엔티티 인스턴스만 존재하도록 보장되는 공간**)

## 3.3 엔티티의 생명주기

**비영속, 영속, 준영속, 삭제**

1. 비영속: persistence context와 전혀 관계가 없는 상태  
    ex) 엔티티를 생성하고 persist() 하지 않음
2. 영속: persistence context에 저장된 상태  
    ex) 엔티티를 persist(xxx)로 저장
3. 준영속: persistence context에 저장되었다가 분리된 상태(persistence context가 더 이상 관리하지 않는 상태)  
    ex) entitymanger.detach(), entitymanager.close(), entitymanager.clear()
4. 삭제: persistence context에서 삭제된 상태(엔티티를 persistence context와 DB에서 삭제)

## 3.4 영속성 컨텍스트의 특징

- **영속 상태는 반드시 식별자 값이 있어야 한다**(식별자 값으로 구분하기 때문에)
- **트랜잭션을 커밋하는 순간 persistence context에 새로 저장된 엔티티를 DB에 반영한다**(이것을 flush라고 함)
- persistence context가 entity를 관리하면 생기는 장점
    - 1차 캐시/동일성 보장/트랜잭션을 지원하는 쓰기 지연/변경 감지/지연 로딩

### 3.4.1 엔티티 조회

- 1차 캐시
    - persistence context 내부 캐시
    - persist 상태의 entity는 모두 1차 캐시에 저장
    - @Id, entity instance, snapshot을 persistence context 1차 캐시에서 가지고 있음
- persistence context(entity manager) 내부 요소
    - 1차 캐시(id, instance, snapshot)
    - 쓰기 지연 SQL 저장소
- 조회
    - entitymanager.find(Class<T> entityClass, Object primaryKey)로 찾는다
    - 만약 entity가 1차 캐시에 들어가 있는 상태이면, 1차 캐시에 있는 데이터를 반환한다
    - 만약 entity가 1차 캐시에 없고, DB에만 있는 상태이면, 1. DB에서 조회한 후 2. 1차 캐시에 저장 후 3. 1차 캐시에 저장된 entity를 반환한다(이때 DB에서 꺼내진 데이터는 persist 상태가 된다)
- 등록
    - transaction.commit()으로 DB에 등록한다
    - entity manager는 트랜잭션을 커밋하기 전까지 DB에 entity를 저장하지 않고 쓰기 지연 SQL 저장소에 SQL을 모아둔다. 이것을 쓰기 지연이라고 한다
    - 1차 캐시에 entity가 들어가면 SQL문을 쓰기 지연 SQL 저장소에 등록해둔다.
    - entity manager에 commit 요청이 들어오면 entity manager는 persistence context를 flush한다.
    - flush: 변경내용을 DB에 동기화하는 작업, 등록/수정/삭제한 엔티티를 DB에 반영한다
    - 쓰기 지연이 가능한 이유: SQL을 바로 DB로 전달해도 트랜잭션 커밋을 하지 않으면 DB가 변경을 동기화하지 않기 때문에
- 수정
    - entity.setter(xxx)로 데이터 수정한다
    - 영속적인 상태의 데이터를 수정하면 1차 캐시에서 snapshot과 entity를 비교해서 변경내용을 자동감지하여 SQL을 쓰기 지연 SQL 저장소에 등록한다
    - 변경 감지: entity의 변경사항을 데이터베이스에 자동으로 반영하는 기능
    - snapshot: 최초 상태를 복사해서 저장해 두는 것
    - 순서
        1. commit하면 em 내부에서 flush가 호출된다.
        2. entity와 snapshot을 비교해서 변경된 entity를 찾는다
        3. 변경된 entity가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다
        4. SQL을 DB로 보낸다
        5. DB에서 트랜잭션을 commit한다.
    - JPA의 persistence context 업데이트 전략: entity의 모든 field를 업데이트한다
    - 상황에 따라 수정된 데이터만 사용해서 update sql을 생성하기도 한다. 이때는 @org.hibernate.annotations.DynamicUpdate 어노테이션(하이버네이트 확장기능)을 사용해야 한다.
    - 데이터가 null이 아닌 필드만 Insert sql로 동적 생성하는 @DynamicInsert도 있다
- 삭제
    - em.find(xxxx)로 찾은 후에 em.remove(entity)로 제거한다.
    - 삭제 쿼리는 쓰기 지연 SQL 저장소에 있다가 commit하면 DB에 삭제 query를 전달한다
    - em.remove(entity)를 하면 해당 entity는 persistence context에서 제거된다

### 3.5 플러시

- flush: persistence context의 변경 내용을 DB와 동기화
- 변경 감지 동작해서 모든 entity와 snapshot 비교해서 수정된 entity 찾기 → 수정된 entity는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록 → 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)
- flush 방법
    - em.flush() 직접 호출
    - 트랜잭션 커밋 시 flush 자동 호출
    - JPQL 쿼리 실행 시 flush 자동 호출(JPQL 쿼리 실행 이전에 엔티티 변경 상태를 동기화해야 하기 때문에)
- flush options
    - FlushModeType.AUTO: commit이나 query 실행 시 플러시(default)
    - FlushModeType.COMMIT: commit할 때만 flush

### 3.6 준영속

- 준영속 상태: entity가 persistence context가 제공하는 기능을 사용할 수 없는 상태, 영속 상태였다가 영속성 콘텍스트가 관리하지 않는 상태, 분리된 상태
- 영속→준영속 방법
    - em.detach(entity): 특정 entity만 준영속 상태로 전환, 메소드 호출하는 순간 1차 캐시와 쓰기 지연 SQL이 모두 삭제된다.
    - em.clear(): persistence context 초기화, 전체 entity 준영속 상태
    - em.close(): persistence context 종료(entity manager 종료)
- 특징
    - 비영속 상태에 가까움
    - 식별자 값 가지고 있음
    - 지연 로딩 불가
- 병합: 준영속 상태의 entity를 다시 영속 상태로 변경, 새로운 영속 상태의 엔티티를 반환
    - em.merge(entity) → 기존의 entity로 영속상태가 되는 것이 아닌 새로운 영속 상태의 엔티티를 반환한다.(entity → mergedEntity)
    - 준영속 상태일 때 변경된 데이터는 Persistence context와 DB에 반영되지 않는다.
    - 비영속 상태의 entity도 영속 상태로 만들 수 있다.(병합은 준영속, 비영속 신경쓰지 않는다)

### 정리

1. 엔티티 매니저는 엔티티 매니저 팩토리에서 생성
2. 영속성 콘텍스트는 엔티티 매니저를 통해서만 접근 가능
3. 영속성 콘텍스트는 app과 DB 사이에서 객체를 보관하는 가상의 DB 역할
4. 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 기능
5. 영속성 컨텍스트에 저장한 엔티티는 flush 시점에 DB에 반영
6. 영속성 컨텍스트가 관리하는 엔티티를 영속 상태의 엔티티라고 하고, 준영속 상태의 엔티티는 영속성 콘텍스트의 관리를 받지 못한다.