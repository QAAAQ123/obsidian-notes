- ORM: Object-Relational Mapping, 객체와 RDB 매핑
- JPA: JAVA ORM 기술 표준
- 스프링 데이터 JPA: 스프링 진영에서 지원하는 JPA

#### 1.1 SQL을 직접 다룰 때 문제점

★자바 애플리케이션은 JDBC API를 이용하여 SQL을 DB에 전달★

DAO: 데이터 접근 객체

- JDBC만으로 회원 조회 기능 생성: SQL 작성 -> JDBC로 SQL 실행 -> 조회 결과 매핑
- JDBC만으로 회원 등록 기능 생성: SQL 작성 -> 회원 객체에서 값을 꺼내 SQL로 전달 -> JDBC로 SQL 실행 -> DB에 저장됨
- 기능을 추가하는 만큼 위의 과정을 반복해야 한다. 이렇게 코드를 작성하면 매우 비효율적이다.
- 기능을 추가할 때마다 SQL문을 작성해야 함 => SQL에 의존적인 코드가 됨

문제점

1. **진정한 의미의 계층 분할이 어려움**
2. **엔티티를 신뢰할 수 없음**
3. **SQL에 의존적인 개발을 하게 됨**

=> 위 문제들을 JPA를 통해 해결할 수 있다

#### 1.2 패러다임 불일치

★객체는 속성(필드)와 기능(메소드)를 가진다.★

★객체는 참조를 사용하여 다른 객체와 연관관계를 맺고 참조에 접근하여 연관된 객체를 조회한다.★

★테이블은 외래키를 사용하여 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관된 테이블을 조회한다.★

**=> 객체와 테이블 사이에 "속성을 통해 관계를 맺는다"라는 표면적인 유사성이 있으나, 근본적으로 패러다임이 일치하는 것은 아니다**

- RDB와 객체는 서로 지향하는 목적이 다르기 때문에 패러다임이 서로 불일치한다 
- 패러다임 불일치를 중간에서 개발자가 해결해야 하는데 시간이 너무 오래 걸린다.
- => JPA가 해결  
    예시) Item을 상속받는 Album 객체를 JPA를 통해 저장하면 알아서 Item과 Album 속성을 분리해 저장하고 검색할 때에도 조인하여 결과를 보여준다
- 팀과 멤버를 만들 때 객체지향적인 방법과 테이블에 맞춘 모델이 있다
- 테이블에 맞춘 멤버 클래스는 teamId를 외래키처럼 Long teamId를 쓰고, 객체지향적 멤버 클래스는 teamId를 객체처럼 Team team으로 작성해야 한다.
- **=> 테이블에 맞춘 멤버id는 객체처럼 사용하기 어렵고, 객체지향에 맞춘 멤버id는 테이블에서 사용하기 어렵다**
- **객체는 참조를 사용하여 객체간 그래프 탐색을 계속할 수 있지만, SQL은 탐색할 수 있는 객체에 한계가 있다.**

DB와 JAVA 값 접근 방식 비교

- DB는 기본키의 값으로 각 row를 구분한다.(값 중심 데이터 읽기)
- 객체는 동일성 비교와 동등성 비교 두 가지가 존재한다.(참조 중심 데이터 읽기)
    - 동일성(identity) 비교: '==' 비교 -> 객체의 주소 값 비교
    - 동등성(equality) 비교: equals() 메소드 -> 객체 내부의 값 비교

#### 결론

객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다. 이 틈을 개발자가 직접 메우면 개발자가 소모하는 비용이 커지고 비즈니스 로직에 집중하지 못하며 데이터 중심 모델로 변질될 수 있다. 이 불편함을 해결해 주는 게 ORM이고 JAVA에서는 JPA를 사용한다.

#### 1.3 JPA란 무엇인가?
![[JPA 구조.jpg]]
- JPA는 자바 진영의 ORM 기술 표준이다
- ORM은 객체와 관계형 데이터베이스를 매핑한다.
- ORM은 단순히 SQL을 개발자 대신 생성해서 DB에 전달하는 것뿐만 아니라, 패러다임 불일치 문제 해결도 해준다
- 자바 진영의 ORM 프레임워크 중 가장 많이 쓰이는 것이 **하이버네이트 프레임워크**이다.
- JPA는 자바 ORM 기술에 대한 API 표준 명세서(인터페이스 모아둔 것)
- JPA 2.1을 구현한 ORM 표준 프레임워크는 하이버네이트, 이클립스 등이 있다
- JPA 사용 이유: 생산성/유지보수/패러다임 불일치 해결/성능/데이터 접근 추상화와 벤더 독립성/표준
- JPA 핵심 개념: 영속성 컨텍스트