[링크](https://school.programmers.co.kr/learn/courses/30/lessons/86491)

## 1. 문제 이해
명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

| 명함 번호 | 가로 길이 | 세로 길이 |
| ----- | ----- | ----- |
| 1     | 60    | 50    |
| 2     | 30    | 70    |
| 3     | 60    | 30    |
| 4     | 80    | 40    |

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

- 명함이 모두 들어가는 지갑 크기 만들기(돌려도 상관없음)


## 2.입력 크기 및 시간/메모리 제한 확인

- sizes의 길이는 1 이상 10,000 이하입니다.
    - sizes의 원소는 [w, h] 형식입니다.
    - w는 명함의 가로 길이를 나타냅니다.
    - h는 명함의 세로 길이를 나타냅니다.
    - w와 h는 1 이상 1,000 이하인 자연수입니다.

## 3. 자료구조 및 알고리즘
- brute-force
## 4. 로직 설계
- w에 작은값,h에는 큰 값으로 바꿈
- w에서는 가장 큰 값,h에서는 가장 작은 큰값을 곱함

## 5. 복잡도 검증
- size 정렬하는데 O($N$)
- 정렬하면서 바로 max값 확인하니까 O(1)
- 결론: O(N)

## 6. 라이브러리 선택
- Math.max
- for

## 7. 검증
```java
class Solution {
    public int solution(int[][] sizes) {
        int maxW = Math.min(sizes[0][0],sizes[0][1]);
        int maxH = Math.max(sizes[0][0],sizes[0][1]);
        int tempW = 0;
        int tempH = 0;
        
        for(int i = 1;i < sizes.length; i++){
            tempW = Math.min(sizes[i][0],sizes[i][1]);
            tempH = Math.max(sizes[i][0],sizes[i][1]);
            if(maxW < tempW){
                maxW = tempW;
            }
            if(maxH < tempH){
                maxH = tempH;
            }
        }
        
        return maxW * maxH;
    }
}
```

## 8. 몰랐던 메소드 정리
- 없음