[링크](https://school.programmers.co.kr/learn/courses/30/lessons/42839)

## 1. 문제
한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.

각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.

## 2. 문제 이해
- 문자열로 숫자가 들어오면 하나씩 분리
- 가능한 모든 수 조합에서 소수만 리턴

## 3.입력 크기 및 시간/메모리 제한 확인
- numbers는 길이 1 이상 7 이하인 문자열입니다.
- numbers는 0~9까지 숫자만으로 이루어져 있습니다.
- "013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.

## 4. 최대 시간복잡도 확인
- N=7
- N!= 5040
- O(N!)까지 가능

## 5. 자료구조 및 알고리즘
- Brute force
- Set,HashSet

## 6. 로직 설계
- numbers를 숫자한개씩 분리하여 string arr만듦
- 이중 for문으로 가능한 모든 수 set 만듦(이때 String->int로)(bucket)
- 소수 판별
	- 모든 개별 수를 2부터 num까지 for문
		- if: (`num%i==0` || num < 2) => bucket에서 뺌
- 완료한 bucket을 리턴
### 6.1 예외 케이스
- 0,1이 있을 경우: 0,1은 소수가 아니기 때문에 소수 판별 for문에서 예외 사항을 추가
- 11과 011은 같은 숫자로 취급합니다.=> 이건 Integer.valueOf이 자동으로 해결함
## 7. 시간복잡도 검증
- string arr만들때: O(N)
- 가능한 모든 숫자 배열 만들 때: $O(N!)$
- 소수 판별: $N!$개를 판별해야함
	- 개별 수 소수 검증: O(L)
- $O(N) + O(N!) + O(N! \times L)$
- 결론:$O(N! \times L)$

## 8. 코드 검증
```java

```
## 9. 몰랐던 메서드 정리
