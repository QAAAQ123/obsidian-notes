[링크](https://school.programmers.co.kr/learn/courses/30/lessons/42839)

## 1. 문제
한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.

각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.

## 2. 문제 이해
- 문자열로 숫자가 들어오면 하나씩 분리
- 가능한 모든 수 조합에서 소수만 리턴
- 소수: 약수가 1과 자신 밖에 없는 수

## 3.입력 크기 및 시간/메모리 제한 확인
- numbers는 길이 1 이상 7 이하인 문자열입니다.
- numbers는 0~9까지 숫자만으로 이루어져 있습니다.
- "013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.

## 4. 최대 시간복잡도 확인
- N=7
- N!= 5040
- O(N!)까지 가능

## 5. 자료구조 및 알고리즘
- Brute force
- Set,HashSet

## 6. 로직 설계
- numbers를 숫자한개씩 분리하여 string arr만듦
- ~~이중 for문으로 가능한 모든 수 set 만듦(이때 String->int로)(bucket)~~-> 함수재귀나 반복문으로 만들어야함
- 소수 판별
	- 모든 개별 수를 2부터 num까지 for문
		- if: (`num%i==0` || num < 2) => bucket에서 뺌
- 완료한 bucket을 리턴
### 6.1 예외 케이스
- 0,1이 있을 경우: 0,1은 소수가 아니기 때문에 소수 판별 for문에서 예외 사항을 추가
- 11과 011은 같은 숫자로 취급합니다.=> 이건 Integer.parseInt가 자동으로 해결함
## 7. 시간복잡도 검증
- string arr만들때: O(N)
- 가능한 모든 숫자 배열 만들 때: $O(N!)$
- 소수 판별: $N!$개를 판별해야함
	- 개별 수 소수 검증: O(L)
- $O(N) + O(N!) + O(N! \times L)$
- 결론:$O(N! \times L)$

## 8. 코드 검증
```java
import java.util.*;
class Solution {
    public int solution(String numbers) {
        Set<Integer> bucket = new HashSet<>();
        //가능한 모든 수 생성
        dfs("",numbers,bucket);
        
        int count = 0;
        //소수 개수 판별
        for(int num: bucket){
            if(num < 2) continue;
            
            boolean t = true;
            for(int i = 2; i < num;i++){
                if(num%i == 0) {
                    t = false;
                    break;
                }
            }
            
            if(t) count++;
        }
        
        return count;
        
    }
    
    private void dfs(String combined, String others, Set<Integer> bucket){
        if(!combined.equals("")) bucket.add(Integer.parseInt(combined));
        
        for(int i = 0; i < others.length(); i++){
            dfs(combined + others.charAt(i), 
                others.substring(0,i)+others.substring(i+1),
                bucket);
        }
    }
}

```
## 9. 몰랐던 것 정리
- 컬렉션은 **순회할때 크기 변경 불가**: ConcurrentModificationException 예외 발생
- 가나다라
	- substring(x,y): x부터 y이전까지
		- substring(1,3):"나다" 
	- substring(x): x이후부터 끝까지
		- substring(2):"다라"
- Integer.ParseInt()나 Interger.ValueOf()은 맨 앞자리의 0을 자동을 떼어냄
	- "034" -> 34
### 소수 찾기 로직
0. 정의: 1과 자기자신만으로 나누어떨어지는 1보다 큰 양의 정수
1. 예외: 0과 1은 소수가 아님
2. 판별범위
	1. $\sqrt n$ 을 기준으로 서로 짝을 이룸
	2. (1,16)(2,8)(4,4)(8,2)(16,1)임-> $\sqrt 16$까지만 해주면 뒤는 자동 검증
	3. 결론: 2부터 $\sqrt n$까지만 나누어떨어지는지 확인하면 됨
3. 논리 구성
	1. 일단 해당 숫자가 **소수라고 가정**합니다 (`boolean isPrime = true`).
	2. 2부터 제곱근까지 숫자를 키워가며 나머지를 확인합니다.
	3. 만약 하나라도 나누어떨어지는 수(약수)가 발견되면:
	    - **소수가 아님**을 표시합니다 (`isPrime = false`).
	    - 효율성을 위해 즉시 검사를 중단합니다 (`break`).
	4. 반복문이 끝난 후, 여전히 `isPrime`이 `true`라면 그 숫자는 소수입니다.

#### 추가 에라토스테네스의 체 비교
|**구분**|**제곱근 방식 (O(N​))**|**에라토스테네스의 체 (O(NloglogN))**|
|---|---|---|
|**핵심 원리**|특정 숫자 하나가 소수인지 직접 확인|2부터 시작해 배수들을 모두 지워나감|
|**장점**|메모리 사용이 거의 없음|범위 내의 모든 소수를 찾는 속도가 매우 빠름|
|**단점**|여러 숫자를 각각 검사하면 중복 계산 발생|숫자의 범위만큼 배열(메모리)을 미리 만들어야 함|