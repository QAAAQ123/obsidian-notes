[링크](https://school.programmers.co.kr/learn/courses/30/lessons/42583)
#queue
## 1. 문제 이해
트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.

예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.

|경과 시간|다리를 지난 트럭|다리를 건너는 트럭|대기 트럭|
|---|---|---|---|
|0|[]|[]|[7,4,5,6]|
|1~2|[]|[7]|[4,5,6]|
|3|[7]|[4]|[5,6]|
|4|[7]|[4,5]|[6]|
|5|[7,4]|[5]|[6]|
|6~7|[7,4,5]|[6]|[]|
|8|[7,4,5,6]|[]|[]|

따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.

solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.

- 다리를 지나가는데 걸리는 최소 시간 구하기
- 최대 무게가 있음
- 다리에 들어가거나 다리를 빠져 나가는 트럭은 각 1대씩만 가능
## 2.입력 크기 및 시간/메모리 제한 확인
- bridge_length는 1 이상 10,000 이하입니다.
- weight는 1 이상 10,000 이하입니다.
- truck_weights의 길이는 1 이상 10,000 이하입니다.
- 모든 트럭의 무게는 1 이상 weight 이하입니다.

- 길이는 truck_weights에 따라서 결정 => N= 10,000
- $N^2$=100,000,000=1억
	- $N^2$ 까지 가능,but 비효율적

## 3. 자료구조 및 알고리즘
- Queue

## 4. 로직 설계
- bridge_length의 길이인 큐를 생성(0으로 초기화);
- currentWeight 생성
- while: truck_weights의 index가 마지막이고 currentWeight가 0일때 종료
	- if: queue가 비어있지 않을 때
		- queue를 poll하고 currentWeight를 offer값 만큼 감소시킴
	- if: (truck_weights[i]의 값 + currentWeight)가 <= weight일때
		- queue에 offer(truck_weights[i])함
	- else
		- 아니라면 한칸씩 트럭을 밀어줘야 하기 때문에 offer(0)을 해야함
	- time++

- while 수정: 위의 것으로 조건을 하면 outofboundsexception이 나옴 
	- 트럭 배열 인덱스가 트럭 배열의 길이를 넘지 않게 바꾸고, 마지막 트럭이 큐에 들어가면 종료하고 시간+다리 길이를 리턴하게 수정

## 5. 복잡도 검증
- bridge_lenght길이 큐 생성: O(L)
- while loop: $O(N+\alpha)$
- 결론: O(N)
## 6. 라이브러리 선택
* Queue
* ArrayDeque

## 7. 검증
```java
import java.util.*;

class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Integer> queue = new ArrayDeque<>();
        int currentWeight = 0;
        int time = 0;
        int truckIndex = 0;
        for(int i = 0; i < bridge_length; i++){
            queue.offer(0);
        }
        
        while(truckIndex < truck_weights.length){
            currentWeight -= queue.poll();
            if(truck_weights[truckIndex] + currentWeight <= weight){
                currentWeight += truck_weights[truckIndex];
                queue.offer(truck_weights[truckIndex]);
                truckIndex++;
            }else{
                queue.offer(0);
            }
            time++;
            
        }
        return time + bridge_length;
    }
}
```
## 8. 몰랐던 메소드 정리
