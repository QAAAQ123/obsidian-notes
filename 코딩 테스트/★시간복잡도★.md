

$$O(1) < O(\log N) < O(N) < O(N \log N) < O(N^2) < O(2^N) < O(N!)$$

| **복잡도**           | **특징**                              | **가능 N 범위 (1초 기준)** |
| ----------------- | ----------------------------------- | ------------------- |
| **$O(1)$**        | **상수:** 해시 맵 조회, 스택 삽입/삭제           | 제한 없음               |
| **$O(\log N)$**   | **로그:** 이진 탐색 (데이터가 매번 절반이 됨)       | $10^{18}$ (**백경**)  |
| **$O(N)$**        | **선형:** 단일 `for`문, 해시 루프, 투 포인터     | $10^7$ (**천만**)     |
| **$O(N \log N)$** | **선형 로그:** `Arrays.sort()`, 효율적인 정렬 | $10^5$ (**십만**)     |
| **$O(N^2)$**      | **이차:** 이중 `for`문, 버블/선택 정렬         | $2,000 \sim 5,000$  |
| **$O(2^N)$**      | **지수:** 재귀 함수, 부분 집합 구하기            | $20 \sim 25$        |
| **$O(N!)$**       | **계승:** 순열(모든 경우의 수 나열), 최악의 성능     | $10$                |

| **N의 크기**               | **허용 시간 복잡도**         | **추천 알고리즘/자료구조**                |
| ----------------------- | --------------------- | ------------------------------- |
| **$500$ (오백) **         | $O(N^3)$              | 3중 for문 (브루트포스)                 |
| **$2,000$ (이천) **       | $O(N^2)$              | 2중 for문, 버블/선택 정렬               |
| **$100,000$ (십만) **     | **$O(N \log N)$**     | **Arrays.sort**, 힙(Heap), 병합 정렬 |
| **$1,000,000$ (백만) **   | **$O(N)$**            | **해시(Hash)**, 투 포인터, 스택/큐, DP   |
| **$10,000,000$ (천만) **  | $O(N)$                | 단일 루프, 해시, 그리디                  |
| **$100,000,000$ (일억) ** | $O(\log N)$ 또는 $O(1)$ | 이진 탐색, 해시 룩업                    |
