[링크](https://school.programmers.co.kr/learn/courses/30/lessons/42626)
#priorityqueue
## 1. 문제 이해
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

```
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
```

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.  
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

---
- 작은 인덱스부터 위의 공식을 이용해서 계산함
	- 스코빌 배열이 작아짐
- 배열의 있는 모든 수가 K이상일때 공식을 사용한 횟수 return
## 2.입력 크기 및 시간/메모리 제한 확인
- scoville의 길이는 2 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.
---
- N=1,000,000(백만)
- $\log_{2}N$은 대략 20이라고 함. 
- 따라서 $O(N \times \log_2N)$까지 가능함(2천만)
## 3. 자료구조 및 알고리즘
- 최소 힙-root node의 값 >= k이면 공식 횟수 return 
## 4. 로직 설계
- 최소 힙 생성
- scoville 전체를 최소 힙에 넣음
- count 생성
- while(최소힙의 root값 < k)
	- root에서 연속으로 2개 꺼냄
	- 공식을 함
	- 나온 결과값을 최소 힙에 다시 넣음
	- count값 증가 시킴
	- 종료 조건: 최소힙의 크기가 1이면 더이상 계산이 불가하기 때문에 -1리턴
- count 값 return
## 5. 복잡도 검증
- 힙에 넣을 때: $O(N\log N)$
- while문: scoville-1번 반복 => O(N)
	- poll할때: $O(\log N)$ x 2
	- 공식 계산하고 다시 넣을 때: $O(\log N)$
- while문: $O(N \log N)$
- 결론: $O(N \log N)$

## 6. 라이브러리 선택
- PriorityQueue
- Queue

## 7. 검증
```java
import java.util.*;

class Solution {
    public int solution(int[] scoville, int K) {
        Queue<Integer> bucket = new PriorityQueue<>();
        int count = 0;
        
        for(int i: scoville) { bucket.add(i); }
        
        
        while(bucket.peek() < K){
            if(bucket.size() < 2) return -1;
            
            bucket.add(bucket.poll() + 2*bucket.poll());
            count++;
        }
       return count; 
    }
}
```
## 8. 몰랐던 메소드 정리
PriorityQueue spelling